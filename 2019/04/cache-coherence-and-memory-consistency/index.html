<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/theme/favicon-100x100.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/theme/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/theme/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wudaijun.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文主要谈谈CPU Cache的设计，内存屏障的原理和用法，最后简单聊聊内存一致性。 我们都知道存储器是分层级的，从CPU寄存器到硬盘，越靠近CPU的存储器越小越快，离CPU越远的存储器越大但越慢，即所谓存储器层级(Memory Hierarchy)。以下是计算机内各种存储器的容量和访问速度的典型值。     存储器类型 容量 特性 速度     CPU寄存器 几十到几百Bytes 数据电路触发器">
<meta property="og:type" content="article">
<meta property="og:title" content="Cache一致性和内存一致性">
<meta property="og:url" content="http://wudaijun.com/2019/04/cache-coherence-and-memory-consistency/index.html">
<meta property="og:site_name" content="wudaijun&#39;s blog">
<meta property="og:description" content="本文主要谈谈CPU Cache的设计，内存屏障的原理和用法，最后简单聊聊内存一致性。 我们都知道存储器是分层级的，从CPU寄存器到硬盘，越靠近CPU的存储器越小越快，离CPU越远的存储器越大但越慢，即所谓存储器层级(Memory Hierarchy)。以下是计算机内各种存储器的容量和访问速度的典型值。     存储器类型 容量 特性 速度     CPU寄存器 几十到几百Bytes 数据电路触发器">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://wudaijun.com/assets/image/201904/cache-simple.png">
<meta property="og:image" content="http://wudaijun.com/assets/image/201904/cache-geometry.png">
<meta property="og:image" content="http://wudaijun.com/assets/image/201904/mesi-example.png">
<meta property="og:image" content="http://wudaijun.com/assets/image/201904/cache-with-store-buffer.png">
<meta property="og:image" content="http://wudaijun.com/assets/image/201904/cache-with-store-forwarding.png">
<meta property="og:image" content="http://wudaijun.com/assets/image/201904/cache-with-invalid-queue.png">
<meta property="article:published_time" content="2019-04-29T16:00:00.000Z">
<meta property="article:modified_time" content="2023-03-20T09:58:40.614Z">
<meta property="article:author" content="wudaijun">
<meta property="article:tag" content="os">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wudaijun.com/assets/image/201904/cache-simple.png">

<link rel="canonical" href="http://wudaijun.com/2019/04/cache-coherence-and-memory-consistency/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Cache一致性和内存一致性 | wudaijun's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="wudaijun's blog" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wudaijun's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Done is better than perfect</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wudaijun.com/2019/04/cache-coherence-and-memory-consistency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/theme/avatar.png">
      <meta itemprop="name" content="wudaijun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wudaijun's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Cache一致性和内存一致性
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-30 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-30T00:00:00+08:00">2019-04-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/os/" itemprop="url" rel="index"><span itemprop="name">os</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/cache-coherence-and-memory-consistency/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/cache-coherence-and-memory-consistency/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文主要谈谈CPU Cache的设计，内存屏障的原理和用法，最后简单聊聊内存一致性。</p>
<p>我们都知道存储器是分层级的，从CPU寄存器到硬盘，越靠近CPU的存储器越小越快，离CPU越远的存储器越大但越慢，即所谓存储器层级(Memory Hierarchy)。以下是计算机内各种存储器的容量和访问速度的典型值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>存储器类型</th>
<th>容量</th>
<th>特性</th>
<th>速度</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU寄存器</td>
<td>几十到几百Bytes</td>
<td>数据电路触发器，断电丢失数据</td>
<td>一纳秒甚至更低</td>
</tr>
<tr>
<td>Cache</td>
<td>分不同层级，几十KB到几MB</td>
<td>SRAM，断电丢失数据</td>
<td>几纳秒到几十纳秒</td>
</tr>
<tr>
<td>内存</td>
<td>几百M到几十G</td>
<td>DRAM，断电丢失数据</td>
<td>几百纳秒</td>
</tr>
<tr>
<td>固态硬盘(SDD)</td>
<td>几十到几百G</td>
<td>SSD，断电不丢失数据</td>
<td>几十微秒</td>
</tr>
<tr>
<td>机械硬盘(HDD)</td>
<td>上百G</td>
<td>磁性介质和磁头，断电不丢失数据</td>
<td>几毫秒</td>
</tr>
</tbody>
</table>
</div>
<p>从广义的概念上来说，所有的存储器都是其下一级存储器的Cache，CPU Cache缓存的是内存数据，内存缓存的是硬盘数据，而硬盘缓存的则是网络中的数据。本文只谈CPU Cache，一个简单的CPU Cache示意图如下:</p>
<p><img src="/assets/image/201904/cache-simple.png" alt=""></p>
<p>图中忽略了一些细节，现代的CPU Cache通常分为三层，分别叫L1,L2,L3 Cache, 其中L1,L2 Cache为每个CPU核特有，L3为所有CPU核共有，L1还分为缓存指令的i-cache(只读)和缓存程序数据的d-cache，L2 L3 Cache则不区分指令和程序数据，称为统一缓存(unified cache)。本文主要讨论缓存命中和缓存一致性的问题，因此我们只关注L1 Cache，不区分指令缓存和程序数据缓存。</p>
<span id="more"></span>
<h3 id="Cache-Geometry"><a href="#Cache-Geometry" class="headerlink" title="Cache Geometry"></a>Cache Geometry</h3><p>当CPU加载某个地址上的数据时，会从Cache中查找，Cache由多个Cache Line构成(通常L1 Cache的Cache Line大小为64字节)，因此目标地址必须通过某种转换来映射对应的Cache Line，我们可以很容易想到两种方案:</p>
<ol>
<li>指定地址映射到指定Cache Line，读Cache时对地址哈希(通常是按照Cache Line数量取模，即在二进制地址中取中间位)来定位Cache Line，写Cache时如果有冲突则丢掉老的数据。这种策略叫<strong>直接映射</strong></li>
<li>任何地址都可以映射到任何Cache Line，读Cache时遍历所有Cache Line查找地址，写Cache时，可以按照LFU(最不常使用)或LRU(最近最少使用)等策略来替换。这种策略叫<strong>全相联</strong></li>
</ol>
<p>直接映射的缺点在于在特定的代码容易发生冲突不命中，假设某CPU Cache的Cache Line大小为16字节，一共2个Cache Line，有以下求向量点乘的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段1</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">dotprod</span><span class="params">(<span class="keyword">float</span> x[<span class="number">8</span>], <span class="keyword">float</span> y[<span class="number">8</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++)</span><br><span class="line">        sum += x[i] * y[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于x和y在函数栈中是连续存放的，<code>x[0..3]</code>和<code>y[0..3]</code>将映射到同一个Cache Line, <code>x[4..7]</code>和<code>y[4..7]</code>被映射到同一个Cache Line，那么在for循环一次读取<code>x[i]</code>,<code>y[i]</code>的过程中，Cache Line将不断被冲突替换，导致Cache “抖动”(thrashing)。也就是说，在直接映射中，即使程序看起来局部性良好，也不一定能充分利用Cache。</p>
<p>那么同样的例子，换成全相联，则不会有这个问题，因为LRU算法会使得<code>y[0..3]</code>不会替换<code>x[0..3]</code>所在的Cache Line，也就不会造成Cache抖动。全相连的缺点是由于每一次读Cache都需要遍历所有的Cache Line进行地址匹配，出于效率考虑，它不适用于太大的Cache。</p>
<p>So，现代OS的操作系统是取两者折中，即组相连结构: 将若干Cache Line分为S个组，组间直接映射，组内全相连，如下图:</p>
<p><img src="/assets/image/201904/cache-geometry.png" alt=""></p>
<p>通用的Cache映射策略，将目标地址分为t(标记位)，s(组索引)，b(块偏移)三个部分。我在<a href="http://wudaijun.com/2019/04/linux-perf/">Linux Perf 简单试用</a>中也有例子说明程序局部性对效率的影响。</p>
<h3 id="Cache-Coherence"><a href="#Cache-Coherence" class="headerlink" title="Cache Coherence"></a>Cache Coherence</h3><p>前面我们谈的主要是Cache的映射策略，Cache设计的最大难点其实在于Cache一致性: </p>
<ol>
<li>任何CPU所发出的访存操作被存储器所观察到的顺序必须与CPU发出操作的顺序相同</li>
<li>每个读操作所返回的值必须是最后一次对该存储位置的写操作的值</li>
</ol>
<p>以上两点，也可以理解为，如何在多层级(L1、L2、L3)，多核(每个核有自己的局部L1、L2缓存)的共享内存存储系统中，保持缓存的透明性，即对CPU而言，对内存地址的访问就像没有缓存系统一样。</p>
<p>举个例子，某CPU尝试修改某个地址值时，其它CPU可能已有该地址的缓存，甚至可能也在执行修改操作。因此该CPU需要先征求其它CPU的”同意”，才能执行写操作。这需要给各个CPU的Cache Line加一些标记(状态)，辅以CPU之间的通信机制(事件)来完成， 这可以通过MESI协议来完成。MESI是以下四个状态的简称:</p>
<p>M(modified): 该行刚被 CPU 改过，并且保证不会出现在其它CPU的Cache Line中。即CPU是该行的所有者。CPU持有该行的唯一正确参照。<br>E(exclusive): 和M类似，但是未被修改，即和内存是一致的，CPU可直接对该行执行修改(修改之后为modified状态)。<br>S(shared): 该行内容至少被一个其它CPU共享，因此该CPU不能直接修改该行。而需要先与其它CPU协商。<br>I(invalid): 该行为无效行，即为空行，前面提到Cache策略会优先填充Invalid行。</p>
<p>除了状态之外，CPU还需要一些消息机制:</p>
<p>Read: CPU发起读取数据请求，请求中包含需要读取的数据地址。<br>Read Response: 作为Read消息的响应，该消息可能是内存响应的，也可能是某CPU响应的(比如该地址在某CPU Cache Line中为Modified状态，该CPU必须返回该地址的最新数据)。<br>Invalidate: 该消息包含需要失效的地址，所有的其它CPU需要将对应Cache置为Invalid状态<br>Invalidate Ack: 收到Invalidate消息的CPU在将对应Cache置为Invalid后，返回Invalid Ack<br>Read Invalidate: 相当于Read消息+Invalidate消息，即取得数据并且独占它，将收到一个Read Response和所有其它CPU的Invalid Ack<br>Writeback: 写回消息，即将状态为Modified的行写回到内存，通常在该行将被替换时使用。现代CPU Cache基本都采用”写回(Write Back)”而非”直写(Write Through)”的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">思考: 为什么要有专门的Read Invalidate消息，而不直接用Read + Invalidate消息的方式呢？</span><br></pre></td></tr></table></figure>
<p>具体MESI状态机的转换不再赘述，本质上来说，CPU体系结构依赖消息传递的方式来共享内存。</p>
<p>下面举个例子，假设我们有个四核CPU系统，每个CPU只有一个Cache Line，每个Cache Line包含一个字节，内存地址空间为0x0-0xF，一共两个字节的数据，有如下操作序列:</p>
<p><img src="/assets/image/201904/mesi-example.png" alt=""></p>
<p>上图第一列代表操作发生的时序，第二列是执行操作的CPU，第三列是CPU执行的操作，后面四列是各个CPU的Cache Line状态，最后两列是地址0和地址8在内存中的数据是是最新的(V)还是过期的(I)。初始状态下，每个CPU Cache Line都是未填充(Invalid)的。</p>
<ol>
<li>CPU0 加载地址0x0的数据，发送Read消息，对应Cache Line被标记为Shared</li>
<li>CPU3 加载地址0x0的数据，同样，Cache Line标记为Shared</li>
<li>CPU0 加载地址0x8的数据，导致Cache Line被替换，由于Cache Line之前为Shared状态，即与内存中数据一致，可直接覆盖Cache Line，而无需写回</li>
<li>CPU2 加载地址0x0的数据，并且之后将要修改它，因此CPU2发出Read Invalidate消息以获取该地址的独占权，导致CPU3的Cache Line被置为Invalid，CPU2 Cache Line为Exclusive</li>
<li>CPU2 修改地址0x0的数据，由于此时Cache Line为Exclusive，因此它可以直接修改Cache Line，此时Cache Line状态为Modified。此时内存中的0x0内存为过期数据(I)</li>
<li>CPU1 对地址0x0的数据执行原子(atomic)递增操作，将发出Read Invalidate消息，CPU2将返回Read Response(而不是内存)，然后CPU1将持有地址0x0的Cache Line，状态为Modified，数据为递增后的数据，CPU2的Cache Line为Invalid，内存中的数据仍然是过期(I)状态</li>
<li>CPU1 加载地址0x0的数据，此时CPU1 Cache Line将被替换，由于其状态为Modified，因此需要先执行写回操作将Cache Line写回内存，此时内存中的数据才是最新(V)的</li>
</ol>
<h3 id="Store-Buffers"><a href="#Store-Buffers" class="headerlink" title="Store Buffers"></a>Store Buffers</h3><p>MESI协议足够简单，并且能够满足我们对Cache一致性的需求，它在单个CPU对指定地址的反复读写方面有很好的性能表现，但在某个CPU尝试修改在其它CPU Cache Line中存在的数据时，性能表现非常糟糕，因为它需要发出Invalidate消息并等待Ack，这个延迟(Stall)对CPU来说对难以忍受的并且有时是无必要的，比如执行写入的CPU可能只是简单的给这个地址赋值(而不关心它的当前值是什么)。解决这类不必要的延迟的一个方案就是在CPU和Cache之间加一个Store Buffer: CPU可以先将要写入的数据写到Store Buffer，然后继续做其它事情。等到收到其它CPU发过来的Cache Line(Read Response)，再将数据从Store Buffer移到Cache Line。结构如下所示:</p>
<p><img src="/assets/image/201904/cache-with-store-buffer.png" alt=""></p>
<p>然后加了Store Buffer之后，会引入另一个问题，比如有如下代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段2</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = a + <span class="number">1</span>;</span><br><span class="line">assert(b == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>初始状态下，假设a,b值都为0，并且a存在CPU1的Cache Line中(Shared状态)，可能出现如下操作序列:</p>
<ol>
<li>CPU0 要写入A，发出Read Invalidate消息，并将a=1写入Store Buffer</li>
<li>CPU1 收到Read Invalidate，返回Read Response(包含a=0的Cache Line)和Invalidate Ack</li>
<li>CPU0 收到Read Response，更新Cache Line(a=0)</li>
<li>CPU0 开始执行 <code>b = a + 1</code>，从Cache Line中加载a，得到a=0</li>
<li>CPU0 将Store Buffer中的a=1应用到Cache Line</li>
<li>CPU0 得到 b=0+1，断言失败</li>
</ol>
<p>造成这个问题的根源在于对同一个CPU存在对a的两份拷贝，一份在Cache，一份在Store Buffer，前者用于读，后者用于写，因而出现CPU执行顺序与程序顺序(Program Order)不一致(先执行了<code>b=a+1</code>，再执行<code>a=1</code>)。</p>
<h3 id="Store-Forwarding"><a href="#Store-Forwarding" class="headerlink" title="Store Forwarding"></a>Store Forwarding</h3><p>Store Buffer可能导致破坏程序顺序(Program Order)的问题，硬件工程师在Store Buffer的基础上，又实现了”Store Forwarding”技术: CPU可以直接从Store Buffer中加载数据，即支持将CPU存入Store Buffer的数据传递(forwarding)给后续的加载操作，而不经由Cache。结构如图:</p>
<p><img src="/assets/image/201904/cache-with-store-forwarding.png" alt=""></p>
<p>现在解决了同一个CPU读写数据的问题，再来看看并发程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段3</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    assert(a == <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设初始状态下，<code>a=0; b=0;</code>，a存在于CPU1的Cache中，b存在于CPU0的Cache中，均为Exclusive状态，CPU0执行foo函数，CPU1执行bar函数，上面代码的预期显然为断言为真。那么来看下执行序列:</p>
<ol>
<li>CPU1执行<code>while(b == 0)</code>，由于CPU1的Cache中没有b，发出<code>Read b</code>消息</li>
<li>CPU0执行<code>a = 1</code>，由于CPU0的Cache中没有a，因此它将<code>a(当前值1)</code>写入到Store Buffer并发出<code>Read Invalidate a</code>消息</li>
<li>CPU0执行<code>b = 1</code>，由于b已经存在在Cache中(Exclusive)，因此可直接执行写入</li>
<li>CPU0收到<code>Read b</code>消息，将Cache中的b(当前值1)返回给CPU1，将b写回到内存，并将Cache Line状态改为Shared</li>
<li>CPU1收到包含b的Cache Line，结束<code>while (b == 0)</code>循环</li>
<li>CPU1执行<code>assert(a == 1)</code>，由于此时CPU1 Cache Line中的a仍然为0并且有效(Exclusive)，断言失败</li>
<li>CPU1收到<code>Read Invalidate a</code>消息，返回包含a的Cache Line，并将本地包含a的Cache Line置为Invalid(已经晚了)</li>
<li>CPU0收到CPU1传过来的Cache Line，然后将Store Buffer中的a(当前值1)刷新到Cache Line</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">思考: 为什么CPU0执行&#96;a&#x3D;1&#96;时要发送Read Invalidate而不直接发送Invalidate?</span><br></pre></td></tr></table></figure>
<p>出现这个问题的原因在于CPU不知道a, b之间的数据依赖，CPU0对a的写入走的是Store Buffer(有延迟)，而对b的写入走的是Cache，因此b比a先在Cache中生效，导致CPU1读到<code>b=1</code>时，a还存在于Store Buffer中。</p>
<h3 id="Memory-Barrier"><a href="#Memory-Barrier" class="headerlink" title="Memory Barrier"></a>Memory Barrier</h3><p>对于上面的内存不一致，很难从硬件层面优化，因为CPU不可能知道哪些值是相关联的，因此硬件工程师提供了一个叫内存屏障的东西，开发者可以用它来告诉CPU该如何处理值关联性。我们可以在<code>a=1</code>和<code>b=1</code>之间插入一个内存屏障:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段4</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    smp_mb()</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    assert(a == <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当CPU看到内存屏障<code>smp_mb()</code>时，会先刷新当前(屏障前)的Store Buffer，然后再执行后续(屏障后)的Cache写入。这里的”刷新Store Buffer”有两种实现方式: 一是简单地刷新Store Buffer(需要挂起等待相关的Cache Line到达)，二是将后续的写入也写到Store Buffer中，直到屏障前的条目全部应用到Cache Line(可以通过给屏障前的Store Buffer中的条目打个标记来实现)。这样保证了屏障前的写入一定先于屏障后的写入生效，第二种方案明显更优，以第二种方案为例:</p>
<ol>
<li>CPU1执行<code>while(b == 0)</code>，由于CPU1的Cache中没有b，发出<code>Read b</code>消息</li>
<li>CPU0执行<code>a = 1</code>，由于CPU0的Cache中没有a，因此它将<code>a(当前值1)</code>写入到Store Buffer并发出<code>Read Invalidate a</code>消息</li>
<li>CPU0看到<code>smp_mb()</code>内存屏障，它会标记当前Store Buffer中的所有条目(即<code>a = 1</code>被标记)</li>
<li>CPU0执行<code>b = 1</code>，尽管b已经存在在Cache中(Exclusive)，但是由于Store Buffer中还存在被标记的条目，因此b不能直接写入，只能先写入Store Buffer中</li>
<li>CPU0收到<code>Read b</code>消息，将Cache中的b(当前值0)返回给CPU1，将b写回到内存，并将Cache Line状态改为Shared</li>
<li>CPU1收到包含b的Cache Line，继续<code>while (b == 0)</code>循环</li>
<li>CPU1收到<code>Read Invalidate a</code>消息，返回包含a的Cache Line，并将本地的Cache Line置为Invalid</li>
<li>CPU0收到CPU1传过来的包含a的Cache Line，然后将Store Buffer中的a(当前值1)刷新到Cache Line，并且将Cache Line状态置为Modified</li>
<li>由于CPU0的Store Buffer中被标记的条目已经全部刷新到Cache，此时CPU0可以尝试将Store Buffer中的<code>b=1</code>刷新到Cache，但是由于包含B的Cache Line已经不是Exclusive而是Shared，因此需要先发<code>Invalid b</code>消息</li>
<li>CPU1收到<code>Invalid b</code>消息，将包含b的Cache Line置为Invalid，返回<code>Invalid Ack</code></li>
<li>CPU1继续执行<code>while(b == 0)</code>，此时b已经不在Cache中，因此发出Read消息</li>
<li>CPU0收到<code>Invalid Ack</code>，将Store Buffer中的<code>b=1</code>写入Cache</li>
<li>CPU0收到Read消息，返回包含b新值的Cache Line</li>
<li>CPU1收到包含b的Cache Line，可以继续执行<code>while(b == 0)</code>，终止循环</li>
<li>CPU1执行<code>assert(a == 1)</code>，此时a不在其Cache中，因此发出Read消息</li>
<li>CPU0收到Read消息，返回包含a新值的Cache Line</li>
<li>CPU1收到包含a的Cache Line，断言为真</li>
</ol>
<p>上面的步骤看起来很多，其实比较简单，由于内存屏障的存在，导致<code>b=1</code>只能随<code>a=1</code>一起进入到Store Buffer，即b的新值不会先于a的新值出现在CPU0的Cache中，对于应用程序而言，内存屏障前的写入会先于内存屏障后的写入生效。</p>
<h3 id="Invalid-Queue"><a href="#Invalid-Queue" class="headerlink" title="Invalid Queue"></a>Invalid Queue</h3><p>引入了Store Buffer，再辅以Store Forwarding，Memory Barrier，看起来好像可以自洽了，然而还有一个问题没有考虑: Store Buffer的大小是有限的，所有写入操作的Cache Missing都会使用Store Buffer，特别是出现内存屏障时，后续的所有写入操作(不管是否Cache Miss)都会挤压在Store Buffer中(直到Store Buffer中屏障前的条目处理完)，因此Store Buffer很容易会满，当Store Buffer满了之后，CPU还是会卡在等对应的Invalid Ack以处理Store Buffer中的条目。因此还是要回到Invalid Ack中来，Invalid Ack耗时的主要原因是CPU要先将对应的Cache Line置为Invalid后再返回Invalid Ack，一个很忙的CPU可能会导致其它CPU都在等它回Invalid Ack。解决思路还是化同步为异步: CPU不必要处理了Cache Line之后才回Invalid Ack，而是可以先将Invalid消息放到某个请求队列Invalid Queue，然后就返回Invalid Ack。CPU可以后续再处理Invalid Queue中的消息，大幅度降低Invalid Ack响应时间。此时的CPU Cache结构图如下:</p>
<p><img src="/assets/image/201904/cache-with-invalid-queue.png" width = "500" height = "400" alt="" align=center /></p>
<p>和Store Buffer类似，Invalid Queue有两个问题要考虑，一是CPU在处理任何Cache Line的MSEI状态前，都必须先看Invalid Queue中是否有该Cache Line的Invalid消息没有处理。这一点在CPU数据竞争不是很激烈时是可以接受的。这方面的一个极端是<a href="http://wudaijun.com/2015/01/false-sharing/">false sharing</a>。</p>
<p>Invalid Queue的另一个要考虑的问题是它也增加了破坏内存一致性的可能，即可能破坏我们之前提到的内存屏障:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段5</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    smp_mb()</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    assert(a == <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仍然假设a, b的初始值为0，a在CPU0,CPU1中均为Shared状态，b为CPU0独占(Exclusive状态)，CPU0执行foo，CPU1执行bar:</p>
<ol>
<li>CPU0执行<code>a = 1</code>，由于其有包含a的Cache Line，将a写入Store Buffer，并发出<code>Invalidate a</code>消息</li>
<li>CPU1执行<code>while(b == 0)</code>，它没有b的Cache，发出<code>Read b</code>消息</li>
<li>CPU1收到CPU0的<code>Invalidate a</code>消息，将其放入Invalidate Queue，返回<code>Invalidate Ack</code></li>
<li>CPU0收到<code>Invalidate Ack</code>，将Store Buffer中的<code>a=1</code>刷新到Cache Line，标记为Modified</li>
<li>CPU0看到<code>smp_mb()</code>内存屏障，但是由于其Store Buffer为空，因此它可以直接跳过该语句</li>
<li>CPU0执行<code>b = 1</code>，由于其Cache独占b，因此直接执行写入，Cache Line标记为Modified，</li>
<li>CPU0收到CPU1发的<code>Read b</code>消息，将包含b的Cache Line写回内存并返回该Cache Line，本地的Cache Line标记为Shared</li>
<li>CPU1收到包含b(当前值1)的Cache Line，结束while循环</li>
<li>CPU1执行<code>assert(a == 1)</code>，由于其本地有包含a旧值的Cache Line，读到a初始值0，断言失败</li>
<li>CPU1这时才处理Invalid Queue中的消息，将包含a旧值的Cache Line置为Invalid</li>
</ol>
<p>问题在于CPU1在读取a的Cache Line时，没有先处理Invalid Queue中该Cache Line的Invalid操作，解决思路仍然是内存屏障，我们可以通过内存屏障让CPU标记当前Invalid Queue中所有的条目，所有的后续加载操作必须先等Invalid Queue中标记的条目处理完成再执行。因此我们可以在<code>while</code>和<code>assert</code>之间插入<code>smp_mb()</code>。这样CPU1在看到<code>smp_mb()</code>后，会先处理Invalidate Queue，然后发现本地没有包含a的Cache Line，重新从CPU0获取，得到a的值为1，断言成立。具体操作序列不再赘述。</p>
<p>前面我们说的内存屏障可以同时作用于Store Buffer和Invalidate Queue，而实际上，CPU0(foo函数)只有写操作，因此只关心Store Buffer，同样的CPU1(bar函数)都是读操作，只关心Invalidate Queue，因此，大多数CPU架构将内存屏障分为了读屏障(Read Memory Barrier)和写屏障(Write Memory Barrier):</p>
<ul>
<li>读屏障: 任何读屏障前的读操作都会先于读屏障后的读操作完成</li>
<li>写屏障: 任何写屏障前的写操作都会先于写屏障后的写操作完成</li>
<li>全屏障: 同时包含读屏障和写屏障的作用</li>
</ul>
<p>因此前面的例子中，foo函数只需要写屏障，bar函数需要读屏障。实际的CPU架构中，可能提供多种内存屏障，比如可能分为四种:</p>
<ul>
<li>LoadLoad: 相当于前面说的读屏障</li>
<li>LoadStore: 任何该屏障前的读操作都会先于该屏障后的写操作完成</li>
<li>StoreLoad: 任何该屏障前的写操作都会先于该屏障后的读操作完成</li>
<li>StoreStore: 相当于前面说的写屏障</li>
</ul>
<p>实现原理类似，都是基于Store Buffer和Invalidate Queue，不再赘述。</p>
<h3 id="Instruction-Reordering"><a href="#Instruction-Reordering" class="headerlink" title="Instruction Reordering"></a>Instruction Reordering</h3><p>到目前为止我们只考虑了CPU按照程序顺序执行指令，而实际上为了更好地利用CPU，CPU和编译器都可能会对指令进行重排(reordering):</p>
<ol>
<li>编译期间重排: 编译器在编译期间，可能对指令进行重排，以使其对CPU更友好</li>
<li>运行期间重排: CPU在执行指令的过程中，可能乱序执行以更好地利用流水线</li>
</ol>
<p>不管是CPU架构，VM，还是编译器，在对指令进行重排时都要遵守一个约束: 不管指令如何重排，对单线程来说，结果必然是一致的。即不会改变单线程程序的行为。比如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段6</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">c = a + b;</span><br></pre></td></tr></table></figure>
<p>编译器/CPU/VM 可以对<code>a = 1;</code>和<code>b = 2;</code>进行对换，而不能将<code>c = a + b</code>与前面两句对换，在实现上来说，对指定地址的操作(读写)序列，CPU是会保证和程序顺序一致的(比如a是先写后读)，并且CPU的读写对自己总是可见的(Store Forwarding)，对于不同的地址，CPU不能解析其依赖关系，可能会乱序执行，比如如果有其它线程依赖于a先于b赋值这个事实，那么就必须要应用程序告诉CPU/编译器，a和b有依赖关系，不要重排。前面提到的内存屏障，一直谈的是它的可见性(visibility)功能，它能够让屏障前的操作(读/写)即时刷新，被其它CPU看到。而内存屏障还有个功能就是限制指令重排(读/写指令)，否则即使在<code>a = 1</code>和<code>b = 2</code>之间加了内存屏障，b也有可能先于a赋值，前面的<code>foo()</code>和<code>bar()</code>的例子也会断言失败。</p>
<h3 id="Programing"><a href="#Programing" class="headerlink" title="Programing"></a>Programing</h3><p>对应用层而言，各种语言提供的并发相关关键字和工具，底层都会使用内存屏障。</p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>java中可以通过volatile关键字来保证变量的可见性，并限制局部的指令重排。它的实现原理是在每个volatile变量写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障，在每个volatile变量读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障来完成。</p>
<h4 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h4><p>以C++的atomic为例，atomic本身的职责是保证原子性，与volatile定位不太一样，后者本身是不保证原子性的，C++ atomic允许在保证原子的基础上，指定内存顺序，即使用哪种内存屏障。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段7</span></span><br><span class="line"><span class="comment">// memory_order_relaxed 松散的内存模型，不要求任何顺序性，只要求原子性。通常用于计数器自增</span></span><br><span class="line"><span class="comment">// Thread A:</span></span><br><span class="line">r1 = y.load(memory_order_relaxed); <span class="comment">// A</span></span><br><span class="line">x.store(r1, memory_order_relaxed); <span class="comment">// B</span></span><br><span class="line"><span class="comment">// Thread B:</span></span><br><span class="line">r2 = x.load(memory_order_relaxed); <span class="comment">// C </span></span><br><span class="line">y.store(<span class="number">42</span>, memory_order_relaxed); <span class="comment">// D</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，可能出现全局执行序列为: D A B C，出现r1=r2=42的情况。<code>memory_order_relaxed</code>相当于没有加内存屏障。除了<code>memory_order_relaxed</code>外，还有:</p>
<ul>
<li><code>memory_order_acquire</code>: 在该原子变量的读操作前插入LoadLoad屏障，在读操作后插入LoadStore。即Load之后的所有读写操作不能重排到Load之前</li>
<li><code>memory_order_consume</code>: acquire限制了Load之后的所有读写操作向前重排，而consume则只限制相关联的读写操作(单线程语义内)</li>
<li><code>memory_order_release</code>: 在该原子变量的写操作前插入LoadStore屏障，在写操作后插入StoreStore屏障。即Store之前的所有读写操作不能重排到Store之后</li>
<li><code>memory_order_acq_rel</code>: 相当于 <code>memory_order_acquire</code> + <code>memory_order_release</code></li>
<li><code>memory_order_seq_cst</code>: 最强的顺序一致性，在<code>memory_order_acq_rel</code>的基础上，支持单独全序，即所有线程以同一顺序观测到该原子变量的所有修改</li>
</ul>
<p>这里也引申出关于内存屏障的两个常用语义:</p>
<ul>
<li>acquire语义：Load 之后的读写操作无法被重排至 Load 之前。即 相当于LoadLoad和LoadStore屏障。</li>
<li>release语义：Store 之前的读写操作无法被重排至 Store 之后。即 相当于LoadStore和StoreStore屏障。</li>
</ul>
<p>注意acquire和release语义没有提到StoreLoad屏障，StoreLoad屏障是四种屏障中开销最大的，这个在后面会提到。</p>
<h4 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h4><p>mutex的实现通常是在mutex lock时加上acquire屏障(LoadLoad+LoadStore)，在mutex unlock时加上release屏障(StoreStore+StoreLoad)，例如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段8</span></span><br><span class="line"><span class="comment">// -&gt; LoadLoad</span></span><br><span class="line">mutex_lock(a);</span><br><span class="line"><span class="comment">// -&gt; LoadStore</span></span><br><span class="line">x = x+<span class="number">1</span>;</span><br><span class="line"><span class="comment">// -&gt; StoreStore</span></span><br><span class="line">mutex_unlock(a);</span><br><span class="line"><span class="comment">// -&gt; StoreLoad</span></span><br></pre></td></tr></table></figure>
<p>由于mutex任意时刻只能被一个线程占有，因此A线程拿到mutex必然在B线程释放mutex之后，由于内存屏障的存在，<code>mutex_lock</code>和<code>mutex_unlock</code>之间的指令只能在mutex里面(无法越过mutex)，并且A线程能即时看到B线程mutex中作出的更改。</p>
<p>注意，这里列举的volatile, atomic, mutex的具体实现和语义可能在不同的语言甚至同种语言不同的编译平台中有所区别(如C++不同的VS版本对volatile关键字的内存屏障使用有所区别)。对开发者而言，编写并发程序需要理解三个东西: 原子性，可见性和顺序性。</p>
<ul>
<li>原子性: 尽管在如今大部分平台下，对一个字的数据进行存取(int,指针)的操作本身就是原子性的，但为了更好地跨平台性，通过atomic操作来实现原子性是更好的方法，并且不会造成额外的开销。C++的atomic还提供可见性和顺序性选项</li>
<li>可见性: 数据同步相关，前面讨论的CPU Cache设计主要关注的就是可见性，即每个读操作所返回的值必须是最后一次对该存储位置的写操作的值。Cache一致性主要解决的就是数据可见性的问题</li>
<li>顺序性: 内存屏障的另一个功能就是可以限制局部的指令重排(一些文章将内存屏障定义为限制指令重排工具，我认为是不准确的，如前面所讨论的，即使没有指令重排，有时也需要内存屏障来保证可见性)。内存屏障保证屏障前的某些操作必定限于屏障后的操作<strong>发生且可见</strong>。但屏障前或屏障后的指令，CPU/编译器仍然可以在不改变单线程结果的情况下进行局部重排。每个硬件平台有自己的基础内存一致性(强/弱内存模型)</li>
</ul>
<h3 id="Memory-Consistency"><a href="#Memory-Consistency" class="headerlink" title="Memory Consistency"></a>Memory Consistency</h3><p>有了前面的讨论，我们可以引出内存一致性的概念了，前面讨论的Cache一致性，内存屏障，指令重排，乱序执行等，都属于内存一致性的范畴。内存一致性也叫做内存模型(Memory Model)或内存一致性模型(Memory Consistency Model)，内存一致性模型规定了程序员和系统之间的契约，其中系统保证，如果程序员遵循内存操作规则，内存将是一致的，读取、写入或更新内存的结果将是可预测的。</p>
<p>Cache一致性(Conherence)和内存一致性(Consistency)中的”一致性”意义是不一样的，前者关注多个CPU对同一内存地址的读写预期，后者关注多个CPU对所有内存地址的读写预期。事实上，Cache一致性的另一种定义(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cache_coherence">From WIKI</a>)就是基于顺序一致性内存模型的:</p>
<p>缓存一致性系统必须以遵循每个线程的程序顺序的总顺序来执行所有线程的加载和存储到单个内存位置。缓存一致系统和顺序一致系统之间的唯一区别是地址位置的数量(缓存一致系统的单个内存位置，顺序一致系统的所有内存位置)。因此可以说Cache一致性是内存一致性的一部分。</p>
<p>PS: 前面讨论的Cache Coherence(MESI，StoreBuffer, InvalidQueue)本质是满足多个CPU对单个内存地址读写的顺序一致性的。之所以会用到内存屏障，是因为那是针对多个内存地址有关联的情况，这属于Memory Consistency考虑的范畴。</p>
<p>以下是几种常见的内存一致性模型:</p>
<ul>
<li><code>Weak Memory Model</code>: 如DEC Alpha是弱内存模型，它可能经历所有的四种内存乱序(LoadLoad, LoadStore, StoreLoad, StoreStore)，任何Load和Store操作都能与任何其它的Load或Store操作乱序，只要其不改变单线程的行为。</li>
<li><code>Weak With Date Dependency Ordering</code>: 如ARM, PowerPC, Itanium，在Aplpha的基础上，支持数据依赖排序，如C/C++中的<code>A-&gt;B</code>，它能保证加载B时，必定已经加载最新的A</li>
<li><code>Strong Memory Model</code>: 如X86/64，强内存模型能够保证每条指令<code>acquire and release</code>语义，换句话说，它使用了LoadLoad/LoadStore/StoreStore三种内存屏障，即避免了四种乱序中的三种，仍然保留StoreLoad的重排，对于代码片段7来说，它仍然可能出现r1=r2=42的情况</li>
<li><code>Sequential Consistency</code>: 最强的一致性，理想中的模型，在这种内存模型中，没有乱序的存在。如今很难找到一个硬件体系结构支持顺序一致性，因为它会严重限制硬件对CPU执行效率的优化(对寄存器/Cache/流水线的使用)。</li>
</ul>
<p>前面说到C++ atomic内存模型属于语言级的约束定义，它建立在处理器平台内存模型之上，如果处理器平台是SC(Sequential Consistency)的，那么语言级无论如何定义也无法将硬件改为更松散的内存模型。语言级的内存模型还有一个重要作用就是限制编译器reorder，即生成编译器屏障(fence)。因此即使处理器平台是SC的，语言层面定义为relaxed也可能因为编译器reorder导致结果不如预期。</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>本文比较杂乱，前面主要介绍CPU Cache结构和Cache一致性问题，引出内存屏障的概念。后面顺便简单谈了谈指令乱序和内存一致性。</p>
<p>实际的CPU Cache结构比上面阐述的要复杂得多，其核心的优化理念都是化同步为异步，然后再去处理异步下的一致性问题(处理不了就交给开发者…)。尽管异步会带来一些理解和开发负担，但它仍然是达成高吞吐量的必经之路。硬件方面的结构优化到一定程度了，CPU/编译器就开始打应用层代码的主意: 如指令重排和乱序执行。</p>
<p>对开发者来说，想要完整掌握和理解内存一致性是非常困难的，其中包括系统架构、语言、编译器等多个层面的实现细节，以及不同语言版本和系统架构之间的差异。实践中，应用程序可以通过封装好的mutex完成大部分的并发控制，而无需关注内存一致性实现细节和不同平台的差异。但是在使用比mutex更底层的同步机制(如atomic, volatile, memory-barrier, lock-free等)时，就要务必小心。从原子性，可见性，顺序性等方面确保代码执行结果如预期。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ol>
<li><a target="_blank" rel="noopener" href="http://www.rdrop.com/~paulmck/scalability/paper/whymb.2010.06.07c.pdf">Memory Barriers: a Hardware View for Software Hackers</a></li>
<li><a target="_blank" rel="noopener" href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/">为什么程序员需要关心顺序一致性而不是Cache一致性？</a></li>
<li><a target="_blank" rel="noopener" href="http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering/">浅谈Memory Reordering</a></li>
<li><a target="_blank" rel="noopener" href="http://0xffffff.org/2017/02/21/40-atomic-variable-mutex-and-memory-barrier/">聊聊原子变量、锁、内存屏障那点事</a></li>
<li><a target="_blank" rel="noopener" href="https://preshing.com/20120913/acquire-and-release-semantics/">Acquire and Release Semantics</a></li>
<li><a href="https://wudaijun.com/2018/09/consistency/">一致性杂谈</a></li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>wudaijun
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://wudaijun.com/2019/04/cache-coherence-and-memory-consistency/" title="Cache一致性和内存一致性">http://wudaijun.com/2019/04/cache-coherence-and-memory-consistency/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/os/" rel="tag"><i class="fa fa-tag"></i> os</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/04/linux-perf/" rel="prev" title="Linux Perf 简单试用">
      <i class="fa fa-chevron-left"></i> Linux Perf 简单试用
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/05/programing-paradigm/" rel="next" title="编程范式游记">
      编程范式游记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache-Geometry"><span class="nav-text">Cache Geometry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache-Coherence"><span class="nav-text">Cache Coherence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Store-Buffers"><span class="nav-text">Store Buffers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Store-Forwarding"><span class="nav-text">Store Forwarding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-Barrier"><span class="nav-text">Memory Barrier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Invalid-Queue"><span class="nav-text">Invalid Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Instruction-Reordering"><span class="nav-text">Instruction Reordering</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Programing"><span class="nav-text">Programing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile"><span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#atomic"><span class="nav-text">atomic</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mutex"><span class="nav-text">mutex</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-Consistency"><span class="nav-text">Memory Consistency</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Summary"><span class="nav-text">Summary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#References"><span class="nav-text">References</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wudaijun"
      src="/assets/theme/avatar.png">
  <p class="site-author-name" itemprop="name">wudaijun</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">133</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wudaijun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wudaijun" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/wudaijun" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;wudaijun" rel="noopener" target="_blank"><i class="fab fa-contao fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2014 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wudaijun</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'mcuD0S7ohGooofXt3SJ62qW2-9Nh9j0Va',
      appKey     : 'qvWjHt4jMELAWtqmpdK6Mh9Q',
      placeholder: "Leave something ...",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
