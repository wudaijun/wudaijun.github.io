<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/theme/favicon-100x100.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/theme/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/theme/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wudaijun.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这段时间学习Unity，顺便系统性地了解了下C#和Unity异步编程的各种机制和实现细节。本文是这些学习资料和个人理解的汇总。会先介绍下C# yield，Task，async&#x2F;await，同步上下文等机制。然后聊聊其在Unity上的一些变体和应用。">
<meta property="og:type" content="article">
<meta property="og:title" content="C#&#x2F;Unity中的异步编程">
<meta property="og:url" content="http://wudaijun.com/2021/11/c-sharp-unity-async-programing/index.html">
<meta property="og:site_name" content="wudaijun&#39;s blog">
<meta property="og:description" content="这段时间学习Unity，顺便系统性地了解了下C#和Unity异步编程的各种机制和实现细节。本文是这些学习资料和个人理解的汇总。会先介绍下C# yield，Task，async&#x2F;await，同步上下文等机制。然后聊聊其在Unity上的一些变体和应用。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-11-25T16:00:00.000Z">
<meta property="article:modified_time" content="2023-03-20T09:58:40.615Z">
<meta property="article:author" content="wudaijun">
<meta property="article:tag" content="coroutine">
<meta property="article:tag" content="async programing">
<meta property="article:tag" content="unity">
<meta property="article:tag" content="c#">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://wudaijun.com/2021/11/c-sharp-unity-async-programing/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C#/Unity中的异步编程 | wudaijun's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="wudaijun's blog" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wudaijun's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Done is better than perfect</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wudaijun.com/2021/11/c-sharp-unity-async-programing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/theme/avatar.png">
      <meta itemprop="name" content="wudaijun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wudaijun's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C#/Unity中的异步编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-26 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-26T00:00:00+08:00">2021-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c#</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/11/c-sharp-unity-async-programing/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/11/c-sharp-unity-async-programing/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这段时间学习Unity，顺便系统性地了解了下C#和Unity异步编程的各种机制和实现细节。本文是这些学习资料和个人理解的汇总。会先介绍下C# yield，Task，async/await，同步上下文等机制。然后聊聊其在Unity上的一些变体和应用。</p>
<span id="more"></span>
<h3 id="C-yield"><a href="#C-yield" class="headerlink" title="C# yield"></a>C# yield</h3><p><code>yield</code>是C#提供的快速创建枚举器的机制:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">TestYield</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IEnumerator&lt;<span class="built_in">int</span>&gt; enumerator = TestYield(<span class="number">4</span>).GetEnumerator();</span><br><span class="line">    <span class="keyword">while</span> (enumerator.MoveNext())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(enumerator.Current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>实现上来说，C#编译器会为TestYield函数生成一个状态机类，将函数执行体通过yield分为几个部分，内部通过一个state字段(通常是个整数)来标识当前迭代到哪一步了，并实现了IEnumerable、IEnumerator枚举器接口。因此可以将TestYield返回值作为一个可枚举对象。介绍关于yield语法糖实现机制的文章很多，这里就不赘述了。</p>
<p>C# 枚举器和JS Generator机制上非常类似，不过只具备单向传值的能力(yield-&gt;MoveNext)。我在<a href="http://wudaijun.com/2018/07/javascript-async-programing/">JS异步编程</a>和<a href="https://wudaijun.com/2015/01/lua-coroutine/">Lua协程</a>中有介绍关于协程和生成器的区别，在我的理解中，C#枚举器和JS生成器一样，都不能算作协程。</p>
<h3 id="Unity-Coroutine"><a href="#Unity-Coroutine" class="headerlink" title="Unity Coroutine"></a>Unity Coroutine</h3><p>C#没有协程，而Unity C#中则经常看到协程的概念(Unity Coroutine)，本质上来说，Unity Coroutine是和JS Generator类似的通过生成器/枚举器实现异步的编程模型。Unity基于C# yield进行了进一步完善:</p>
<ol>
<li>Unity协程通过Unity Engine提供的<code>StartCoroutine(myEnumerableFunc)</code>启动，Unity Engine会驱动枚举器的迭代，无需开发者关心</li>
<li>Unity协程基于yield返回的对象，只能是YieldInstruction的子类(它最重要的方法是bool IsDone()，用于判断异步操作是否已经完成)，如此Unity Engine会在YieldInstruction完成后，通过MoveNext迭代枚举器</li>
<li>Unity Engine预实现了部分YieldInstruction，如WaitForSeconds，WaitForEndOfFrame等，以实现常用的协程控制</li>
<li>Unity Engine完善了协程(枚举器)生命周期管理(Start/Stop)和嵌套机制(如一个协程yield另一个协程)，并将协程的生命周期与GameObject绑定</li>
</ol>
<p>关于Unity Coroutine的更深入实现原理推荐<a target="_blank" rel="noopener" href="https://sunweizhe.cn/2020/05/08/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Unity%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">这篇博客</a>。如此，对于Unity开发者而言，使用yield就能完成简单的异步控制。当然，还达不到JS Generator异步那样的灵活度(如C# yield不能像JS yield一样双向传值)。我们可以从<a href="http://wudaijun.com/2018/07/javascript-async-programing/">JS 异步编程</a>中提到的Generator异步编程的四要素，来对比看看Unity Coroutine是如何工作的:</p>
<ul>
<li>Generator: C#的yield相当于JS Generator的阉割版，支持执行权转移，单向传值</li>
<li>Thunk: Thunk的本质目的是让Iterator能以一种标准化的方式挂接回调(如此才能回到yield语句)，而Unity YieldInstruction本身就是一种标准，Unity会在YieldInstruction完成(IsDone()==true)后，调用对应协程的的MoveNext回到yield语句，这也就相当于完成了Thunk的职责</li>
<li>AsyncOp: Unity Engine和它的标准库提供了大量适配了YieldInstruction的异步操作，包括帧控制、定时、网络IO等，并且支持开发者扩展</li>
<li>Iterator: Unity Engine统一管理所有通过StartCoroutine启动的协程，并基于帧驱动检查它们的状态，在YieldInstruction异步操作完成后继续驱动协程(MoveNext)，直至协程生命周期结束。</li>
</ul>
<p>由于C# yield是单向传值，Unity协程自然也就不支持yield语句返回值。如此看来，Unity C#确实具备部分的异步编程能力，不过如前面所说，基于个人对狭义的协程概念的理解，我认为程JS、C#、Unity支持协程是不合适的。类似的还有Golang的抢占式轻量级线程goroutine也被翻译为协程。</p>
<h3 id="C-Task"><a href="#C-Task" class="headerlink" title="C# Task"></a>C# Task</h3><p>C#中的Task本质上类似JS中的Promise，表示一个异步任务，通常运行在其他线程而非创建Task的当前线程中。Task在启动(Task.Start/Task.Run/TaskFactory.StartNew)和ContinueWith的时候，可以选择指定其对应的TaskScheduler(对于ContinueWith而言，指定的是执行异步回调的任务调度器)，默认的TaskScheduler只会将任务放到线程池中去执行。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">888</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">111</span>;</span><br><span class="line">    <span class="keyword">var</span> task = <span class="keyword">new</span> Task&lt;<span class="built_in">int</span>&gt;(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;add task, on thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;main thread&#123;0&#125;, task&#123;1&#125; init status: &#123;2&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId, task.Id, task.Status);</span><br><span class="line">    task.Start();</span><br><span class="line">    task.ContinueWith((task, arg) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;continue with 1, got result: &#123;0&#125;, got arg: &#123;1&#125;, on thread&#123;2&#125;&quot;</span>, task.Result, arg, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    &#125;, <span class="string">&quot;Arg1&quot;</span>).</span><br><span class="line">    ContinueWith((task) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;continue with 2, on thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    &#125;).Wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// main thread1, task1 init status: Created</span></span><br><span class="line"><span class="comment">// add task, on thread3</span></span><br><span class="line"><span class="comment">// continue with 1, got result: 999, got arg: Arg1, on thread4</span></span><br><span class="line"><span class="comment">// continue with 2, on thread5</span></span><br></pre></td></tr></table></figure>
<p>以上代码展示了Task的几个特性:</p>
<ol>
<li>任务内部有个简单的状态机，其他线程可通过<code>Task.Status</code>获取任务当前状态</li>
<li><code>Task.ContinueWith</code>返回值是一个新的Task，可以像<code>JS promise.then</code>一样，以可读性较好的方式(相比回调地狱)书写异步调用链</li>
<li><code>task.ContinueWith</code>中的回调可以取到到task的返回值，并且可以为其附加额外的参数</li>
<li><code>task.Wait</code>可以让当前线程同步阻塞等待该任务完成，除此之外，还可以通过<code>Task.WaitAny</code>和<code>Task.WaitAll</code>来等待一个任务数组</li>
<li>在任务执行完成后，通过<code>task.Result</code>可以取得异步任务的返回值，注意，如果此时任务未完成，将会同步阻塞等待任务完成</li>
<li>如果没有指定TaskScheduler，默认的任务调度器只是在线程池中随机选一个线程来执行异步任务和对应回调</li>
</ol>
<p>有时候我们在线程A中将某些耗时操作，如网络IO，磁盘IO等封装为Task放到线程B异步执行之后，希望Task的回调在A线程执行(最典型的如UI线程，因为通常UI框架的API都不是线程安全的)，以实现A-&gt;B-&gt;A的线程上下文切换效果。要实现这种效果，我们需要为Task显式指定TaskScheduler，TaskScheduler本质只是接口，它的派生类主要有两个:</p>
<ul>
<li>thread pool task scheduler: 基于线程池的任务调度器，即任务(及其continuewith产生的新任务)会被分配到线程池中的某个工作线程，这也是默认的调度器，通过<code>TaskScheduler.Default</code>获取默认线程池调度器</li>
<li>synchronization context task scheduler: 同步上下文调度器，即任务会在指定的同步上下文上执行，比如在GUI框架中，通常会将控件操作全部放到GUI线程中执行。通过<code>TaskScheduler.FromCurrentSynchronizationContext</code>获取与当前同步上下文绑定的任务调度器</li>
</ul>
<p>那么什么是同步上下文？SynchronizationContext代表代码的执行环境，提供在各种同步模型中传播同步上下文的功能，为各个框架的线程交互提供统一的抽象。它最重要的是以下两个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取当前线程的同步上下文</span><br><span class="line">public static System.Threading.SynchronizationContext? Current &#123; get; &#125;</span><br><span class="line">&#x2F;&#x2F; 派发一个异步到消息到当前同步上下文</span><br><span class="line">public virtual void Post (System.Threading.SendOrPostCallback d, object? state);</span><br><span class="line">&#x2F;&#x2F; 派发一个同步消息到当前同步上下文</span><br><span class="line">public virtual void Send (System.Threading.SendOrPostCallback d, object? state);</span><br></pre></td></tr></table></figure>
<p>SynchronizationContext提供了默认的实现，对Post而言，它只会通过QueueUserWorkItem将任务丢给ThreadPool，对于Send而言，它会立即在当前线程上同步执行委托。</p>
<p>各个框架可以重载SynchronizationContext实现自己的同步上下文行为，如Windows Froms实现了<code>WindowsFormsSynchronizationContext</code>，它的Post会通过<code>Control.BeginInvoke</code>实现，而WPF的<code>DispatcherSynchronizationContext</code>则通过框架的<code>Dispatcher.BeginInvoke</code>实现，它们都实现了将委托异步投递给UI线程执行。正因为不同的平台，不同的线程，有不同的消息泵和交互方式，因此才需要SynchronizationContext来封装抽象这些差异性，以增强代码的可移植性。</p>
<p>每个线程都有自己的SynchronizationContext(通过<code>SynchronizationContext.Current</code>获取，默认为null)，但SynchronizationContext与线程不一定是一一对应的，比如默认的<code>SynchronizationContext.Post</code>是通过线程池来执行任务。SynchronizationContext本质上想要封装的是一个执行环境以及与该环境进行任务交互的方式。</p>
<p>对Task，TaskScheduler，SynchronizationContext有一定了解后，我们将这些概念结合起来:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建并设置当前线程的SynchronizationContext</span></span><br><span class="line">    <span class="comment">// 否则TaskScheduler.FromCurrentSynchronizationContext()调用会触发System.InvalidOperationException异常</span></span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">new</span> SynchronizationContext();</span><br><span class="line">    SynchronizationContext.SetSynchronizationContext(context);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;main thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Task&lt;<span class="built_in">int</span>&gt; task = <span class="keyword">new</span> Task&lt;<span class="built_in">int</span>&gt;(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;task thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    task.Start();</span><br><span class="line">    task.ContinueWith(t =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;continuewith result: &#123;0&#125;, thread&#123;1&#125;&quot;</span>, t.Result, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">    &#125;, TaskScheduler.FromCurrentSynchronizationContext()).Wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// main thread1</span></span><br><span class="line"><span class="comment">// task thread3</span></span><br><span class="line"><span class="comment">// continuewith result: 1, thread4</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，使用<code>TaskScheduler.FromCurrentSynchronizationContext()</code>来指定<code>task.ContinueWith</code>任务的调度器(注意，我们并没有为<code>task.Start</code>指定调度器，因为我们希望task本身使用默认的线程池调度器，当执行完成之后，再回到主线程执行ContinueWith任务)，输出结果并不如我们预期，<code>task.ContinueWith</code>中的回调委托仍然在线程池中执行，而不是在主线程。</p>
<p>这个结果其实很容易解释，<code>task.ContinueWith(delegate, TaskScheduler.FromCurrentSynchronizationContext())</code>表示: 当task执行完成后，通过<code>SynchronizationContext.Post(delegate, task)</code>将任务异步投递到指定的同步上下文(在上例中，即为主线程创建的上下文)。但是一来我们创建的是默认的SynchronizationContext，它的Post本身就是投递到线程池的，二来我们并没有在主线程中集成消息泵(message pump)。</p>
<p>类比Actor模型，我们要实现 Actor A 向 Actor B 通信，我们需要: </p>
<ol>
<li>定义一个消息通道: channel/mailbox</li>
<li>集成channel/mailbox到B消息泵</li>
<li>将channel/mailbox暴露给A</li>
</ol>
<p>因此，上例中，我们即没有定义消息的传输方式，也没有定义消息的处理方式。SynchronizationContext本质只是提供了一层同步上下文切换交互抽象，传输方式，消息泵，甚至线程模型都需要我们自己实现。这里就不再展示SynchronizationContext的扩展细节，更多关于SynchronizationContext的文档:</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://hamidmosalla.com/2018/06/24/what-is-synchronizationcontext/">what is synchronizationcontext</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2011/february/msdn-magazine-parallel-computing-it-s-all-about-the-synchronizationcontext">synchronizationcontext doc on MSDN</a></li>
</ol>
<h3 id="C-async-await"><a href="#C-async-await" class="headerlink" title="C# async/await"></a>C# async/await</h3><p>async/await是C# .NET4.5推出的更高级的异步编程模型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static async void AsyncTask()</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;before await, thread&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    var a &#x3D; await Task.Run(() &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(500);</span><br><span class="line">        Console.WriteLine(&quot;in task, thread&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId); </span><br><span class="line">        return 666;</span><br><span class="line">    &#125;);</span><br><span class="line">    Console.WriteLine(&quot;after await, got result: &#123;0&#125;, thread&#123;1&#125;&quot;, a, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;Main: before AsyncTask thread&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    var r &#x3D; AsyncTask().Result;</span><br><span class="line">    Console.WriteLine(&quot;Main: after AsyncTask result: &#123;0&#125; thread&#123;1&#125;&quot;, r, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Output:</span><br><span class="line">AsyncTask: before await, thread1</span><br><span class="line">AsyncTask: in task, thread3</span><br><span class="line">AsyncTask: after await, got result: 666, thread3</span><br><span class="line">Main: after AsyncTask result: 667 thread1</span><br></pre></td></tr></table></figure>
<p>可以看到async/await进一步简化了异步编程的书写方式，达到更接近同步编程的可读性和易用性(这一点后面会再探讨下)。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>在进一步了解它的用法之前，我们先大概了解下它的实现机制(可以看看<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/197335532">这篇文章</a>提到了不少实现细节)，async/await本质也是编译器的语法糖，编译器做了以下事情:</p>
<ol>
<li>为所有带async关键字的函数，生成一个状态机类，它满足IAsyncStateMachine接口，await关键字本质生成了状态机类中的一个状态，状态机会根据内部的state字段(通常-1表示开始，-2表示结束，其他状态依次为0,1,2…)，一步步执行异步委托。整个状态机由<code>IAsyncStateMachine.MoveNext</code>方法驱动，类似迭代器</li>
<li>代码中的<code>await xxx</code>，xxx返回的对象都需要实现GetAwaiter方法，该方法返回一个Awaiter对象，编译器不关心这个对象Awaiter对象类型，它只关心这个Awaiter对象需要满足三个条件: a. 实现INotifyCompletion(只有一个<code>OnCompleted(Action continuation)</code>方法)，b. 实现IsCompleted属性，c. 实现GetResult方法，如此编译器就能知道如何与该异步操作进行交互，比如最常见的Task对象，就实现了GetAwaiter方法返回一个<a target="_blank" rel="noopener" href="https://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs,2935">TaskAwaiter</a>对象，但除了TaskAwaiter，任何满足以上三个条件的对象均可被await</li>
<li>有了stateMachine和TaskAwaiter之后，还需要一个工具类将它们组合起来，以驱动状态机的推进，这个类就是<code>AsyncTaskMethodBuilder/AsyncTaskMethodBuilder&lt;TResult&gt;</code>，是Runtime预定义好的，每个async方法，都会创建一个Builder对象，然后通过<a target="_blank" rel="noopener" href="https://referencesource.microsoft.com/#mscorlib/system/runtime/compilerservices/AsyncMethodBuilder.cs,67">AsyncTaskMethodBuilder.Start</a>方法绑定对应的IAsyncStateMachine，并进行状态首次MoveNext驱动，MoveNext执行到await处(此时实际上await已经被编译器去掉了，只有TaskAwaiter)，会调用<code>TaskAwaiter.IsCompleted</code>判断任务是否已经立即完成(如<code>Task.FromResult(2)</code>)，如果已完成，则将结果设置到builder(此时仍然在当前线程上下文)，并之后跳转到之后的代码(直接goto，无需MoveNext)，否则，更新state状态，通过<a target="_blank" rel="noopener" href="https://referencesource.microsoft.com/#mscorlib/system/runtime/compilerservices/AsyncMethodBuilder.cs,154">AsyncTaskMethodBuilder.AwaitUnsafeOnCompleted</a>(最终调到<code>Awaiter.OnCompleted</code>)挂接(对<code>TaskAwaiter.OnCompleted</code>而言，是<a target="_blank" rel="noopener" href="https://referencesource.microsoft.com/#mscorlib/system/runtime/compilerservices/TaskAwaiter.cs,339">挂接到Continuation</a>上)异步回调(此回调包含整个状态机的后续驱动方式，通过<a target="_blank" rel="noopener" href="https://referencesource.microsoft.com/#mscorlib/system/runtime/compilerservices/AsyncMethodBuilder.cs,ac92075576570beb">GetCompletionAction</a>生成)并返回(此时当前函数堆栈已结束)，当taskAwaiter完成(不同的Awaiter完成方式也不同，对Task而言，即Task执行完成)后，buildier会通过GetCompletionAction生成的回调再次调用到<code>stateMachine.MoveNext</code>驱动状态机(此时可能已经不在当前线程，state状态也不一样了，可通过TaskAwaiter.GetResult拿到异步结果)，如此完成状态机的正常驱动。</li>
<li>除了驱动状态机外，AsyncTaskMethodBuilder的另一个作用是将整个async函数，封装为一个新的Task(wrapper task)，该Task可通过<code>AsyncTaskMethodBuilder.Task</code>属性获取。当stateMachine通过MoveNext走完每个状态后，会将最终结果，通过builder.SetResult写入到builder中的Task，如果中途出现异常，则通过builder.SetExpection保存，如此发起方可通过<code>try &#123;await xxx;&#125; catch (e Exception)&#123;...&#125;</code>捕获异常，最终整个编译器改写后的async函数，返回的实际上就是这个<code>builder.Task</code>。</li>
</ol>
<h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><p>除了直接跟Task外，<code>.NET</code>和Windows运行时也封装了部分关于网络IO，文件，图像等，这些方法通常都以Async结尾，可直接用于await。以下代码说明了跟在await后面的常见的几种函数，以便进一步理解其中的差异和原理。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为没有async标注，所以编译器不会为该函数生成状态机，但由于该函数返回的是Task，因此可以直接用于await</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">F1Async</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Task.Run(() =&gt; &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要标记了async 就会生成对应状态机，但这里有几点需要注意:</span></span><br><span class="line"><span class="comment">// 1. 如果方法声明为 async，那么可以直接 return 异步操作返回的具体值，不再用创建Task，由编译器通过builder创建Task</span></span><br><span class="line"><span class="comment">// 2. 由于该函数体内没有使用await，整个状态机相当于直接builder.SetResult(2)，其中不涉及异步操作和线程切换(没有await异步切换点)，因此整个过程实际上都是在主线程同步进行的(虽然经过了一层builder.Task封装)</span></span><br><span class="line"><span class="comment">// 3. 编译器也会提示Warning CS1998: This async method lacks &#x27;await&#x27; operators and will run synchronously.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">F2Async</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法在Task上套了一层空格子Task，看起来好像和F1Async没区别</span></span><br><span class="line"><span class="comment">// 但实际上，编译器仍然会生成对应的builder和wrapper task，这个wrapper task在原task完成之后，只是做了简单的return操作</span></span><br><span class="line"><span class="comment">// 因此 await F3Async() 实际上可能导致两次线程上下文切换，如果是在UI线程上执行await，用法不当则可能触发&quot;async/await 经典UI线程卡死&quot;场景，因为await会默认捕获SynchronizationContext。这个后面说。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">F3Async</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> Task.Run(() =&gt; &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h4><p>理解async/await基本原理后，不难发现，async/await本质上是不创建线程的，它只是一套状态机封装，以及通过回调驱动状态机的异步编程模型。await默认会捕获当前的执行上下文ExecuteContext，但是并不会捕获当前的同步上下文SynchronizationContext(关于ExcuteContext和SynchronizationContext的区别联系参考<a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/pfxteam/executioncontext-vs-synchronizationcontext/">executioncontext-vs-synchronizationcontext on MSDN</a>，强烈建议阅读)，同步上下文的捕获是由TaskAwaiter实现(见<a target="_blank" rel="noopener" href="https://referencesource.microsoft.com/#mscorlib/system/runtime/compilerservices/TaskAwaiter.cs,93">TaskAwaiter.OnCompleted</a>)，它会先获取<code>SynchronizationContext.Current</code>，如果没有或者是默认的，会再尝试获取Task对应的TaskScheduler上的SynchronizationContext。也就是说对TaskAwaiter而言，设置默认的SynchronizationContext和没有设置效果是一样的(为了少一次QueueWorkItem，对应源码在<a target="_blank" rel="noopener" href="https://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs,2976">这里</a>，我们可以结合前面的AsyncTask，以及下面的进一步测试来验证:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title">MySynchronizationContext</span> : <span class="title">SynchronizationContext</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">SendOrPostCallback d, <span class="built_in">object</span> state</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MySynchronizationContext Post, thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">base</span>.Post(d, state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">AsyncTask</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="comment">// 创建并使用自定义的SynchronizationContext</span></span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">new</span> MySynchronizationContext();</span><br><span class="line">    SynchronizationContext.SetSynchronizationContext(context);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;AsyncTask: before await, thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">await</span> Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;AsyncTask: in task, thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">666</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;AsyncTask: after await, got result: &#123;0&#125;, thread&#123;1&#125;&quot;</span>, a, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AsyncTask();</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output (使用自定义的SynchronizationContext):</span></span><br><span class="line"><span class="comment">// AsyncTask: before await, thread1</span></span><br><span class="line"><span class="comment">// AsyncTask: in task, thread3</span></span><br><span class="line"><span class="comment">// MySynchronizationContext Post, thread3</span></span><br><span class="line"><span class="comment">// AsyncTask: after await, got result: 666, thread4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Output2 (使用默认的SynchronizationContext):</span></span><br><span class="line"><span class="comment">// AsyncTask: before await, thread1</span></span><br><span class="line"><span class="comment">// AsyncTask: in task, thread3</span></span><br><span class="line"><span class="comment">// AsyncTask: after await, got result: 666, thread3</span></span><br></pre></td></tr></table></figure>
<p>这说明了如果当前线程没有或者设置的默认的SynchronizationContex，那么await之后的回调委托实际上是在await的Task所在的线程上执行的(这一点和ContinueWith的默认行为不大一样，后者总是会通过QueueWorkItem跑在一个新的线程中)。</p>
<p>如果设置了非默认的SynchronizationContex，那么回调委托将通过<code>SynchronizationContex.Post</code>方法封送(由于SynchronizationContex本质也只是接口，我们这里并不能草率地说，会回到Caller线程)。如对于WPF这类UI框架而言，它实现的<code>DispatcherSynchronizationContext</code>最终通过<code>Dispatcher.BeginInvoke</code>将委托封送到UI线程。而如果你是在UI线程发起await，其后又在UI线程上使用<code>task.Result</code>同步等待执行结果，就可能解锁前面F3Async中提到的<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/371362645">UI线程卡死场景</a>，这也是新手最常犯的问题。你可以通过<code>task.ConfigureAwait(bool continueOnCapturedContext)</code>指定false来关闭指定Task捕获SynchronizationContex的能力，如此委托回调的执行线程就和没有SynchronizationContex类似了。</p>
<p>总结下，async/await本身不创建线程，<code>aaa; await bbb; ccc;</code> 这三行代码，可能涉及到一个线程(比如没有await，或任务立即完成，甚至await线程自己的异步操作)，两个线程(比如没有自定义SynchronizationContex，或有自己实现消息泵的的SynchronizationContex)，三个线程(有其他线程实现消息泵的自定义SynchronizationContex)。但具体涉及几个线程，GetAwaiter(通常返回的是TaskAwaiter，但是你也可以自定义)，SynchronizationContex等外部代码和环境决定的。</p>
<h4 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h4><h5 id="await与yield的区别"><a href="#await与yield的区别" class="headerlink" title="await与yield的区别"></a>await与yield的区别</h5><p>yield和await都是语法糖，最后都会被生成一个状态机，每行yield/await都对应其中一个状态。</p>
<ul>
<li>本质用途: yield用于快速构造枚举器，而await用于简化异步编程模型，两者都会生成状态机，但前对外表现为可枚举类，用于手动迭代，后者主要用于AsyncTaskMethodBuilder自动迭代(从调用async函数起，Builder就通过异步回调不断调用MoveNext，直至走完每个await状态)</li>
<li>线程切换: yield不涉及线程上下文的切换，而await通常涉及(前面说了，不是因为它会创建线程，而是依赖具体的异步操作，以及同步上下文)</li>
</ul>
<h5 id="C-async-await-vs-JS-Generator异步"><a href="#C-async-await-vs-JS-Generator异步" class="headerlink" title="C# async/await vs JS Generator异步"></a>C# async/await vs JS Generator异步</h5><p>既然async/await也是异步编程模型，同样的，我们也将C# async/await用Generator异步编程四要素来分析下:</p>
<ul>
<li>Generator: C# yield是由编译器生成状态机类并实现IEnumerable，类似的，C# async/await也是编译器生成的可迭代状态机IAsyncStateMachine，不过它只有MoveNext()方法，看起来甚至不能单向传值。不过事实上，它的双向传值机制都封装在状态机类内部了</li>
<li>Thunk: await也有Awaitable标准，它需要实现INotifyCompletion的<code>OnCompleted(Action continuation)</code>方法，这也就提供了统一的挂载回调标准。C# Task和JS Promise一样，都实现了异步执行和回调挂接分离</li>
<li>AsyncOp: C#的Task原生适配了Awaitable，并且Awaitable也非常易于开发者扩展(后面讲UniTask还会详述)</li>
<li>Iterator: 整个状态机的驱动，由前面提到的AsyncTaskMethodBuilder来完成，它负责将await之后的执行路径通过OnCompleted挂载到异步操作上</li>
</ul>
<p>强行将C# async/await映射到四要素可能不是很合适，因为C# async/await的Generator和Iterator是一体生成的，严格上不涉及所谓的执行权转移。C# async/await 是在async function外部直接生成一个状态机Wrapper类，对函数执行入口、返回值等进行了”魔改”。而JS Generator异步，是通过自定义的run函数或第三方co库驱动迭代。因此C#的async/await可以进行任意函数层级嵌套，而无需像JS一样每一个Generator都要单独驱动，另外C# async/await 可能涉及到线程切换，而JS则通常都是在单线程。</p>
<h5 id="async-await是Task-状态机的语法糖"><a href="#async-await是Task-状态机的语法糖" class="headerlink" title="async/await是Task+状态机的语法糖"></a>async/await是Task+状态机的语法糖</h5><p>这个要从两方面看，一方面，async函数在经过编译器处理后，最终返回给调用方的，是builder中的Task对象(这也是为何async方法的返回值只能是<code>void</code>, <code>Task</code>, <code>Task&lt;TResult&gt;</code>)。而另一方面，await本身不关注Task，它支持所有提供异步相关接口的对象(GetAwaiter)，这样的好处在于除了Task，它还可以集成更多来自框架(比如<code>.NET</code>已经提供的各种Async API)，甚至自定义的异步对象，已有的异步操作也可以通过适配GetAwaiter移植到新的async/await异步编程模型。</p>
<h5 id="出现await的地方，当前线程就会返回，或发生线程上下文切换"><a href="#出现await的地方，当前线程就会返回，或发生线程上下文切换" class="headerlink" title="出现await的地方，当前线程就会返回，或发生线程上下文切换"></a>出现await的地方，当前线程就会返回，或发生线程上下文切换</h5><p>这个前面也解释过了，出现await的地方未必会涉及线程上下文切换，比如前面的<code>await F2Async()</code>，对它的整个调用都是同步的。异步编程和线程无关，线程切换取决于异步操作的实现细节，而await本身只关注与异步操作交互的接口。</p>
<h3 id="Unity-async-await"><a href="#Unity-async-await" class="headerlink" title="Unity async/await"></a>Unity async/await</h3><p>Unity也引入了C# async/await机制，并对其进行了适配:</p>
<ol>
<li>Unity本身也是UI框架，因此它实现了自己的同步上下文<a target="_blank" rel="noopener" href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Scripting/UnitySynchronizationContext.cs">UnitySynchronizationContext</a>以及主线程的消息泵，如此await的异步委托会默认会回到Unity主线程执行(可通过task.ConfigureAwait配置)</li>
<li>Unity社区提供了针对大部分常见YieldInstruction(如WaitForSeconds)，以及其他常用库(如UnityWebRequest、ResourceRequest)的GetAwaiter适配(如<a target="_blank" rel="noopener" href="https://github.com/svermeulen/Unity3dAsyncAwaitUtil">Unity3dAsyncAwaitUtil</a>)</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/svermeulen/Unity3dAsyncAwaitUtil">Unity3dAsyncAwaitUtil</a>这个库及其相关Blog: <a target="_blank" rel="noopener" href="http://www.stevevermeulen.com/index.php/2017/09/using-async-await-in-unity3d-2017/">Async-Await instead of coroutines in Unity 2017</a>，非常值得了解一下，以适配大家最熟悉的YieldInstruction WaitForSeconds(3)为例，来大概了解下如何通过将它适配为可以直接<code>await WaitForSeconds(3);</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetAwaiter</span></span><br><span class="line"><span class="comment">// 适配WaitForSeconds类的GetAwaiter方法，通过GetAwaiterReturnVoid返回其Awaiter对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SimpleCoroutineAwaiter <span class="title">GetAwaiter</span>(<span class="params"><span class="keyword">this</span> WaitForSeconds instruction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GetAwaiterReturnVoid(instruction);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// GetAwaiterReturnVoid</span></span><br><span class="line"><span class="comment">// 创建和返回Awaiter: SimpleCoroutineAwaiter</span></span><br><span class="line"><span class="comment">// 并在Unity主线程执行InstructionWrappers.ReturnVoid(awaiter, instruction)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SimpleCoroutineAwaiter <span class="title">GetAwaiterReturnVoid</span>(<span class="params"><span class="built_in">object</span> instruction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> awaiter = <span class="keyword">new</span> SimpleCoroutineAwaiter();</span><br><span class="line">    RunOnUnityScheduler(() =&gt; AsyncCoroutineRunner.Instance.StartCoroutine(</span><br><span class="line">        InstructionWrappers.ReturnVoid(awaiter, instruction)));</span><br><span class="line">    <span class="keyword">return</span> awaiter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// InstructionWrappers.ReturnVoid</span></span><br><span class="line"><span class="comment">// 这里其实已经在Unity主线程，所以这里本质是将await最终换回了yield，由Unity来驱动WaitForSeconds的完成</span></span><br><span class="line"><span class="comment">// 只不过yield完成之后，通过awaiter.Complete回到Awaiter.OnCompleted流程去</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerator <span class="title">ReturnVoid</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            SimpleCoroutineAwaiter awaiter, <span class="built_in">object</span> instruction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// For simple instructions we assume that they don&#x27;t throw exceptions</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> instruction;</span><br><span class="line">    awaiter.Complete(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保Action在Unity主线程上运行</span></span><br><span class="line"><span class="comment">// SyncContextUtil.UnitySynchronizationContext在插件Install的时候就初始化好了</span></span><br><span class="line"><span class="comment">// 如果发现当前已经在Unity主线程，就直接执行Action，无需自己Post自己</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RunOnUnityScheduler</span>(<span class="params">Action action</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (SynchronizationContext.Current == SyncContextUtil.UnitySynchronizationContext)</span><br><span class="line">    &#123;</span><br><span class="line">        action();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        SyncContextUtil.UnitySynchronizationContext.Post(_ =&gt; action(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正的Awaiter，它是无返回值的，对应还有一个SimpleCoroutineAwaiter&lt;T&gt;版本</span></span><br><span class="line"><span class="comment">// 它的实现比较简单，就是适配接口，记录委托回调(_continuation)，并在Compele()任务完成时，通过RunOnUnityScheduler封送委托回调</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleCoroutineAwaiter</span> : <span class="title">INotifyCompletion</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> _isDone;</span><br><span class="line">    Exception _exception;</span><br><span class="line">    Action _continuation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsCompleted</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _isDone; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetResult</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Assert(_isDone);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_exception != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ExceptionDispatchInfo.Capture(_exception).Throw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Complete</span>(<span class="params">Exception e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Assert(!_isDone);</span><br><span class="line"></span><br><span class="line">        _isDone = <span class="literal">true</span>;</span><br><span class="line">        _exception = e;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Always trigger the continuation on the unity thread when awaiting on unity yield</span></span><br><span class="line">        <span class="comment">// instructions</span></span><br><span class="line">        <span class="keyword">if</span> (_continuation != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RunOnUnityScheduler(_continuation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> INotifyCompletion.OnCompleted(Action continuation)</span><br><span class="line">    &#123;</span><br><span class="line">        Assert(_continuation == <span class="literal">null</span>);</span><br><span class="line">        Assert(!_isDone);</span><br><span class="line"></span><br><span class="line">        _continuation = continuation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此我们就可以直接使用<code>await WaitForSeconds(3);</code>了，深入细节可以发现，不管是WaitForSeconds本身，还是之后的回调委托，其实都是在Unity主线程中执行的，并且结合RunOnUnityScheduler的优化，整个过程既不会创建线程，也不会产生额外的消息投递，只是在yield上加了一层壳子而已。这也再次说明了，async/await本身只是异步编程模型，具体的线程切换情况，Awaiter，SynchronizationContext，ConfigureAwait等综合控制。</p>
<p>这个工具库还有一些有意思的小特性，比如Task到IEnumerator的转换(原理就是轮询Task完成状态)，通过<code>await new WaitForBackgroundThread();</code>切换到后台线程(原理其实就是对<code>task.ConfigureAwait(false)</code>的封装)，这些在理解整个async/await，Unity协程，SynchronizationContext等内容后，都应该不难理解了。</p>
<p>另外，这里有篇关于<a target="_blank" rel="noopener" href="https://www.linkedin.com/pulse/unity-async-vs-coroutine-jo%C3%A3o-borks">Unity中async/await与coroutine的性能对比</a>，可以看看。</p>
<h3 id="Unity-UniTask"><a href="#Unity-UniTask" class="headerlink" title="Unity UniTask"></a>Unity UniTask</h3><p>通过前面的了解，可以发现，在Unity中，Coroutine可以用来实现单线程内的异步操作，Task可用来实现多线程的并发、异步和协同操作。而async/await是一种比Coroutine和Task更抽象易用的异步编程模型，C#完成了Task和async/await的适配，Unity3dAsyncAwaitUtil完成了Coroutine和async/await的适配，但对Unity开发者而言，还是不够方便，开发者面临过多方案选择: yield Coroutine or await Coroutine or await Task，因此，Unity社区又有大神出手，出了一套新方案: <a target="_blank" rel="noopener" href="https://github.com/Cysharp/UniTask">UniTask</a>，它的目的是整合Coroutine的轻量、Task的并发、async/await的易用于一体，为开发者提供高性能、可并发、易使用的接口。</p>
<p>它的主要特性包括:</p>
<ul>
<li>基于值类型的 UniTask<T> 和自定义的 AsyncMethodBuilder 来实现0GC</li>
<li>使所有 Unity 的 AsyncOperations 和 Coroutines 可等待 (类似Unity3dAsyncAwaitUtil的适配)</li>
<li>基于 PlayerLoop 的任务(UniTask.Yield, UniTask.Delay, UniTask.DelayFrame…)可以替代所有协程操作</li>
<li>对 MonoBehaviour 消息事件和 uGUI 事件进行 可等待/异步枚举 拓展</li>
<li>与C#原生 Task/ValueTask/IValueTaskSource 行为高度兼容</li>
<li>…</li>
</ul>
<p>更详细UniTask功能介绍，推荐<a target="_blank" rel="noopener" href="https://www.lfzxb.top/unitask_reademe_cn/">这篇博客</a>，UniTask一方面保留和适配 Unity Coroutine的轻量单线程异步模型，另一方面，将Coroutine的惯用场景(如WaitForSeconds)全部移植到性能更优的UniTask上实现了一遍(受益于async/await异步模型的抽象性)，并且保持UniTask与Task语义兼容，保留大部分的Task并发和交互模型能力。</p>
<p>从实现上来说，以<code>UniTask.Delay</code>为例，它的功能类似于WaitForSeconds，它会返回一个<code>UniTask</code>对象，UniTask对象本身只是一层可await的壳子，真正起作用的对象是其持有的<code>DelayPromise</code>对象(<code>IUniTaskSource source</code>字段)，DelayPromise的有两个核心方法:</p>
<ul>
<li><code>OnCompleted</code>: AsyncUniTaskMethodBuilder挂接异步回调会通过UniTask Awaiter调到这里，它只是简单转调用<code>core.OnCompleted</code>，<code>UniTaskCompletionSourceCore core</code>是UniTask Promise都有的字段，做一些核心代码复用</li>
<li><code>MoveNext() bool</code>: 它会检查时间是否到期，未到期返回true，到期则通过<code>core.TrySetResult(null)</code>设置完成状态，并返回true。注意，<code>core.TrySetResult</code>中，会调用并执行continuation</li>
</ul>
<p>异步挂接和回调机制有了，谁来驱动<code>IUniTaskSource.MoveNext</code>，注意，这个MoveNext和C#中的<code>IAsyncStateMachine.MoveNext</code>是不同的:</p>
<ul>
<li><code>IAsyncStateMachine.MoveNext</code>: 通过AsyncTaskMethodBuilder来驱动async/await语法糖生成的状态机，对于<code>await Task.Run</code>而言，Task在线程池中执行完成了，那么一个状态机的状态就完成了，并且由Task的ContinueWith机制负责调用continuation继续驱动状态机(继续调用MoveNext)</li>
<li><code>IUniTaskSource.MoveNext</code>: 用于确定状态机的某个状态是否已经完成，<code>UniTask.Delay</code>本质是不切换线程的，如Unity Coroutine一样，必然需要额外的Ticker/Event/Poll这类机制，来检查状态变更(如Delay到期)，设置Awaiter Result，并回调continuation(通过<code>core.TrySetResult(null)</code>)</li>
</ul>
<p>驱动<code>IUniTaskSource.MoveNext</code>的工作是由<a target="_blank" rel="noopener" href="https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/Internal/PlayerLoopRunner.cs">PlayerLoopRunner</a>来完成的，DelayPromise创建之后，就会被立即添加到PlayerLoop Action中，PlayerLoopRunner穿插在Unity的各个执行Timing，驱动/检查所有IPLayerLoopItem任务的MoveNext。</p>
<p>对于<code>UniTask.Yield(PlayerLoopTiming.FixedUpdate);</code>这类场景，UniTask的实现更为简单，直接在<code>YieldAwaitable.OnCompleted(continuation)</code>挂接异步回调时，将continuation挂在PlayerLoop上即可，PlayerLoop会在对应timing(如FixedUpdate)触发时，调用continuation。</p>
<p>另外，<code>UniTask.Run/RunOnThreadPool</code>不使用默认的UnitySynchronizationContext和ExecutionContext，而是自己做同步上下文切换，这一点可能会容易和原生Task行为混淆，虽然它也提供<code>UniTask.SwitchToMainThread</code>、<code>UniTask.SwitchToThreadPool</code>、<code>UniTask.ReturnToCurrentSynchronizationContext</code>等API进行精确的同步上下文控制。</p>
<p>UniTask将Unity单线程异步编程诸多实践与async/await异步编程模型有机整合，并对Unity Coroutine与C# Task的诸多痛点进行优化和升级，看起来确实有一统Unity异步编程模型的潜力，应该离整合进Unity官方包也不远了。</p>
<h3 id="一点体会"><a href="#一点体会" class="headerlink" title="一点体会"></a>一点体会</h3><p>首先我是个C#和Unity的门外汉，只是谈谈自己的体会，异步编程尤其是并发编程从来都不是一件简单的事，无论它看起来多么”简洁优雅”。学习各语言/框架的异步演进史，是一件非常有意思的事情:</p>
<ul>
<li>C#: Thread(关注实现) -&gt; Task(关注任务) -&gt; async/await(关注可读性和扩展性)</li>
<li>Unity: Coroutine(Engine做大量支持，算半个异步编程模型) -&gt; Unity3DAsyncAwaitUtil(将Coroutine适配到async/await) -&gt; 到UniTask(整合Coroutine和Task，兼并性能更高、可读性更高、更适合Unity)</li>
<li>JS: Callback(最原始) -&gt; Generator+Thunk+AsyncOp+Iterator异步(初步四件套) -&gt; Promise(统一规范异步操作) -&gt; Generator+Promise+co(标准三件套) -&gt; async/await+Promise(终极两件套)</li>
</ul>
<p>异步编程模型一直在演进，看起来写越来越”简单”，可读性越来越”高”，代价是编译器和运行时做了更多的工作，并且这些工作和原理是作为开发者必须要了解的，以C# async/await为例，如果不能充分了解底层原理，就容易引发: </p>
<ul>
<li>异步回调闭包引用可变上下文的问题</li>
<li>async “无栈编程”本身带来的理解负担和调试难度</li>
<li>代码的线程上下文难以分析，容易引发并发安全访问的问题</li>
<li>同一段代码在不同的线程执行可能具有完全不同的行为(SynchronizationContext和ExecuteContext不同)</li>
</ul>
<p>等问题。语言和框架本身只提供选择，作为使用者的我们，在并发越来越”容易”的同时，保持对原理的理解，才能充分发挥工具的作用(享受上限高的好处，避免下限低的问题)。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>wudaijun
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://wudaijun.com/2021/11/c-sharp-unity-async-programing/" title="C#&#x2F;Unity中的异步编程">http://wudaijun.com/2021/11/c-sharp-unity-async-programing/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/coroutine/" rel="tag"><i class="fa fa-tag"></i> coroutine</a>
              <a href="/tags/async-programing/" rel="tag"><i class="fa fa-tag"></i> async programing</a>
              <a href="/tags/unity/" rel="tag"><i class="fa fa-tag"></i> unity</a>
              <a href="/tags/c/" rel="tag"><i class="fa fa-tag"></i> c#</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/software-engineering-ability/" rel="prev" title="软件工程能力">
      <i class="fa fa-chevron-left"></i> 软件工程能力
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/slg-server-mindmap/" rel="next" title="SLG游戏服务器随想">
      SLG游戏服务器随想 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-yield"><span class="nav-text">C# yield</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unity-Coroutine"><span class="nav-text">Unity Coroutine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-Task"><span class="nav-text">C# Task</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-async-await"><span class="nav-text">C# async&#x2F;await</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95"><span class="nav-text">基础用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="nav-text">线程切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85"><span class="nav-text">一些补充</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#await%E4%B8%8Eyield%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">await与yield的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-async-await-vs-JS-Generator%E5%BC%82%E6%AD%A5"><span class="nav-text">C# async&#x2F;await vs JS Generator异步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#async-await%E6%98%AFTask-%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="nav-text">async&#x2F;await是Task+状态机的语法糖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BA%E7%8E%B0await%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%8C%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%B0%B1%E4%BC%9A%E8%BF%94%E5%9B%9E%EF%BC%8C%E6%88%96%E5%8F%91%E7%94%9F%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-text">出现await的地方，当前线程就会返回，或发生线程上下文切换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unity-async-await"><span class="nav-text">Unity async&#x2F;await</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unity-UniTask"><span class="nav-text">Unity UniTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%82%B9%E4%BD%93%E4%BC%9A"><span class="nav-text">一点体会</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wudaijun"
      src="/assets/theme/avatar.png">
  <p class="site-author-name" itemprop="name">wudaijun</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">132</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wudaijun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wudaijun" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/wudaijun" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;wudaijun" rel="noopener" target="_blank"><i class="fab fa-contao fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2014 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wudaijun</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'mcuD0S7ohGooofXt3SJ62qW2-9Nh9j0Va',
      appKey     : 'qvWjHt4jMELAWtqmpdK6Mh9Q',
      placeholder: "Leave something ...",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
