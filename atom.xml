<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wudaijun&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/eb575f4256a9fe4728b794090470955c</icon>
  <subtitle>Done is better than perfect</subtitle>
  <link href="http://wudaijun.com/atom.xml" rel="self"/>
  
  <link href="http://wudaijun.com/"/>
  <updated>2023-12-31T04:21:57.773Z</updated>
  <id>http://wudaijun.com/</id>
  
  <author>
    <name>wudaijun</name>
    <email>wdjlost@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习小记</title>
    <link href="http://wudaijun.com/2023/08/machine-learning/"/>
    <id>http://wudaijun.com/2023/08/machine-learning/</id>
    <published>2023-08-16T16:00:00.000Z</published>
    <updated>2023-12-31T04:21:57.773Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/image/202308/机器学习.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/assets/image/202308/机器学习.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="gameserver" scheme="http://wudaijun.com/categories/gameserver/"/>
    
    
    <category term="gameserver" scheme="http://wudaijun.com/tags/gameserver/"/>
    
  </entry>
  
  <entry>
    <title>SLG跨服模型</title>
    <link href="http://wudaijun.com/2023/03/slg-cross-map-model/"/>
    <id>http://wudaijun.com/2023/03/slg-cross-map-model/</id>
    <published>2023-03-13T16:00:00.000Z</published>
    <updated>2023-03-21T07:21:12.369Z</updated>
    
    <content type="html"><![CDATA[<p>SLG是重生态边界和导量策略的游戏，游戏到了中后期，为了维护玩家的新鲜感，扩大社交范围，提升留存和付费。会伴随各种各样的跨服玩法。其中以KvK(Kingdom vs Kingdom)持续时间最长(一个月左右)，最为复杂(玩家可以在KvK中参与城建、活动、联盟等各种玩法，与原服的体验很接近)。本文以KvK为出发点，聊聊关于SLG跨服模型的一些实践和思考。</p><p>在此之前，有必要对游戏中常见的跨服、合服、迁服几个概念进行区分:</p><ul><li>跨服: 生态的摩擦和碰撞</li><li>合服: 生态的融合和重组</li><li>迁服: 生态的流动和微调</li></ul><p>KvK跨服战场活动的简单示意图如下:</p><p><img src="/assets/image/202303/kvkserver.jpg" width="50%" height="50%"></p><p>对玩家而言，体验最好的KvK玩法应该是轻量的，即玩家可随时自愿加入和退出，KvK战场活动持续期间，原服和KvK服都可以有玩家在玩。并且玩家切换战场的成本应该最小化，如联盟关系、活动进度、邮件、聊天等数据都应该尽可能保留。</p><p>以下聊聊我们在实际项目中，对KvK跨服的三种理解(领域模型)和实现，并简单以Model1，Model2，Model3区分。</p><span id="more"></span><h3 id="Model1-将KvK实现为飞服"><a href="#Model1-将KvK实现为飞服" class="headerlink" title="Model1 将KvK实现为飞服"></a>Model1 将KvK实现为飞服</h3><p>服务器框架早期基于一个依赖赛季合服(冷数据处理)进行KvK的项目，因此框架早期并未对跨服模型做过多考虑，单个服务器的活动、联盟、地图、城建相关数据，均内聚在一个Game节点上。在之后的项目开发到中期的时候，发现想要实现竞品级别的KvK(尤其是保留活动和联盟数据)，成本非常高。因此有的项目综合考虑，选择了通过玩家飞服的方式来实现KvK。这种思路的核心是将KvK战场看做一个完整的服务器生态(Game节点)，在玩家进入KvK战场时，需要进行数据清洗、剥离、迁移和恢复:</p><ol><li>玩家数据: 剥离打包原服玩家数据并迁移到新服，如果想对原服生态造成的影响尽可能小(如想保留一份玩家数据镜像在联盟、排行榜等系统，避免原服快速过于”冷清”，或者是想管理一些原服强相关的玩家数据)，需要谨慎处理数据的清洗、迁移和合并。另外玩家在原服地图上是消失的，避免产生玩家交互引发数据变更</li><li>活动数据: 对活动数据做剥离和恢复(尤其是个人活动)，对于非个人活动而言，由于各服活动投放内容和进度不一样，很难跨地图保留(但可以回原服之后恢复)。并且由于活动本身的多样性性和灵活性，这个过程很容易产生各种BUG</li><li>联盟数据: 联盟数据与各系统的耦合较重，很难扩展为跨服联盟，因此玩家进入KvK服后，联盟关系会丢失，玩家在KvK服需要新建联盟，但为了保留原服生态，玩家在原服的联盟中会存在一个”镜像玩家”，同时也让跨服玩家回来(经过数据合并)也不需要重新加入联盟</li><li>服务器关系: 从玩法上而言，各个玩家并不算是真正迁入了KvK服(玩家所属服务器仍然为原服，否则很难制造生态摩擦)，因此玩家身上本质有两个字段，原服和KvK服，部分业务逻辑需要围绕这两个字段特殊处理，如登陆流程、两个全服聊天频道等</li><li>其他功能: 如聊天、邮件、以及其他需要单独跨服的功能，都需要单独评估，做数据剥离迁移</li></ol><p>Model1示意图如下:</p><p><img src="/assets/image/202303/kvk-by-transfer-server.jpg" width="50%" height="50%"></p><p>这种方案的优势:</p><ul><li>延迟跨服决策，前期开发效率高</li><li>单服大部分业务数据都在单节点内部，数据一致性高，并支持滚动部署(单个服务器只停服几分钟)</li></ul><p>劣势:</p><ul><li>对跨服玩法的原生支持比较差，如部分活动数据，联盟关系这类数据很难保留</li><li>基于各种考虑，最终的实现可能并不是纯粹的数据迁移，而是原服和KvK都有部分玩家数据，需要谨慎处理数据的清洗、剥离和合并</li><li>之后每添加一个(或想要从已有玩法切换为)跨服玩法，都要单独考虑数据的剥离和迁移，开发成本高，且容易产生各种BUG</li><li>对于其他更轻量的跨服地图玩法，如GvG(持续一小时左右的地图副本)，需要额外做跨服地图副本或迁服机制，无法复用KvK服逻辑(没必要做数据迁移)</li></ul><h3 id="Model2-将KvK实现为跨服"><a href="#Model2-将KvK实现为跨服" class="headerlink" title="Model2 将KvK实现为跨服"></a>Model2 将KvK实现为跨服</h3><p>鉴于Model1.0的一些经验，也有项目开始提前规划对跨服业务进行重构和拆分，即将联盟、活动这类跨服系统(需要在跨KvK战场时保留的系统)从原服抽离出来单独维护。如此玩家在进出KvK时，可以保留活动和联盟数据，同时玩家数据迁移也更轻量。</p><p>Model2示意图如下:</p><p><img src="/assets/image/202303/kvk-by-cross-server.jpg" width="50%" height="50%"></p><p>这种思路的主要考虑点:</p><ul><li>跨服活动: 解耦活动系统，支持多个服务器可以参加同一个活动(可以考虑实现为KvK服的活动，或者参与KvK的Server Group的活动)</li><li>跨服联盟: 解耦联盟系统，支持一个联盟的玩家可以处于不同的服务器上</li><li>数据迁移: 仍然要考虑玩家数据(主要是养成相关)剥离和迁移过程，及其性能、数据一致性、服务器关系等</li><li>架构设计: 如数据共享、依赖关系、网络拓扑、负载和部署策略、数据一致性等</li></ul><p>优势:</p><ul><li>相对完整的跨服功能支持</li><li>数据迁移更轻量</li></ul><p>劣势:</p><ul><li>需要较早地规划业务设计和解耦(尤其是需要跨服的功能)，对于业务已经成型的项目，还考验渐进重构的能力</li><li>这套思路有点往大服方向走，因此在前期开发效率、部署更新流程、数据一致性方面，也要多做考虑</li><li>对于更轻量的跨服地图玩法，仍然需要额外实现一套地图副本机制</li></ul><h3 id="Model3-将KvK实现为跨地图副本"><a href="#Model3-将KvK实现为跨地图副本" class="headerlink" title="Model3 将KvK实现为跨地图副本"></a>Model3 将KvK实现为跨地图副本</h3><p>在Model1和Model2的实现中，主要将KvK服理解为一个相对完整的生态，技术上也用独立的服务器进程来实现。</p><p>打个可能不是很恰当的比喻，KvK就像是车主因为某些原因，不得不换辆车:</p><ul><li>Model1: 为车主尽可能把车上装饰物和随身物品打包(数据剥离和迁移)好</li><li>Model2: 将车上的更多影响用户体验的组件，如方向盘(联盟系统)，座位(活动系统)，提前规划为可拆卸替换的(跨服系统)，这样用户在换车的时候，不会感到不适应</li></ul><p>而Model3的想法，是重新审视车主需求，即他为什么要换车。可能只是车胎没气了，那么对症下药，换车胎就行了。回到KvK来，KvK的本质是创造一个跨服临时战场，以激活后期生态(而不是合并后期生态)，刺激付费和留存。因此，<strong>KvK的本质不是跨服，而是跨地图副本</strong>。</p><p>Model3图示如下:</p><p><img src="/assets/image/202303/kvk-by-cross-map.jpg" width="50%" height="50%"></p><p>注: 联盟、活动、养成可以选择部署在一个节点上(数据一致性和开发效率更高)，也可以部署在不同的节点(如有真正的跨服联盟需求)，但部署边界不等于业务边界，联盟、活动、养成这些系统，从业务设计上应该尽可能解耦，提升可维护、可测试、可扩展性。</p><p>Model3模型核心思路:</p><ul><li>地图副本: 将地图和养成、联盟、活动等玩法解耦，原服大地图也通过副本机制来实现。除了活动和联盟，其他系统可能需要围绕地图进行调整，如排行榜，邮件聊天组，天下大势，养成系统(如果不同地图的养成线有差异)等。MapID和ServerID将是两个不同的概念，一个ServerID的玩家可能在不同的MapID，一个MapID的玩家也可能来自于不同的Server</li><li>跨地图联盟: 联盟本质不再需要跨服，只需要支持一个联盟的玩家可能处于不同的地图副本上(有不同的势力范围和联盟建筑)，这个要比跨服联盟实现起来更简单很多，也不需要额外的联盟节点</li><li>跨地图活动: 活动支持跨地图也比跨服更简单。真正的跨服活动，可以按照Map Owner(地图专属活动)，Cross Wrapper(轻度跨服活动)，ServerGroup Owner(重度跨服活动)等多种方案来扩展</li><li>数据迁移: 玩家的KvK战场切换，本质只是地图切换，只同步极少量地图需要的初始化数据即可，无需再迁移玩家、联盟、活动等数据</li></ul><p>如果我们沿着Model2的思路，将Model1切换KvK服要保留的联盟、活动、养成系统这些全部剥离出来，最终可能会发现，唯一不能保留，真正要切换的(车主换车的原因)，只有地图。而联盟、养成系统这类玩法，也并不是真的必须要支持跨服，而是只需支持跨地图。Model3是一种以终为始的方案，是对领域知识充分消化的结果。</p><p>优势:</p><ul><li>进一步精化了领域模型，解决了Model2一些领域模型不恰当导致问题，如需要剥离的跨”服”业务过多、玩家的服务器关系问题、原服和KvK服的活动冲突、KvK服不应该创建联盟、KvK服的动态生命周期等问题</li><li>用同一套方案处理原服地图、KvK、GvG等玩法，开发效率、复用性、健壮性方面都有优势</li><li>由于原服地图也拆为了副本，因此想要实现类似飞服(A服玩家可以飞到B服地图上去PK)这种玩法也比较容易，和跨KvK副本是一套机制</li><li>地图副本可以动态开启，灵活负载，更能满足SLG跨服常态化、轻量化、自动化的趋势</li></ul><p>劣势:</p><ul><li>拆分地图的技术难度，包括性能、数据一致性、依赖关系、部署策略，以及各种异常下的容错与故障恢复等等。尽管地图副本在MMO中是非常成熟的概念，但SLG的离线策略、实时战斗、无极缩放等特性，为这套机制带来了新的内容和挑战</li><li>需要持续和策划围绕地图副本的概念对各业务系统做必要的调整，持续迭代业务模型</li></ul><p>本文并不扩展讨论各种技术实现细节，更多地从业务领域的角度来讨论SLG跨服的实现思路和常见模型。模型没有优劣，只有是否和业务匹配之分，模型如架构，是设计的结果，也是权衡的结果。SLG跨服这类复杂业务而言，前期业务模型设计的优劣将很大程度决定后期架构的可扩展和可维护性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SLG是重生态边界和导量策略的游戏，游戏到了中后期，为了维护玩家的新鲜感，扩大社交范围，提升留存和付费。会伴随各种各样的跨服玩法。其中以KvK(Kingdom vs Kingdom)持续时间最长(一个月左右)，最为复杂(玩家可以在KvK中参与城建、活动、联盟等各种玩法，与原服的体验很接近)。本文以KvK为出发点，聊聊关于SLG跨服模型的一些实践和思考。&lt;/p&gt;
&lt;p&gt;在此之前，有必要对游戏中常见的跨服、合服、迁服几个概念进行区分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨服: 生态的摩擦和碰撞&lt;/li&gt;
&lt;li&gt;合服: 生态的融合和重组&lt;/li&gt;
&lt;li&gt;迁服: 生态的流动和微调&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;KvK跨服战场活动的简单示意图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/image/202303/kvkserver.jpg&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;&lt;/p&gt;
&lt;p&gt;对玩家而言，体验最好的KvK玩法应该是轻量的，即玩家可随时自愿加入和退出，KvK战场活动持续期间，原服和KvK服都可以有玩家在玩。并且玩家切换战场的成本应该最小化，如联盟关系、活动进度、邮件、聊天等数据都应该尽可能保留。&lt;/p&gt;
&lt;p&gt;以下聊聊我们在实际项目中，对KvK跨服的三种理解(领域模型)和实现，并简单以Model1，Model2，Model3区分。&lt;/p&gt;</summary>
    
    
    
    <category term="SLG" scheme="http://wudaijun.com/categories/SLG/"/>
    
    
    <category term="software design" scheme="http://wudaijun.com/tags/software-design/"/>
    
    <category term="DDD" scheme="http://wudaijun.com/tags/DDD/"/>
    
    <category term="SLG" scheme="http://wudaijun.com/tags/SLG/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统理论基础</title>
    <link href="http://wudaijun.com/2022/12/distributed-system-basic/"/>
    <id>http://wudaijun.com/2022/12/distributed-system-basic/</id>
    <published>2022-12-24T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.616Z</updated>
    
    <content type="html"><![CDATA[<p>起意是想梳理下分布式系统的一些基本概念和理论，做一张知识脉络图，后来发现内容太多，图片不适合，因此整理成了文字版本。不过整体框架结构仍然类似思维导图，用作知识联结与发散。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="什么是分布式系统？"><a href="#什么是分布式系统？" class="headerlink" title="什么是分布式系统？"></a>什么是分布式系统？</h3><p>系统中有若干独立自治的计算实体，每个实体有自己的内存状态，实体之间通过传递消息相互通信。整个系统对用户提供一致、统一的服务。</p><h3 id="为什么要使用分布式系统？"><a href="#为什么要使用分布式系统？" class="headerlink" title="为什么要使用分布式系统？"></a>为什么要使用分布式系统？</h3><p>使用分布式而不是单机的原因有很多，总的来说大概分为三类: </p><ul><li>解决业务问题: 如复杂度瓶颈、系统对接、成本考量等</li><li>解决扩展性问题: 如计算瓶颈、存储瓶颈、延迟优化等</li><li>解决可用性问题: 通过冗余提升可用性</li></ul><h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p>分布式系统关注哪些指标？或者说我们通过哪些指标来衡量一个分布式系统？</p><h3 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h3><p>定义: 系统通过添加资源来应对不断增长(或变更)的工作量的能力。</p><p>伸缩的维度有很多，包括规模伸缩、地理伸缩、功能伸缩、异构伸缩等。</p><p>理想情况下，期望系统处理能力随资源投入线性增长。而实际上，还要权衡通信成本和延迟、可用性、数据一致性等诸多方面。</p><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>定义: 系统处于正常工作状态的时间比例。</p><p>这里有两个个相关概念:</p><ul><li>MTBF(Mean Time Between Failure)：平均无故障时间，MTBF越长表示可靠性越高</li><li>MTTR(Mean Time To Repair):平均修复时间，MTTR越短表示易恢复性越好</li></ul><p>可用性 = 正常运行时间/(正常运行时间+故障时间) = MTBF/(MTBF+MTTR)。</p><span id="more"></span><p>注意可用性和可靠性的区别，可用性关注时间比例，可靠性关注时间间隔。假设一个系统每小时崩溃1ms，可用性高达99.9999%，但它仍然高度不可靠。</p><p>在实践中，可用性很难如它定义那般能明确度量，如部分功能可用、部分入口可用等。另外，用户感知的可用性与系统可用性也可能有差异(受用户本地缓存、重试机制、用户使用功能范围等影响)。</p><p>分布式系统可以通过容错来提升可用性，最常见的容错方案就是冗余(并行可用性)。不做额外容错的分布式系统，其可用性上限为其组成部分的可用性(串行可用性)。</p><p>基于不可靠的硬件和网络，打造高可用的系统和服务，是分布式系统的重要目标之一。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>定义: 有效工作量与所用时间和资源的比值。</p><p>提升性能的方式: 提升吞吐量(如并发)、降低响应延迟(受光速制约)、降低资源占用(性能优化)。</p><p>将响应延迟归入性能是比较有意思的，一方面，响应延迟当然受处理性能的影响，另一方面，响应延迟也受设计(如同步or异步)和架构(如异地多活)的影响。并且站在用户的角度上看，响应延迟是最直观的性能属性。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一致性这个概念用得很广(有点过度重载)，在我的理解中，分布式系统的一致性本质指预期一致性，即由多台计算机组成的分布式系统，能否像一台计算机一样，行为符合预期且容易理解，这是分布式系统的理想目标之一。但现实中，分布式系统与单机系统相比，要额外考虑部分故障、网络最小延迟、网络不可靠、没有全局时钟等因素，想到完全达到单机一样的可理解可预期是不可能的。但是我们可以通过技术手段和不同的一致性模型，增强用户对分布式系统行为的预期。</p><p>我将分布式中的一致性分为读写一致性和事务一致性。而这两者又分别和复制、分片这两个分布式基础技术相关。因此这两种具体的一致性，放到后面的复制与分片中再谈。</p><h2 id="现实"><a href="#现实" class="headerlink" title="现实"></a>现实</h2><p>在实践中，分布式系统受到哪些限制？或者说，哪些因素影响我们获得可伸缩、高可用、高性能、强一致性？</p><h3 id="各个节点独立并行运行"><a href="#各个节点独立并行运行" class="headerlink" title="各个节点独立并行运行"></a>各个节点独立并行运行</h3><p>分布式系统中的程序在独立的节点上并行运行，这里面有两个关键字”独立”和”并行”。</p><p>“独立运行”意味着独立失败，也就意味着分布式系统有比单机系统更高的硬件故障概率，这种部分故障，是分布式系统首先要考虑的问题。如系统如何检测到节点故障？如何在部分故障时仍然保持整个系统的可用性和数据一致性？</p><p>“并行运行”意味着时间、顺序、和一致性的问题，不同于节点内并发可以通过锁来做互斥同步，分布式系统实现锁的代价要大很多，比如使用Redis实现分布式锁，要考虑Redis本身的可用性问题，和Redis的网络通信的稳定性问题，节点故障后的锁释放问题等等。</p><h3 id="节点之间通过不可靠且有速度上限的网络通信"><a href="#节点之间通过不可靠且有速度上限的网络通信" class="headerlink" title="节点之间通过不可靠且有速度上限的网络通信"></a>节点之间通过不可靠且有速度上限的网络通信</h3><p>更多的节点，意味着更复杂的网络拓扑，也就会带来更高的管理和通信成本。这会影响影响分布式系统的性能(包括响应延迟)和扩展性问题。</p><p>更复杂的网络拓扑也意味着网络(部分)故障的概率更高，在不可靠网络下，我们甚至无法区分节点故障和网络分区。这极大增加了分布式系统容错的难度，如网络分区之后脑裂和一致性问题，网络恢复之后的数据冲突问题。</p><p>网络速度受光速限制，意味着每个节只能快速访问局部状态(内存状态)，任何关于全局的状态都是过时的，这对数据一致性也带来了挑战。</p><h3 id="没有全局时钟"><a href="#没有全局时钟" class="headerlink" title="没有全局时钟"></a>没有全局时钟</h3><p>秩序源于顺序，人对分布式一致性的理解离不开对顺序的假设，而最自然的顺序就是时间先后顺序。但分布式系统没有全局时钟，节点本地的时钟是不一致甚至不可靠(可人为篡改的)的，这使得并发分布式系统的行为很难理解，且很难察觉。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>针对现实中的节点故障、网络不可靠、以及全局时钟问题，有哪些相关的模型或假设？</p><h3 id="故障模型"><a href="#故障模型" class="headerlink" title="故障模型"></a>故障模型</h3><ul><li>node crash-stop failures: 节点崩溃-终止模型，该模型假定节点只会因为崩溃失败，失败后停止发送和接受消息，且不会恢复</li><li>node crash-recover failures: 节点崩溃-恢复模型，在crash-stop的基础上，假定节点可能随后恢复服务。这里还要分健忘和非健忘两种情况，即节点是否持久化了crash前的状态信息</li><li>byzantine failures: 拜占庭故障模型，在crash-recover模型上，进一步放宽约束，假定节点可能因为因为逻辑错误或其他原因导致不可信，即它可能伪造信息或输出错误信息。拜占庭故障基本是分布式系统最难的故障模型，解决它通常需要假设同步网络模型。拜占庭将军问题是拜占庭故障模型下衍生的共识问题</li><li>network partition failures: 网络分区故障模型，即是否假设节点间网络可能无限延迟或者不可达，这种情况和节点崩溃有所区别，因为网络分区下，不可达的节点可能已经崩溃或者仍在接受客户端请求(并且无法区分)。CAP定理中的P就表示网络分区故障容忍度</li></ul><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><ul><li>Synchrony: 同步网络模型，假定节点消息传输延迟有一个已知的上限值Δ，如此进程可以以锁步(lock-step)的方式执行(类似流水线作业)。同步网络模型易于分析和解决分布式问题，但实践中很难保证该假设的成立</li><li>Asynchrony: 异步网络模型，只保证消息最终会被投递，但消息传输延迟无上限。基于它而设计的分布式算法鲁棒性很强，但解决方案也更复杂，而FLP不可能定理(后面会提到)更是指明了全异步的网络模型下，想要在确定时间内让节点达成共识是不可能的。因此异步网络模型的共识算法，在极限网络状况下，有可能丧失活性</li><li>Partial synchrony: 部分同步/半同步网络模型，介于同步和异步之间，指存在一个网络传输延迟上限Δ，和一个特殊的事件GST(Global Stabilization Time，全局稳定时间)，如果一条消息在时间x被发出，那么它必然在<code>Δ+max(x,GST)</code>内投递。即网络模型在GST前是异步的，在GST后是同步的。但是这个GST何时发生无法预测。这个定义稍微晦涩一些，可以映射到现实中的网络状况，99%的时候传输延迟有上限，但是少数情况出现网络波动，或者对方受到DDos攻击时，传输延迟不可预估，不过最终网络还是会稳定下来，又回到正常有界传输的状态。GST风格的部分同步网络模型，允许构建在大多数情况(网络稳定)表现很好(可以使用比较保守的Δ值)，在少数情况(网络不稳定)时，也保证安全性(但可能丧失活性)的共识算法</li></ul><p>关于半同步网络模型的另一个定义是UL(Unknown Latency)风格: 网络始终是同步的，只是协议设计者不知道消息传输的最大延迟界限。它的核心思路是协议设计者需要动态调整传输上限Δ(按照系统最坏的延迟情况)，以逼近真正的网络延迟。<a href="https://decentralizedthoughts.github.io/2019-09-14-flavours-of-partial-synchrony/">这篇文章</a>尝试阐述基于GST和UL风格的定义在理论上是等价的。</p><p>目前主流的分布式算法，都是基于部分同步网络模型的，如Paxos，Raft，PBFT等。</p><h3 id="时间和顺序"><a href="#时间和顺序" class="headerlink" title="时间和顺序"></a>时间和顺序</h3><p>对单台计算机系统而言，确定操作的执行时间和顺序是比较容易的，这也使得系统的行为比较容易预测。而对于分布式系统而言，则需要重新理解时钟和顺序。</p><p>分布式系统中的顺序分为偏序和全序，偏序是每个节点看到的操作执行顺序，是对局部操作的局部视角。而全序则是整个系统所有事件的执行顺序，在分布式系统中，想要维护全序是比较困难的，因为网络是异步的，并且没有全局时钟。</p><p>分布式系统中的时钟分为物理时钟和逻辑时钟，物理时钟对应绝对时间，如各个节点的机器时间，想要完全同步各个节点的物理时钟是非常困难的(网络时间协议NTP、原子时钟本质都是减少误差而不能消除误差)。而逻辑时钟则对应相对时间，它关注分布式事件的相对顺序，如Lamport逻辑时钟(vector clock，矢量时间)可以用来维护事件因果关系的偏序，而大部分时候，我们期望的也是就”事件发生顺序”达成一致，而不是就”事件绝对时间”达成一致，换个角度来说，”时间”这个概念本身就没有绝对。在分布式系统中，对时间/顺序的假设和依赖越少，就越能充分发挥分布式系统的优势。</p><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>分布式系统中有哪些经典的理论和问题？</p><h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p>CAP定理主要阐述线性一致性(C)、高可用性(A)、网络分区故障容忍(P)不得兼得(三选二)。理解CAP定理的前提是认识到它作为理论模型的绝对(只考虑了最强的线性一致性和高可用)和局限(只关注了三个指标，其他还有性能、延迟、硬件故障、可读可写等)。不过CAP定理仍是分布式系统最重要的理论之一，它指出了分布式系统中一致性和可用性的权衡参考线，在此之上的分布式系统，要么加强假设(假设没有网络分区)，要么削弱保证(如提供更弱的一致性和可用性，以容忍网络分区，如BASE理论)。</p><p>通常来说，CA和CP系统以严格的仲裁协议来达成一致，区别是CA系统完全无法容忍(没有考虑)任何网络分区，如2PC两段式提交。而CP系统通常可以容忍部分网络分区并为此舍弃(至少少数节点一侧的)可用性。至于AP系统，则通常包含如何解决数据冲突的协议，如DNS系统。</p><p>从另一个角度来看，C、A描述的是系统的行为，而P描述的是系统的假设和工作范围。当我们说一个系统或算法是CA的，本质是说，如果没有网络分区，那么它是一致可用的(典型如2PC)，但是现实中的网络分区往往不可避免，因此当所谓的CA系统遇上不得不考虑的P时，通常就会变成CP、AP甚至P(既不线性一致，也不可用)系统。如2PC，它通常被认为属于CA系统，但当发生网络分区时，它可能是CP(如果参与者一直独占资源等待协调者通知Commit)或者P(如果参与者等待Commit通知超时后，自己会执行Commit避免独占，此时既不可用，也不一致)。</p><p>总之，由于CAP的局限性和系统的可配置性，将很多系统简单以CA、AP、CP来归类和讨论可能是不合适的。</p><h3 id="FLP不可能定理"><a href="#FLP不可能定理" class="headerlink" title="FLP不可能定理"></a>FLP不可能定理</h3><p>FLP不可能定理讨论的是在异步网络模型(不考虑网络分区故障)下，哪怕只有一台机器可能因为Crash出错(Crash-Stop模型)，则没有任何确定性共识算法保证在有限时间内结束。这是一个咋一看比较”悲观”的定理，它定义了异步网络下共识算法的上限，好在现实中的网络大部分时候都比较可靠，系统可以在网络超时时，舍弃一些活性和安全性。</p><h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><p>拜占庭将军问题，本质讨论，在有节点作恶的情况下，如何达成共识。拜占庭问题是如此出名，以至于主流共识算法通常被分为支持拜占庭问题(BFT)和不支持拜占庭问题(CFT)两类:</p><ul><li>拜占庭容错(Byzantine Fault Tolerance，BFT): 容忍节点故障和节点作恶，通常用在公网区块链上，经典如 PoW算法(最多容忍1/2作恶节点)，PBFT算法(最多容忍1/3作恶节点)</li><li>宕机容错(Crash Fault Tolerance，CFT):  即容忍节点故障，但是不考虑节点作恶的情况，经典算法有Raft、Paxos等。在实践中的大部分非公网分布式系统，都采用CFT算法，因为其通常具备更好的性能、可理解和可实现性</li></ul><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>“分”(分割)而”制”(复制)之是分布式系统的最核心最基础的技术方案，前者解决存储、计算、以及业务复杂度瓶颈，后者提升可用性和性能。</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>在多台机器上维护相同的数据副本，为同样一份数据提供更多的处理能力、位置扩展和容错，提升系统的性能和可用性。数据复制的挑战主要在于一致性(读写一致性)和容错。由于分布式系统中，各个节点通常都是相同的确定性状态机，因此大部分场景下，复制问题也称为状态机复制(State-Machine Replication)问题。</p><h4 id="读写一致性"><a href="#读写一致性" class="headerlink" title="读写一致性"></a>读写一致性</h4><p>指多数据副本(复制集)场景下，系统对用户保证的读写预期。如A进程对复制集系统写入一个值，A或其他进程能立即读到这个值吗？理想情况下，用户最容易理解的是最强的线性一致性，因为它实现了如同单节点一般的读写预期，但其需要付出额外的可用性和性能(包括响应时延)取舍，CAP理论就明确指出了线性一致性和高可用性两者的矛盾。除了线性一致性，还有其他更弱的一致性模型，如顺序一致性、会话一致性、因果一致性、最终一致性等。我在<a href="wudaijun.com/2018/09/consistency/">这里</a>重点介绍了线性一致性和顺序一致性。</p><p>除了强一致性(线性一致性和顺序一致性，也有种理解认为只有线性一致性是强一致性)之外的一致性都称为弱一致性，弱一致性模型可以是和用户的任何读写约定，而理论上最弱的一致性就是完全不保证数据一致(即不提供一致性保证)，这显然缺乏实际意义，因此实践中最弱的一致性模型通常为最终一致性，即系统在经过一段时间后最终会达成一致。最终一致性承诺就像“人终有一死”一样，对用户来说仍然缺乏实际的指导意义，用户还需要关心:</p><ul><li>这个“最终”是指多久？或者有多大概率在多久内可以达成一致？(类似响应延迟SLA)</li><li>如何达成一致？是最后写入者成功？还是有其他解决冲突的方案？</li><li>其他保证: 如用户可以读到刚写入的值吗(读你写)？连续读某个键值，后读出的会比先读出的数据更旧吗(单调读)？等</li></ul><p>以DNS为例，我们都知道DNS是最终一致性系统，但知道DNS的最大同步时间(48h)、DNS如何达成一致(最后写入者成功)、以及DNS的单调读一致性等信息，才能让我们更好地使用DNS系统。对系统开发者而言，也需要根据业务场景为用户提供适合的一致性保证。</p><h4 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h4><p>和复制集、读写一致性一起出现的，通常还有共识(Consensus)一词，它是指多个节点如何就同一个提案(如某个键的值、谁是主节点、事件发生顺序等)达成一致。共识算法可以作为复制集多节点数据同步和主从切换的技术方案。共识关注的是复制集内部达成一致的过程，而读写一致性关注复制集对用户提供的读写预期。共识算法有一些基本属性:</p><ul><li>可终止性(Termination): 所有正确的进程最终都会认同某个提案，即保证能正常给出结果，也被称作活性(Liveness)，对应于CAP中的可用性</li><li>约同性(Agreement): 所有正确的进程最终认同的提案是同一个提案，即保证给出的结果是一致的，也被称作安全性(Safety)，对应于CAP中的一致性</li><li>合法性(Validity): 最终认同的提案，必然是某个节点提出的提案</li></ul><p>活性(Liveness)和安全性(Safety)是最常被提及的两个共识算法属性，因为它们在分布式的各种挑战下，往往不得不妥协。</p><p>以下介绍数据复制和共识算法的经典解决思路</p><h4 id="中心化方案"><a href="#中心化方案" class="headerlink" title="中心化方案"></a>中心化方案</h4><p>主从方案是复制算法最经典也是最容易理解的中心化方案，整个复制集由一个主节点(称作Primary或Leader)N个从节点(称作Backup或Follower)组成，由主节点对外提供写服务，并把操作同步给从节点，从而完成复制的目的。主从方案有一些权衡点:</p><ul><li>从节点是否可读: 支持从节点可读的性能更好，但读写一致性可能降低</li><li>主节点是否同步等待从节点确认: 同步等待确认的数据一致性更高，且主从切换时不容易发生数据丢失，但性能、响应延迟和可用性会降低</li><li>数据同步机制: 全量(同步数据快照)和增量(同步操作日志)各有优劣(前者下限高，后者上限高)，需要相互结合</li><li>容错性: 主节点失效时的主从切换(非常容易产生数据丢失或不一致)、从节点失效时的数据追赶(全量同步派上用场)、以及如何解决网络分区导致的脑裂问题(大部分算法不会考虑)</li></ul><p>主从方案的优势是实现相对简单，由于主节点通常需要和所有的从节点交互，因此只适用于小规模集群。</p><h4 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h4><p>去中心化是指所有节点地位平等，均可以处理用户请求，最终通过协商合并来达成最终数据一致。</p><p>去中心化的优势在于节点可以任意数量扩展，劣势在于性能和一致性较差。由于去中心化的特性，它通常被用在公网上，因此通常是容忍网络分区和拜占庭容错的。这里以比特币的共识算法PoW为例来了解去中心化的一些难点:</p><ul><li>如何容忍网络分区: 比特币为了可用性而牺牲强一致性(AP系统)，因此它将重心放到如何解决数据合并和冲突上</li><li>如何容忍占庭将军问题: 通过工作量证明来提升提案成本，通过最长链来解决数据冲突，使得作恶所需要的算力要高于总集群算力的50%。但代价是长周期的最终确认(解决分叉)的时间，以及大量的算力浪费</li></ul><h4 id="N段提交"><a href="#N段提交" class="headerlink" title="N段提交"></a>N段提交</h4><p>前面提到的主从数据同步，通常主节点和从节点单次数据同步只需要单次交互(1PC, 1-Phase Commit)，这可能会导致部分从节点提交成功而另一部分提交失败，引发读写一致性问题。两段提交(2PC, 2-Phase Commit)可以改进这个问题:</p><ol><li>协调节点先向参与节点咨询操作是否可执行，参与节点做对应的提前准备，当参与者回复OK时，意味着<strong>承诺操作在该节点一定能成功Commit</strong></li><li>协调节点如果发现有参与者回复失败，则向其他节点发送Rollback通知，否则如果所有参与节点都回复OK，则通知所有参与节点Commit，当协调节点发起Commit时，意味着<strong>承诺该事务一定能完成</strong></li><li>如果Commit/Rollback阶段参与节点宕机或者发生网络分区，协调节点负责重试，直到所有参与节点回复Commit成功</li><li>如果协调节点故障，协调节点通过持久化来容忍自身宕机，并在恢复后读取上一次的决策进度(崩溃-恢复-备忘模型)</li></ol><p>2PC相比1PC，通过第一阶段的Check+Prepare流程减少了第二阶段Commit结果不一致的可能性，也就增强了数据一致性，相应的也增加了响应延迟。2PC主要有如下缺点:</p><ol><li>协调者可能出现单点故障，可能导致参与节点处于阻塞或者临界状态 </li><li>执行过程中，参与节点的相关资源处于独占状态，系统吞吐量会降低 (如果超时释放或提交，就可能产生不一致)</li><li>最后一轮Commit，可能只通知到部分节点，导致数据不一致 (CA系统)</li></ol><p>当然，2PC还有很多细节，如要不要重试，协调者崩溃后，参与者是一直等协调者恢复(通常此时还持有锁或处于阻塞状态)，还是Abort或Commit等等。</p><p>基于2PC的部分缺点，3PC进行了一些改进，它将Check和Prepare分开，并在参与方引入超时机制，但由于更加复杂且响应时延较高，因此实践中仍以2PC为主。可以看到，1PC-&gt;2PC-&gt;3PC，消息交互的轮次越多，不一致或处于临界状态的时间窗口就越小，但响应延迟也会更高。</p><h4 id="多数表决机制"><a href="#多数表决机制" class="headerlink" title="多数表决机制"></a>多数表决机制</h4><p>前面讨论的主从，2PC等方案，都没有考虑网络分区问题。针对网络分区问题最经典的解决方案就是多数表决机制，它能容忍小于半数的节点发生网络分区，并在多数节点一侧继续对外提供一致性保证和服务。多数表决和中心化一样，都适用于较小、可信任的集群，因此它们通常被搭配使用，如经典的Raft/Paxos算法，以Raft为例，在执行写入操作时，和2PC类似，Leader节点会和Follower进行两段提交确认，在获得大于一半的节点同意后，才会执行写入。在Leader宕机或者Leader发生分区后，多数节点侧会通过随机错峰+多数表决的机制选出新的Leader，并通过Leader任期+提案号等机制来解决分区恢复后脑裂恢复。</p><h4 id="读写Quorum"><a href="#读写Quorum" class="headerlink" title="读写Quorum"></a>读写Quorum</h4><p>在中心化方案中，我们假设只有主(Primary/Leader)节点对外提供读写服务，这种方案实现比较简单，也具备较好的一致性，但是不利于性能扩展，因此部分复制系统(如MongoDB，DymanoDB)也为客户端提供读写策略选项，即WRN模型</p><ul><li>N为集群总节点数量</li><li>W代表写入操作需要征得多少节点成功响应</li><li>R代表读操作需要向多少个节点查询</li></ul><p>WRN常见的几种关系</p><ul><li>W+R&gt;N时: 系统能检测到读写冲突(读写必有交集)，是系统可以提供强数据一致性的基础(还有其他因素，如N是否稳定、分区是否脑裂等)，在此基础上，系统/用户可以在写入性能(W更小)和读取性能(R更小)中进行取舍</li><li>W&lt;(N+1)/2时: 系统将出现写分裂(如何检测和解决数据冲突是这类策略的考虑重点)</li><li>让R+W&lt;=N时: 将出现读写不一致(即弱一致性模型，典型如异步主从复制+从节点可读模型)</li></ul><p>读写策略是经典的一致性、可用性、性能的权衡策略，通过部分表决而非多数表决，给设计和使用上更高的灵活性。如MongoDB可以在每次读写操作时，指定WR表决数量。</p><h4 id="如何解决写入冲突"><a href="#如何解决写入冲突" class="headerlink" title="如何解决写入冲突"></a>如何解决写入冲突</h4><p>在容忍网络分区的复制模型中，如何检测和解决数据冲突，使数据最终收敛，也是个比较重要的的领域，尤其对于可用性大于一致性的分布式系统而言。经典的方案是在请求和响应中加入更多的元数据，如: 时间戳、矢量时钟、版本号等。更进一步的方案是无序编程(前面提过，对时间和顺序的依赖越低，越能发挥分布式的优势)，无序编程中的相关理论有CRDTs(Convergent Replicated Data Types，无冲突复制数据类型)以及CALM(Consistency As Logical Monotonicity，逻辑单调的一致性)定理等。MapReduce是典型地声明式的、无序的算法模型。</p><h4 id="拜占庭容错"><a href="#拜占庭容错" class="headerlink" title="拜占庭容错"></a>拜占庭容错</h4><p>前面的几种机制都没有考虑拜占庭容错，解决这个分布式系统最难容错模型的主流算法分两类：</p><p>一类仍然基于中心化+多数表决原理，如PBFT算法，而PBFT算法能容忍小于1/3的节点作恶，它通过三阶段提交(与3PC原理和目的有所不同)来达成共识，PBFT适用于内部的(不能防止女巫攻击)、小规模的(需要节点频繁通信)集群。</p><p>另一类基于去中心化+多数表决原理，如区块链的PoW(工作量证明)算法，不过PoW的”大多数”，不是基于节点数量，而是基于算力，即最长的链。PoW算法优点是开放(自动准入)、安全(拜占庭容错+防女巫攻击)，适用于公网。缺点是有算力浪费、达成共识的时间较长。</p><p>PS: 女巫攻击，指个人试图创建多个账号、节点或IP，来试图成为整个集群的大多数，达成恶意攻击的目的。女巫攻击是拜占庭容错模型的一种升级，通常只有在自由准入的公网集群才考虑。</p><h4 id="其他实现因素"><a href="#其他实现因素" class="headerlink" title="其他实现因素"></a>其他实现因素</h4><p>前面重点关注的是共识算法的一些实现思路(除了读写Quorum)，而非对外表现的读写一致性。读写一致性除了受底层共识算法的限制外，还要考虑应用层的实现。如Raft，它通过主从+2PC+多数表决+选举机制等算法实现了一套理论上可以实现线性一致性语义的共识算法和协议，这套协议在应用层的实现，如Follower节点是否可读、分区之后老的Leader节点是否可读、写入时应用层是否同步执行Raft 2PC+多数表决流程等等，都会影响读写一致性。又如前面讨论的主从同步(它也是一种简单的共识算法)，从节点是否可读、同步还是异步、是否做了主从切换、是否会有分区脑裂问题等，也都取决于应用层(或者用户配置)。</p><p>这里简单列举下可能影响到读写一致性的一些实现因素:</p><ul><li>会话粘性: 即是否将用户的请求绑定到一台服务器上，会话粘性使得会话一致性这类弱一致性比较容易实现，缺点是负载均衡能力和容错性降低，可以一定程度通过会话复制或会话共享来优化</li><li>同步vs异步: 这个前面已经多次提到过，同步的读写一致性更高，异步的吞吐量、可用性以及响应延迟更优</li><li>读写策略: 包括从节点是否可读、以及前面提到的WRN模型等，这些读写策略通常是用户可配置的</li><li>客户端缓存: 客户端(或会话)缓存技术，可以实现如单调读这类一致性</li></ul><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>分片是指将数据集分为若干更小的数据集，用于避免数据集增长带来存储瓶颈和性能瓶颈。主流理解中的数据分片，主要指Kafka Partition、MongoDB Sharding这种存储中间件提供的分片技术。而我理解的广义上的数据分片，还包含应用层的数据和业务拆分(分表、分节点)。由于分片通常涉及到具体的中间件技术和业务场景，不如复制一般通用和抽象，因此鲜有脱离业务和DBMS的模型讨论。</p><p>数据分割不直接提升可用性，分割+复制才能提升可用性。数据分割主要解决性能(存储)瓶颈，分片主要考虑事务一致性的问题。</p><h4 id="事务一致性"><a href="#事务一致性" class="headerlink" title="事务一致性"></a>事务一致性</h4><p>指多节点场景下，分布式系统对”不变约束”的保证，即ACID中的事务一致性，它保证系统中所有的数据都是符合期望的，且相互关联的数据之间不会产生矛盾，是系统内部的数据状态一致性。</p><p>这里再提一下ACID，传统的理解，将A(原子性)、C(一致性)、I(隔离性)、D(持久性)作为达成事务的四个手段和原则，但如今也另有一种理解，就是将AID(以及DBMS提供的约束、触发器等)作为”因”，应用层事务一致性”C”(不包含DBMS本身提供的约束触发器)作为”果”来理解。这种理解更符合如今分布式大场景下，事务一致性理念的普适性。我个人也比较倾向于这种理解。</p><p>以转账系统为例，转出方和转入方数据可能不在一个分片(节点)上，那么转账前后双方的余额总数应该相等，双方的余额都不会为负数这些就是这个转账事务的”不变约束”，也就是事务一致性。应用层的事务一致性当然主要依赖应用程序本身的正确性，但另一方面，在多线程和分布式等场景下，如何确保应用层事务满足一致性，也是有一些套路和模式的。</p><p>注意，部分复制集中提到的解决方案，如N段提交方案(2PC、3PC)，仍然适用于事务一致性，以下不再复述。</p><h4 id="刚性事务"><a href="#刚性事务" class="headerlink" title="刚性事务"></a>刚性事务</h4><p>满足ACID四个要素的事务，被称为刚性事务，如单个RDBMS中的事务，由于不涉及网络，它们也被称作本地事务。RDBMS中的刚性事务通过Commiting Loging、Shadow Paging等技术来实现原子性和持久性(主要考虑磁盘崩溃和安全回滚问题)，通过锁(读锁/写锁/范围锁)来实现并发事务的不同的隔离级别(从MYSQL读未提交到可串行化)。刚性事务的实现方案很多，也不仅限于RDBMS，不过不属于这里的讨论重点。</p><p>刚性事务的这套实现机制，不适用于分布式场景，但ACID中的原子性、隔离性、持久性仍然可以作为分布式系统，实现事务一致性的重要维度参考。</p><h4 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h4><p>由于ACID不适用于分布式事务，因此BASE理论被提出，它通过牺牲一定的一致性来换取可用性。BASE中的S即Soft State，可理解为柔性状态、软状态或柔性事务。遵循BASE原则的事务被称为柔性事务。</p><p>在分布式事务中，柔性事务是主流思想，柔性事务关注最终一致性。在了解柔性事务的常见方案前，需要再理解下事务模型相较复制模型的区别:</p><ol><li>事务的每个参与者(表/分片/节点)都是整个事务不可缺少的一部分，任何一个参与者失败(事务参与者失败的概率要比复制场景中简单的读写大得多)、故障、分区，都将导致整个事务失败。而复制本身就是冗余换取可用和性能，因此可以容忍部分故障，也可以通过多数表决和仲裁来达成一致。</li><li>复杂事务可能有执行顺序依赖，事务整体的交互复杂度，很大程度取决于事务复杂度。复制模型比较简单，每个节点要做的事情(达成的共识)是一致的。</li><li>事务参与者与参与者之间是平等关系，它们都对外提供服务，不存在主从之分，因此要考虑并发隔离性的问题，典型如超售问题。复制模型中，并发隔离性本质影响的是读写一致性强弱的问题(如读到旧值)，而通常不会造成复制集内部数据不一致(共识算法至少会确保最终一致)，因此复制集中隔离性带来的问题影响相对较小(只要给了用户正确的读写一致性预期)。</li></ol><h5 id="最大努力交付"><a href="#最大努力交付" class="headerlink" title="最大努力交付"></a>最大努力交付</h5><p>最大努力交付方案(Best-Effort Delivery)的核心思路是，通过可靠消息服务、幂等、重试等机制，最大程度地容忍网络分区和节点故障，推进事务达成最终一致性。</p><p>以可靠消息队列方案为例，它的主要参与者有: 事务发起方、事务参与方、消息中间件。整个事务执行流程如下:</p><ol><li>事务发起方执行本地事务</li><li>事务发起方将要发送到其他事务参与方的消息写入自己的数据库，状态为”进行中”</li><li>启动一个消息服务，定时查询消息表，将消息表中的消息发送到事件参与方</li><li>如果3中出现任何网络异常和节点故障，消息服务会不断重试，直接事务参与方执行成功并返回</li><li>所有事务参与者均返回成功后，消息服务更新消息表对应消息状态为已完成，整个事务执行完成</li></ol><p>注意:</p><ul><li>上面流程中的1，2步，是在同一个本地事务中完成的(使用同一个数据库)</li><li>可靠消息队列假设，只要事务发起方本地事务完成，后续就没有失败回滚的概念，事务参与方只能成功，不能失败。因此主要还是适用相对简单的事务，可以让容易出错的操作方(比如扣款服务)，作为事务的发起方，事实上，可靠消息队列最常见的场景，就是第三方支付回调</li><li>可靠消息队列依赖消息幂等，否则出现网络异常，无法安全重试</li></ul><p>可靠消息队列的一种变形是引入消息中间件，事务发起方的消息服务将消息发给消息中间件，消息中间件接收成功后，即标记本地消息表已完成，由消息中间件的QoS来保证持续重试并达成最终一致性(当然，消息中间件本身实现高可用，仍然主要基于前面提到的复制冗余技术)。部分消息中间件如RocketMQ还提供了事务支持，如此就是不再需要本地消息表和消息服务，而是事务发起方通过RocketMQ提供的事务API和本地事务API通过一种比2PC更复杂的带重试的机制来保证执行本地事务和写入MQ消息这两件事情的事务一致性。</p><p>最大努力交付是一种非常普遍的容错思想，可靠消息队列只是其中一种方案，它通过本地事务+最大努力交付达成事务的最终一致性。</p><p>最大努力交付没有考虑事务参与方失败的问题，常见的事务失败处理策略分两种: 回滚和补偿。两种策略的代表分别是TCC和SAGA。</p><h5 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h5><p>TCC(Try-Confirm-Cancel)的核心思路是悲观预留:</p><ol><li>Try: 事务发起方通知各事务参与方执行业务检查，预留资源(如库存预扣除)</li><li>Confirm: 如果Try阶段所有参与方都返回成功，则事务发起方通知各参与方接入Confirm阶段，即真正提交本地事务。如果此阶段有节点故障或网络异常，事务发起方会不断重试，即最大努力交付</li><li>Cancel: 如果Try阶段任何事务参与方返回失败或者响应超时，则通知(包含重试)所有的参与方进行Cancel阶段，取消之前预留的资源</li></ol><p>注意，事务参与方的Confirm和Cancel接口都需要满足幂等。TCC的主要优势:</p><ul><li>通过预留资源，在业务层支持了回滚</li><li>通过预留资源，让事务具备了隔离性，能够避免超售问题</li><li>通过最大努力交付，使得其有一定的网络分区容忍度</li><li>相比2PC，TCC更偏业务层，预扣除也可以实现得很轻量，有性能优势</li></ul><p>TCC的劣势:</p><ul><li>对业务的侵入性较强，部分已有接口可能并不支持预留操作(如第三方支付接口，不支持预扣除操作)</li><li>业务层的开发成本较高</li></ul><h5 id="SAGA"><a href="#SAGA" class="headerlink" title="SAGA"></a>SAGA</h5><p>针对TCC业务侵入式强的缺点，SAGA的乐观补偿思路可以解决这个问题，SAGA的核心思路:</p><ul><li>将一个大的分布式事务T，分为N个子事务T1,T2,…,Tn</li><li>为每个子事务Ti实现一个对应的补偿操作Ci，即对应有C1,C2,….Cn</li></ul><p>Ti、Ci满足如下条件:</p><ul><li>Ti、Ci都可视为原子行为并且满足幂等</li><li>Ti和Ci满足交换律，即执行先执行Ti再执行Ci或者反过来，执行结果都是一样的(即没有影响)</li><li>Ci必需能成功提交，即不考虑Ci执行失败的情形</li></ul><p>如果T1,T2,…,Tn均成功执行，则事务T成功执行，正常完成。否则如果Ti执行失败，需要根据Ti特性和业务场景考虑两种恢复措施:</p><ul><li>正向恢复(Forward Recovery): 不断重试直至Ti执行成功(最大努力交付)</li><li>反向恢复(Backward Recovery): 尝试执行Ti对应的补偿操作Ci(最大努力交付)，整个执行链变为T1,T2,…,Ti,Ci,…,C2,C1</li></ul><p>SAGA协调者本身也可能崩溃，因此它需要持久化事务进度，并在crash-recover后，恢复对事务的进度跟踪和推进。</p><p>SAGA的优势:</p><ul><li>在某些场景，补偿比预留机制通常更容易实现(如银行扣款)</li><li>更适合长时间事务(Long Lived Transaction)</li></ul><p>SAGA的劣势:</p><ul><li>事务隔离性较差，这也是SAGA的最大痛点</li><li>执行整个事务的耗时较长(串行执行)</li><li>业务层的开发成本仍然较高</li></ul><h2 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h2><p>分布式基本理论是互联网和云计算的基础，它于每个软件工程师而言，都有很多值得学习的地方:</p><ul><li>打破单机的性能、位置、耦合度的局限性</li><li>在不可靠的网络和硬件上打造高可用系统</li><li>知不能完美，但仍在性能、可用性、一致性、扩展性等指标中不断权衡，寻求更优解</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;起意是想梳理下分布式系统的一些基本概念和理论，做一张知识脉络图，后来发现内容太多，图片不适合，因此整理成了文字版本。不过整体框架结构仍然类似思维导图，用作知识联结与发散。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;h3 id=&quot;什么是分布式系统？&quot;&gt;&lt;a href=&quot;#什么是分布式系统？&quot; class=&quot;headerlink&quot; title=&quot;什么是分布式系统？&quot;&gt;&lt;/a&gt;什么是分布式系统？&lt;/h3&gt;&lt;p&gt;系统中有若干独立自治的计算实体，每个实体有自己的内存状态，实体之间通过传递消息相互通信。整个系统对用户提供一致、统一的服务。&lt;/p&gt;
&lt;h3 id=&quot;为什么要使用分布式系统？&quot;&gt;&lt;a href=&quot;#为什么要使用分布式系统？&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用分布式系统？&quot;&gt;&lt;/a&gt;为什么要使用分布式系统？&lt;/h3&gt;&lt;p&gt;使用分布式而不是单机的原因有很多，总的来说大概分为三类: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决业务问题: 如复杂度瓶颈、系统对接、成本考量等&lt;/li&gt;
&lt;li&gt;解决扩展性问题: 如计算瓶颈、存储瓶颈、延迟优化等&lt;/li&gt;
&lt;li&gt;解决可用性问题: 通过冗余提升可用性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;指标&quot;&gt;&lt;a href=&quot;#指标&quot; class=&quot;headerlink&quot; title=&quot;指标&quot;&gt;&lt;/a&gt;指标&lt;/h2&gt;&lt;p&gt;分布式系统关注哪些指标？或者说我们通过哪些指标来衡量一个分布式系统？&lt;/p&gt;
&lt;h3 id=&quot;可伸缩性&quot;&gt;&lt;a href=&quot;#可伸缩性&quot; class=&quot;headerlink&quot; title=&quot;可伸缩性&quot;&gt;&lt;/a&gt;可伸缩性&lt;/h3&gt;&lt;p&gt;定义: 系统通过添加资源来应对不断增长(或变更)的工作量的能力。&lt;/p&gt;
&lt;p&gt;伸缩的维度有很多，包括规模伸缩、地理伸缩、功能伸缩、异构伸缩等。&lt;/p&gt;
&lt;p&gt;理想情况下，期望系统处理能力随资源投入线性增长。而实际上，还要权衡通信成本和延迟、可用性、数据一致性等诸多方面。&lt;/p&gt;
&lt;h3 id=&quot;可用性&quot;&gt;&lt;a href=&quot;#可用性&quot; class=&quot;headerlink&quot; title=&quot;可用性&quot;&gt;&lt;/a&gt;可用性&lt;/h3&gt;&lt;p&gt;定义: 系统处于正常工作状态的时间比例。&lt;/p&gt;
&lt;p&gt;这里有两个个相关概念:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MTBF(Mean Time Between Failure)：平均无故障时间，MTBF越长表示可靠性越高&lt;/li&gt;
&lt;li&gt;MTTR(Mean Time To Repair):平均修复时间，MTTR越短表示易恢复性越好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可用性 = 正常运行时间/(正常运行时间+故障时间) = MTBF/(MTBF+MTTR)。&lt;/p&gt;</summary>
    
    
    
    <category term="distributed" scheme="http://wudaijun.com/categories/distributed/"/>
    
    
    <category term="distributed" scheme="http://wudaijun.com/tags/distributed/"/>
    
    <category term="system" scheme="http://wudaijun.com/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计之柔性设计</title>
    <link href="http://wudaijun.com/2022/10/ddd-suple-design/"/>
    <id>http://wudaijun.com/2022/10/ddd-suple-design/</id>
    <published>2022-10-14T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.616Z</updated>
    
    <content type="html"><![CDATA[<p>本文为《领域驱动设计-软件核心复杂性应对之道》中关于柔性设计和重构相关内容学习笔记，之前总结的<a href="https://wudaijun.com/2021/06/software-design-mindmap/">软件设计</a>更多偏向于技术实现层面，而柔性设计更强调领域模型，属于非结构化建模。前者教你修房子(设计之术)，后者教你设计建筑(设计之道)。虽曰”道可道，非常道”。但反复学习品味相关内容，结合之前的重构实践，相互印证，确实诸多共鸣，受益匪浅，逐整理之。</p><p><img src="assets/image/202210/柔性设计.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文为《领域驱动设计-软件核心复杂性应对之道》中关于柔性设计和重构相关内容学习笔记，之前总结的&lt;a href=&quot;https://wudaijun.com/2021/06/software-design-mindmap/&quot;&gt;软件设计&lt;/a&gt;更多偏向于技术实现层面，而柔性设计更</summary>
      
    
    
    
    <category term="design" scheme="http://wudaijun.com/categories/design/"/>
    
    
    <category term="domain driver design" scheme="http://wudaijun.com/tags/domain-driver-design/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Golang游戏服务器的热更</title>
    <link href="http://wudaijun.com/2022/08/golang-gameserver-hotfix/"/>
    <id>http://wudaijun.com/2022/08/golang-gameserver-hotfix/</id>
    <published>2022-08-19T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.616Z</updated>
    
    <content type="html"><![CDATA[<p>从Erlang过渡到Golang以来，一直陆续会有同学问: “Golang能不能做代码热更呢？”，”游戏服务器不能热更会不会经常停服？”之类的问题，我的一贯看法是，抛开成本和风险谈收益的意义是不大的，所以在回答以上问题之前，先聊聊主流的Golang热更方案，它们都是基于<a href="https://pkg.go.dev/plugin">Go Plugin</a>机制的，这里讨论其中的两种，这里我将其称为plugin package swap方案和plugin function patch方案。</p><h4 id="plugin-package-swap"><a href="#plugin-package-swap" class="headerlink" title="plugin package swap"></a>plugin package swap</h4><p>该方案的思路是，将业务package编译为plugin，动态加载和替换，再通过<code>plugin.Lookup</code>来动态查找和使用函数。这也是最主流的Go Plugin应用方案，不过该方案有以下缺点:</p><ol><li>受 Go Plugin 本身的限制，如第三方依赖需要一致、不能引用插件package、插件内数据类型共享、插件无法释放、调试相对困难、跨平台问题等</li><li>对业务代码侵入式较强，包括 plugin main package限制、Lookup调用方式、发布流程等</li></ol><p>Go Plugin从2016年发布以来一直不温不火，Go官方对Plugin的维护升级更谈不上上心(两者互为因果)，对于大部分开发者而言，面临Plugin的诸多限制，还是要花一些时间踩坑的。因此，有一套弱侵入性的热更方案，减少对已有框架代码的影响，减轻对开发者的理解负担(比如不要为热更单独写业务代码)，并且提供快速切换静态编译和热更版本的支持，在我看来对线上服务是比较重要的。有一些开源库能解决部分问题，如<a href="https://github.com/edwingeng/hotswap">hotswap</a>能解决 main package 限制(通过正则临时替换)、不同版本plugin数据类型问题、Plugin生命周期管理问题等，并且也提供了动态链接(走plugin Lookup)和静态链接(对外暴露相同的接口，不过底层不走plugin Lookup，而是package函数调用)两种集成方式，一定程度降低了热更的侵入性。</p><span id="more"></span><p>更进一步降低侵入式的方案是使用条件编译来区分静态编译版本和热更版本，对静态编译版本而言，它除了多个几个no-op hook外，不耦合任何热更相关的东西。将插件相关代码对框架的侵入式降到最低。每次发布主体或插件，基于同一套代码同时构建热更主体、热更插件以及静态编译版本，如此在需要时，可以很方面地切换或者对照。</p><p>另一种较为Geek的方案是不使用条件编译对静态编译和热更版本做编译期区分，而是做运行时区分。服务器每次都以静态编译启动(无需so插件)，但是开启插件热更机制，一旦自动检测或手动启动热加载，就用so插件的代码替换掉原本的package实现，从而实现热更。这种方案的优点是在服务器没有BUG无需热更的情况下，它的运行时表现和静态编译版本基本一致。缺点是代码层面对热更机制有一定的耦合。</p><p>另外，Go Plugin 的诸多限制也影响了该方案的应用范围，对游戏服务器而言，首要就是得有合理的package拆分，这方面可以借助DDD和洋葱架构对业务领域进行拆分和隔离，理想中的plugin package需要满足:</p><ol><li>无全局变量</li><li>不被其他package依赖</li><li>所有数据和接口依赖，都通过外部依赖注入</li><li>无后台goroutine</li><li>尽量不要暴露plugin内的数据类型</li><li>…</li></ol><p>满足如上条件的package其实更偏向提供类似纯函数的Handler实现，这较大程度限制了Plugin代码热修复的覆盖度和能力。</p><h4 id="plugin-function-patch"><a href="#plugin-function-patch" class="headerlink" title="plugin function patch"></a>plugin function patch</h4><p>另一种在其他项目应用过的方案也是基于Plugin，但不是将Plugin作为整个package的可替换实现，而是只通过Plugin实现要替换的函数补丁:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func GetPatchFuncs() map[string]string &#123;</span><br><span class="line">&#x2F;&#x2F;map的key是新函数在本补丁文件中的名称(以便通过plugin.Lookup找到该函数地址)</span><br><span class="line">&#x2F;&#x2F;map的value是旧函数在旧可执行文件中的名称(应该用nm来查，以便通过CGO dlsym找到该函数地址) </span><br><span class="line">list :&#x3D; map[string]string&#123;</span><br><span class="line">&quot;TestHandlerHotFix&quot;: &quot;main.TestHandler&quot;,</span><br><span class="line">&#125;</span><br><span class="line">return list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在加载Plugin后，借助<code>plugin.Lookup(&quot;GetPatchFuncs&quot;)</code>拿到Patch映射，再通过<code>plugin.Lookup</code>和<code>CGO dlsym</code>分别找到新旧函数地址，最后借助<code>mprotect</code>+<code>memcpy</code>+<code>hardcode asm</code>修改旧函数地址入口内容为: <code>jmpq 新函数地址</code>。</p><p>这套方案借鉴经典的C函数补丁热更方案，它的好处是，业务代码不需要大的调整，缺点也有不少:</p><ol><li>相较package swap，函数补丁灵活性没有那么高</li><li>需要为了热更，暴露package过多的类型和函数</li><li>Patch函数修复后，还需要在业务逻辑中再修复一次</li><li>由于是函数地址替换，因此还会受到编译器内联优化的影响</li><li>由于用了C和汇编，与底层耦合过重，跨平台和跨系统可移植性只能自己保证</li></ol><h4 id="代码热更的价值"><a href="#代码热更的价值" class="headerlink" title="代码热更的价值"></a>代码热更的价值</h4><p>在大概了解Go热更的两种实现方式和相对应的成本和风险之后，现在来聊聊代码热更的价值和收益。首要仍然要强调的是，代码热更如同设计模式中的适配器，本质都是一种补救措施。如果一个线上服务器频繁使用代码热更来修复BUG，这不能说明代码热更很有用，反倒是说明服务器的线上交付质量有问题，工作重心应该更多地考虑保障线上交付质量。同时，为热更付出的开发成本以及带来的风险性都要谨慎评估，否则就会有点舍本逐末了(提升可用性的措施，引入了新的风险或花了过高的成本反而降低了可用性)。这也是我前面提到非侵入性和共存方案的初衷之一。</p><p>现在回到最开始的两个问题:</p><ol><li>“Golang能否做代码热更?”: 能支持一定程度的代码热更，但目前已知的代码热更方案，都有一定的技术风险(坑)，限制也比较多，并且只能覆盖部分业务代码，可能还需要做前置代码重构</li><li>“没有热更会不会经常停服？”: 在我们近年的Golang服务器实践经验中，能否代码热更还不算是服务器的可用性瓶颈，服务器停服的原因包括版本更新、意外故障以及紧急修复等，代码热更只能解决紧急修复中的一部分BUG，这个”部分”取决于BUG复杂程度、是否需要停服止损、修复数据、是否被热更覆盖等</li></ol><p>综上，代码热更是否值得做，最终还是取决于对各项目对这一块的成本风险和收益的权衡，而每个项目在这一块上面临的技术挑战和风险是不一样的。对我们而言，由于之前借助一些DDD思想对业务领域进行了拆分和重组(基于可维护、可测试、可扩展性考量)，目前的业务package粒度和组织方式，都比较适合hotswap方案，因此目前我们开始尝试 hotswap + domain package + 条件编译 + 并存构建的热更方案，其前置业务重构成本、侵入性、风险性都很低，目前的想法是小范围逐步推进，比如先用在活动这类最常出问题的系统上。</p><h4 id="非代码热修复"><a href="#非代码热修复" class="headerlink" title="非代码热修复"></a>非代码热修复</h4><p>一个完整的有状态游戏服务器主要包含三部分: 代码、数据和配置，因此除了代码热更之外，这里顺便提一下配置热更和数据热修复。</p><p>配置问题是游戏服务器线上问题的主要来源之一，大部分的游戏服务器都会提供一定的配置热更能力，这个实现起来不难，由于我们使用全容器部署，为了做到宿主机隔离，配置热更是通过将配置导入到DB然后Reload来实现的，并借助<code>atomic.Value</code>保证配置的并发读写安全性。对于逻辑层而言，尽可能不要缓存配置，而是每次都从配置中读取最新值。</p><p>至于数据热修复，SLG游戏服务器基于性能、响应延迟、逻辑耦合强等各种原因，通常都是有状态+定时落地的，尽管我们尽可能从防御性编程、架构可靠性、线上监控、快速部署恢复等手段来尽可能提升服务器可用性，但各种预期之外的错误和故障仍然可能导致处理流程中断，引发各种数据不一致性问题。而按照经验，处理这些故障导致的数据修复，往往比服务恢复更可能成为”可用性瓶颈”。因此，为了最大程度提升玩家体验，一种或多种不停服修复数据方案是需要被考虑并长期维护的。按照我们的经验，大概可以从以下几个维度来考虑:</p><ul><li>Normal Fix: 对于常见的数据不一致，做一套Fix流程，并且手动(如通过GM)或者自动(如服务器启动、玩家上线时)开启</li><li>Lua Fix: 接入Lua(如<a href="https://github.com/yuin/gopher-lua">gopher-lua</a>)并暴露核心的数据API以便通过Lua做一些临时的数据诊断和修复</li><li>Reflect Fix: 基于Go Reflect实现一套简单的DSL，支持结构体嵌套字段的读取和赋值</li><li>DB Fix: 强制带LRU的数据刷盘，修改DB，最后Reload</li></ul><p>由于这一块和业务框架耦合较重，不再展开，仅仅提供一些思路。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从Erlang过渡到Golang以来，一直陆续会有同学问: “Golang能不能做代码热更呢？”，”游戏服务器不能热更会不会经常停服？”之类的问题，我的一贯看法是，抛开成本和风险谈收益的意义是不大的，所以在回答以上问题之前，先聊聊主流的Golang热更方案，它们都是基于&lt;a href=&quot;https://pkg.go.dev/plugin&quot;&gt;Go Plugin&lt;/a&gt;机制的，这里讨论其中的两种，这里我将其称为plugin package swap方案和plugin function patch方案。&lt;/p&gt;
&lt;h4 id=&quot;plugin-package-swap&quot;&gt;&lt;a href=&quot;#plugin-package-swap&quot; class=&quot;headerlink&quot; title=&quot;plugin package swap&quot;&gt;&lt;/a&gt;plugin package swap&lt;/h4&gt;&lt;p&gt;该方案的思路是，将业务package编译为plugin，动态加载和替换，再通过&lt;code&gt;plugin.Lookup&lt;/code&gt;来动态查找和使用函数。这也是最主流的Go Plugin应用方案，不过该方案有以下缺点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;受 Go Plugin 本身的限制，如第三方依赖需要一致、不能引用插件package、插件内数据类型共享、插件无法释放、调试相对困难、跨平台问题等&lt;/li&gt;
&lt;li&gt;对业务代码侵入式较强，包括 plugin main package限制、Lookup调用方式、发布流程等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Go Plugin从2016年发布以来一直不温不火，Go官方对Plugin的维护升级更谈不上上心(两者互为因果)，对于大部分开发者而言，面临Plugin的诸多限制，还是要花一些时间踩坑的。因此，有一套弱侵入性的热更方案，减少对已有框架代码的影响，减轻对开发者的理解负担(比如不要为热更单独写业务代码)，并且提供快速切换静态编译和热更版本的支持，在我看来对线上服务是比较重要的。有一些开源库能解决部分问题，如&lt;a href=&quot;https://github.com/edwingeng/hotswap&quot;&gt;hotswap&lt;/a&gt;能解决 main package 限制(通过正则临时替换)、不同版本plugin数据类型问题、Plugin生命周期管理问题等，并且也提供了动态链接(走plugin Lookup)和静态链接(对外暴露相同的接口，不过底层不走plugin Lookup，而是package函数调用)两种集成方式，一定程度降低了热更的侵入性。&lt;/p&gt;</summary>
    
    
    
    <category term="gameserver" scheme="http://wudaijun.com/categories/gameserver/"/>
    
    
    <category term="gameserver" scheme="http://wudaijun.com/tags/gameserver/"/>
    
    <category term="golang" scheme="http://wudaijun.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang性能分析</title>
    <link href="http://wudaijun.com/2022/04/golang-performance-analysis/"/>
    <id>http://wudaijun.com/2022/04/golang-performance-analysis/</id>
    <published>2022-04-02T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.616Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/image/202204/Golang性能分析.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/assets/image/202204/Golang性能分析.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="golang" scheme="http://wudaijun.com/categories/golang/"/>
    
    
    <category term="golang" scheme="http://wudaijun.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>SLG游戏服务器随想</title>
    <link href="http://wudaijun.com/2022/03/slg-server-mindmap/"/>
    <id>http://wudaijun.com/2022/03/slg-server-mindmap/</id>
    <published>2022-03-12T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.615Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/image/202203/slg-server.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/assets/image/202203/slg-server.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="gameserver" scheme="http://wudaijun.com/categories/gameserver/"/>
    
    
    <category term="gameserver" scheme="http://wudaijun.com/tags/gameserver/"/>
    
  </entry>
  
  <entry>
    <title>C#/Unity中的异步编程</title>
    <link href="http://wudaijun.com/2021/11/c-sharp-unity-async-programing/"/>
    <id>http://wudaijun.com/2021/11/c-sharp-unity-async-programing/</id>
    <published>2021-11-25T16:00:00.000Z</published>
    <updated>2023-07-26T10:41:50.740Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间学习Unity，顺便系统性地了解了下C#和Unity异步编程的各种机制和实现细节。本文是这些学习资料和个人理解的汇总。会先介绍下C# yield，Task，async/await，同步上下文等机制。然后聊聊其在Unity上的一些变体和应用。</p><span id="more"></span><h3 id="C-yield"><a href="#C-yield" class="headerlink" title="C# yield"></a>C# yield</h3><p><code>yield</code>是C#提供的快速创建枚举器的机制:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">TestYield</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IEnumerator&lt;<span class="built_in">int</span>&gt; enumerator = TestYield(<span class="number">4</span>).GetEnumerator();</span><br><span class="line">    <span class="keyword">while</span> (enumerator.MoveNext())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(enumerator.Current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>实现上来说，C#编译器会为TestYield函数生成一个状态机类，将函数执行体通过yield分为几个部分，内部通过一个state字段(通常是个整数)来标识当前迭代到哪一步了，并实现了IEnumerable、IEnumerator枚举器接口。因此可以将TestYield返回值作为一个可枚举对象。介绍关于yield语法糖实现机制的文章很多，这里就不赘述了。</p><p>C# 枚举器和JS Generator机制上非常类似，不过只具备单向传值的能力(yield-&gt;MoveNext)。我在<a href="http://wudaijun.com/2018/07/javascript-async-programing/">JS异步编程</a>和<a href="https://wudaijun.com/2015/01/lua-coroutine/">Lua协程</a>中有介绍关于协程和生成器的区别，在我的理解中，C#枚举器和JS生成器一样，都不能算作协程。</p><h3 id="Unity-Coroutine"><a href="#Unity-Coroutine" class="headerlink" title="Unity Coroutine"></a>Unity Coroutine</h3><p>C#没有协程，而Unity C#中则经常看到协程的概念(Unity Coroutine)，本质上来说，Unity Coroutine是和JS Generator类似的通过生成器/枚举器实现异步的编程模型。Unity基于C# yield进行了进一步完善:</p><ol><li>Unity协程通过Unity Engine提供的<code>StartCoroutine(myEnumerableFunc)</code>启动，Unity Engine会驱动枚举器的迭代，无需开发者关心</li><li>Unity协程基于yield返回的对象，只能是YieldInstruction的子类(它最重要的方法是bool IsDone()，用于判断异步操作是否已经完成)，如此Unity Engine会在YieldInstruction完成后，通过MoveNext迭代枚举器</li><li>Unity Engine预实现了部分YieldInstruction，如WaitForSeconds，WaitForEndOfFrame等，以实现常用的协程控制</li><li>Unity Engine完善了协程(枚举器)生命周期管理(Start/Stop)和嵌套机制(如一个协程yield另一个协程)，并将协程的生命周期与GameObject绑定</li></ol><p>关于Unity Coroutine的更深入实现原理推荐<a href="https://sunweizhe.cn/2020/05/08/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Unity%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">这篇博客</a>。如此，对于Unity开发者而言，使用yield就能完成简单的异步控制。当然，还达不到JS Generator异步那样的灵活度(如C# yield不能像JS yield一样双向传值)。我们可以从<a href="http://wudaijun.com/2018/07/javascript-async-programing/">JS 异步编程</a>中提到的Generator异步编程的四要素，来对比看看Unity Coroutine是如何工作的:</p><ul><li>Generator: C#的yield相当于JS Generator的阉割版，支持执行权转移，单向传值</li><li>Thunk: Thunk的本质目的是让Iterator能以一种标准化的方式挂接回调(如此才能回到yield语句)，而Unity YieldInstruction本身就是一种标准，Unity会在YieldInstruction完成(IsDone()==true)后，调用对应协程的的MoveNext回到yield语句，这也就相当于完成了Thunk的职责</li><li>AsyncOp: Unity Engine和它的标准库提供了大量适配了YieldInstruction的异步操作，包括帧控制、定时、网络IO等，并且支持开发者扩展</li><li>Iterator: Unity Engine统一管理所有通过StartCoroutine启动的协程，并基于帧驱动检查它们的状态，在YieldInstruction异步操作完成后继续驱动协程(MoveNext)，直至协程生命周期结束。</li></ul><p>由于C# yield是单向传值，Unity协程自然也就不支持yield语句返回值。如此看来，Unity C#确实具备部分的异步编程能力，不过如前面所说，基于个人对狭义的协程概念的理解，我认为程JS、C#、Unity支持协程是不合适的。类似的还有Golang的抢占式轻量级线程goroutine也被翻译为协程。</p><h3 id="C-Task"><a href="#C-Task" class="headerlink" title="C# Task"></a>C# Task</h3><p>C#中的Task本质上类似JS中的Promise，表示一个异步任务，通常运行在其他线程而非创建Task的当前线程中。Task在启动(Task.Start/Task.Run/TaskFactory.StartNew)和ContinueWith的时候，可以选择指定其对应的TaskScheduler(对于ContinueWith而言，指定的是执行异步回调的任务调度器)，默认的TaskScheduler只会将任务放到线程池中去执行。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">888</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">111</span>;</span><br><span class="line">    <span class="keyword">var</span> task = <span class="keyword">new</span> Task&lt;<span class="built_in">int</span>&gt;(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;add task, on thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;main thread&#123;0&#125;, task&#123;1&#125; init status: &#123;2&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId, task.Id, task.Status);</span><br><span class="line">    task.Start();</span><br><span class="line">    task.ContinueWith((task, arg) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;continue with 1, got result: &#123;0&#125;, got arg: &#123;1&#125;, on thread&#123;2&#125;&quot;</span>, task.Result, arg, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    &#125;, <span class="string">&quot;Arg1&quot;</span>).</span><br><span class="line">    ContinueWith((task) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;continue with 2, on thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    &#125;).Wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// main thread1, task1 init status: Created</span></span><br><span class="line"><span class="comment">// add task, on thread3</span></span><br><span class="line"><span class="comment">// continue with 1, got result: 999, got arg: Arg1, on thread4</span></span><br><span class="line"><span class="comment">// continue with 2, on thread5</span></span><br></pre></td></tr></table></figure><p>以上代码展示了Task的几个特性:</p><ol><li>任务内部有个简单的状态机，其他线程可通过<code>Task.Status</code>获取任务当前状态</li><li><code>Task.ContinueWith</code>返回值是一个新的Task，可以像<code>JS promise.then</code>一样，以可读性较好的方式(相比回调地狱)书写异步调用链</li><li><code>task.ContinueWith</code>中的回调可以取到到task的返回值，并且可以为其附加额外的参数</li><li><code>task.Wait</code>可以让当前线程同步阻塞等待该任务完成，除此之外，还可以通过<code>Task.WaitAny</code>和<code>Task.WaitAll</code>来等待一个任务数组</li><li>在任务执行完成后，通过<code>task.Result</code>可以取得异步任务的返回值，注意，如果此时任务未完成，将会同步阻塞等待任务完成</li><li>如果没有指定TaskScheduler，默认的任务调度器只是在线程池中随机选一个线程来执行异步任务和对应回调</li></ol><p>有时候我们在线程A中将某些耗时操作，如网络IO，磁盘IO等封装为Task放到线程B异步执行之后，希望Task的回调在A线程执行(最典型的如UI线程，因为通常UI框架的API都不是线程安全的)，以实现A-&gt;B-&gt;A的线程上下文切换效果。要实现这种效果，我们需要为Task显式指定TaskScheduler，TaskScheduler本质只是接口，它的派生类主要有两个:</p><ul><li>thread pool task scheduler: 基于线程池的任务调度器，即任务(及其continuewith产生的新任务)会被分配到线程池中的某个工作线程，这也是默认的调度器，通过<code>TaskScheduler.Default</code>获取默认线程池调度器</li><li>synchronization context task scheduler: 同步上下文调度器，即任务会在指定的同步上下文上执行，比如在GUI框架中，通常会将控件操作全部放到GUI线程中执行。通过<code>TaskScheduler.FromCurrentSynchronizationContext</code>获取与当前同步上下文绑定的任务调度器</li></ul><p>那么什么是同步上下文？SynchronizationContext代表代码的执行环境，提供在各种同步模型中传播同步上下文的功能，为各个框架的线程交互提供统一的抽象。它最重要的是以下两个方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取当前线程的同步上下文</span><br><span class="line">public static System.Threading.SynchronizationContext? Current &#123; get; &#125;</span><br><span class="line">// 派发一个异步到消息到当前同步上下文</span><br><span class="line">public virtual void Post (System.Threading.SendOrPostCallback d, object? state);</span><br><span class="line">// 派发一个同步消息到当前同步上下文</span><br><span class="line">public virtual void Send (System.Threading.SendOrPostCallback d, object? state);</span><br></pre></td></tr></table></figure><p>SynchronizationContext提供了默认的实现，对Post而言，它只会通过QueueUserWorkItem将任务丢给ThreadPool，对于Send而言，它会立即在当前线程上同步执行委托。</p><p>各个框架可以重载SynchronizationContext实现自己的同步上下文行为，如Windows Froms实现了<code>WindowsFormsSynchronizationContext</code>，它的Post会通过<code>Control.BeginInvoke</code>实现，而WPF的<code>DispatcherSynchronizationContext</code>则通过框架的<code>Dispatcher.BeginInvoke</code>实现，它们都实现了将委托异步投递给UI线程执行。正因为不同的平台，不同的线程，有不同的消息泵和交互方式，因此才需要SynchronizationContext来封装抽象这些差异性，以增强代码的可移植性。</p><p>每个线程都有自己的SynchronizationContext(通过<code>SynchronizationContext.Current</code>获取，默认为null)，但SynchronizationContext与线程不一定是一一对应的，比如默认的<code>SynchronizationContext.Post</code>是通过线程池来执行任务。SynchronizationContext本质上想要封装的是一个执行环境以及与该环境进行任务交互的方式。</p><p>对Task，TaskScheduler，SynchronizationContext有一定了解后，我们将这些概念结合起来:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建并设置当前线程的SynchronizationContext</span></span><br><span class="line">    <span class="comment">// 否则TaskScheduler.FromCurrentSynchronizationContext()调用会触发System.InvalidOperationException异常</span></span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">new</span> SynchronizationContext();</span><br><span class="line">    SynchronizationContext.SetSynchronizationContext(context);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;main thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Task&lt;<span class="built_in">int</span>&gt; task = <span class="keyword">new</span> Task&lt;<span class="built_in">int</span>&gt;(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;task thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    task.Start();</span><br><span class="line">    task.ContinueWith(t =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;continuewith result: &#123;0&#125;, thread&#123;1&#125;&quot;</span>, t.Result, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">    &#125;, TaskScheduler.FromCurrentSynchronizationContext()).Wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// main thread1</span></span><br><span class="line"><span class="comment">// task thread3</span></span><br><span class="line"><span class="comment">// continuewith result: 1, thread4</span></span><br></pre></td></tr></table></figure><p>上面代码中，使用<code>TaskScheduler.FromCurrentSynchronizationContext()</code>来指定<code>task.ContinueWith</code>任务的调度器(注意，我们并没有为<code>task.Start</code>指定调度器，因为我们希望task本身使用默认的线程池调度器，当执行完成之后，再回到主线程执行ContinueWith任务)，输出结果并不如我们预期，<code>task.ContinueWith</code>中的回调委托仍然在线程池中执行，而不是在主线程。</p><p>这个结果其实很容易解释，<code>task.ContinueWith(delegate, TaskScheduler.FromCurrentSynchronizationContext())</code>表示: 当task执行完成后，通过<code>SynchronizationContext.Post(delegate, task)</code>将任务异步投递到指定的同步上下文(在上例中，即为主线程创建的上下文)。但是一来我们创建的是默认的SynchronizationContext，它的Post本身就是投递到线程池的，二来我们并没有在主线程中集成消息泵(message pump)。</p><p>类比Actor模型，我们要实现 Actor A 向 Actor B 通信，我们需要: </p><ol><li>定义一个消息通道: channel/mailbox</li><li>集成channel/mailbox到B消息泵</li><li>将channel/mailbox暴露给A</li></ol><p>因此，上例中，我们即没有定义消息的传输方式，也没有定义消息的处理方式。SynchronizationContext本质只是提供了一层同步上下文切换交互抽象，传输方式，消息泵，甚至线程模型都需要我们自己实现。这里就不再展示SynchronizationContext的扩展细节，更多关于SynchronizationContext的文档:</p><ol><li><a href="https://hamidmosalla.com/2018/06/24/what-is-synchronizationcontext/">what is synchronizationcontext</a></li><li><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2011/february/msdn-magazine-parallel-computing-it-s-all-about-the-synchronizationcontext">synchronizationcontext doc on MSDN</a></li></ol><h3 id="C-async-await"><a href="#C-async-await" class="headerlink" title="C# async/await"></a>C# async/await</h3><p>async/await是C# .NET4.5推出的更高级的异步编程模型:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static async void AsyncTask()</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;before await, thread&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    var a = await Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(500);</span><br><span class="line">        Console.WriteLine(&quot;in task, thread&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId); </span><br><span class="line">        return 666;</span><br><span class="line">    &#125;);</span><br><span class="line">    Console.WriteLine(&quot;after await, got result: &#123;0&#125;, thread&#123;1&#125;&quot;, a, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;Main: before AsyncTask thread&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    var r = AsyncTask().Result;</span><br><span class="line">    Console.WriteLine(&quot;Main: after AsyncTask result: &#123;0&#125; thread&#123;1&#125;&quot;, r, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line">// Output:</span><br><span class="line">AsyncTask: before await, thread1</span><br><span class="line">AsyncTask: in task, thread3</span><br><span class="line">AsyncTask: after await, got result: 666, thread3</span><br><span class="line">Main: after AsyncTask result: 667 thread1</span><br></pre></td></tr></table></figure><p>可以看到async/await进一步简化了异步编程的书写方式，达到更接近同步编程的可读性和易用性(这一点后面会再探讨下)。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>在进一步了解它的用法之前，我们先大概了解下它的实现机制(可以看看<a href="https://zhuanlan.zhihu.com/p/197335532">这篇文章</a>提到了不少实现细节)，async/await本质也是编译器的语法糖，编译器做了以下事情:</p><ol><li>为所有带async关键字的函数，生成一个状态机类，它满足IAsyncStateMachine接口，await关键字本质生成了状态机类中的一个状态，状态机会根据内部的state字段(通常-1表示开始，-2表示结束，其他状态依次为0,1,2…)，一步步执行异步委托。整个状态机由<code>IAsyncStateMachine.MoveNext</code>方法驱动，类似迭代器</li><li>代码中的<code>await xxx</code>，xxx返回的对象都需要实现GetAwaiter方法，该方法返回一个Awaiter对象，编译器不关心这个对象Awaiter对象类型，它只关心这个Awaiter对象需要满足三个条件: a. 实现INotifyCompletion(只有一个<code>OnCompleted(Action continuation)</code>方法，用以异步框架挂载回调)，b. 实现IsCompleted属性，c. 实现GetResult方法，如此编译器就能知道如何与该异步操作进行交互，比如最常见的Task对象，就实现了GetAwaiter方法返回一个<a href="https://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs,2935">TaskAwaiter</a>对象，但除了TaskAwaiter，任何满足以上三个条件的对象均可被await</li><li>有了stateMachine和TaskAwaiter之后，还需要一个工具类将它们组合起来，以驱动状态机的推进，这个类就是<code>AsyncTaskMethodBuilder/AsyncTaskMethodBuilder&lt;TResult&gt;</code>，是Runtime预定义好的，每个async方法，都会创建一个Builder对象，然后通过<a href="https://referencesource.microsoft.com/#mscorlib/system/runtime/compilerservices/AsyncMethodBuilder.cs,67">AsyncTaskMethodBuilder.Start</a>方法绑定对应的IAsyncStateMachine，并进行状态首次MoveNext驱动，MoveNext执行到await处(此时实际上await已经被编译器去掉了，只有TaskAwaiter)，会调用<code>TaskAwaiter.IsCompleted</code>判断任务是否已经立即完成(如<code>Task.FromResult(2)</code>)，如果已完成，则将结果设置到builder(此时仍然在当前线程上下文)，并之后跳转到之后的代码(直接goto，无需MoveNext)，否则，更新state状态，通过<a href="https://referencesource.microsoft.com/#mscorlib/system/runtime/compilerservices/AsyncMethodBuilder.cs,154">AsyncTaskMethodBuilder.AwaitUnsafeOnCompleted</a>(最终调到<code>Awaiter.OnCompleted</code>)挂接(对<code>TaskAwaiter.OnCompleted</code>而言，是<a href="https://referencesource.microsoft.com/#mscorlib/system/runtime/compilerservices/TaskAwaiter.cs,339">挂接到Continuation</a>上)异步回调(此回调包含整个状态机的后续驱动方式，通过<a href="https://referencesource.microsoft.com/#mscorlib/system/runtime/compilerservices/AsyncMethodBuilder.cs,ac92075576570beb">GetCompletionAction</a>生成)并返回(此时当前函数堆栈已结束)，当taskAwaiter完成(不同的Awaiter完成方式也不同，对Task而言，即Task执行完成)后，buildier会通过GetCompletionAction生成的回调再次调用到<code>stateMachine.MoveNext</code>驱动状态机(此时可能已经不在当前线程，state状态也不一样了，可通过TaskAwaiter.GetResult拿到异步结果)，如此完成状态机的正常驱动。整个stateMachine只需要MoveNext一次，即可完全跑起来。</li><li>除了驱动状态机外，AsyncTaskMethodBuilder的另一个作用是将整个async函数，封装为一个新的Task(wrapper task)，该Task可通过<code>AsyncTaskMethodBuilder.Task</code>属性获取。当stateMachine通过MoveNext走完每个状态后，会将最终结果，通过builder.SetResult写入到builder中的Task，如果中途出现异常，则通过builder.SetExpection保存，如此发起方可通过<code>try &#123;await xxx;&#125; catch (e Exception)&#123;...&#125;</code>捕获异常，最终整个编译器改写后的async函数，返回的实际上就是这个<code>builder.Task</code>。</li></ol><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><p>除了直接跟Task外，<code>.NET</code>和Windows运行时也封装了部分关于网络IO，文件，图像等，这些方法通常都以Async结尾，可直接用于await。以下代码说明了跟在await后面的常见的几种函数，以便进一步理解其中的差异和原理。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为没有async标注，所以编译器不会为该函数生成状态机，但由于该函数返回的是Task，因此可以直接用于await</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">F1Async</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Task.Run(() =&gt; &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要标记了async 就会生成对应状态机，但这里有几点需要注意:</span></span><br><span class="line"><span class="comment">// 1. 如果方法声明为 async，那么可以直接 return 异步操作返回的具体值，不再用创建Task，由编译器通过builder创建Task</span></span><br><span class="line"><span class="comment">// 2. 由于该函数体内没有使用await，整个状态机相当于直接builder.SetResult(2)，其中不涉及异步操作和线程切换(没有await异步切换点)，因此整个过程实际上都是在主线程同步进行的(虽然经过了一层builder.Task封装)</span></span><br><span class="line"><span class="comment">// 3. 编译器也会提示Warning CS1998: This async method lacks &#x27;await&#x27; operators and will run synchronously.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">F2Async</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法在Task上套了一层空格子Task，看起来好像和F1Async没区别</span></span><br><span class="line"><span class="comment">// 但实际上，编译器仍然会生成对应的builder和wrapper task，这个wrapper task在原task完成之后，只是做了简单的return操作</span></span><br><span class="line"><span class="comment">// 因此 await F3Async() 实际上可能导致两次线程上下文切换，如果是在UI线程上执行await，用法不当则可能触发&quot;async/await 经典UI线程卡死&quot;场景，因为await会默认捕获SynchronizationContext。这个后面说。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">F3Async</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> Task.Run(() =&gt; &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h4><p>理解async/await基本原理后，不难发现，async/await本质上是不创建线程的，它只是一套状态机封装，以及通过回调驱动状态机的异步编程模型。await默认会捕获当前的执行上下文ExecuteContext，但是并不会捕获当前的同步上下文SynchronizationContext(关于ExcuteContext和SynchronizationContext的区别联系参考<a href="https://devblogs.microsoft.com/pfxteam/executioncontext-vs-synchronizationcontext/">executioncontext-vs-synchronizationcontext on MSDN</a>，强烈建议阅读)，同步上下文的捕获是由TaskAwaiter实现(见<a href="https://referencesource.microsoft.com/#mscorlib/system/runtime/compilerservices/TaskAwaiter.cs,93">TaskAwaiter.OnCompleted</a>)，它会先获取<code>SynchronizationContext.Current</code>，如果没有或者是默认的，会再尝试获取Task对应的TaskScheduler上的SynchronizationContext。也就是说对TaskAwaiter而言，设置默认的SynchronizationContext和没有设置效果是一样的(为了少一次QueueWorkItem，对应源码在<a href="https://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs,2976">这里</a>，我们可以结合前面的AsyncTask，以及下面的进一步测试来验证:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title">MySynchronizationContext</span> : <span class="title">SynchronizationContext</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">SendOrPostCallback d, <span class="built_in">object</span> state</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MySynchronizationContext Post, thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">base</span>.Post(d, state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">AsyncTask</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 创建并使用自定义的SynchronizationContext</span></span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">new</span> MySynchronizationContext();</span><br><span class="line">    SynchronizationContext.SetSynchronizationContext(context);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;AsyncTask: before await, thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">await</span> Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;AsyncTask: in task, thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">666</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;AsyncTask: after await, got result: &#123;0&#125;, thread&#123;1&#125;&quot;</span>, a, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AsyncTask();</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output (使用自定义的SynchronizationContext):</span></span><br><span class="line"><span class="comment">// AsyncTask: before await, thread1</span></span><br><span class="line"><span class="comment">// AsyncTask: in task, thread3</span></span><br><span class="line"><span class="comment">// MySynchronizationContext Post, thread3</span></span><br><span class="line"><span class="comment">// AsyncTask: after await, got result: 666, thread4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Output2 (使用默认的SynchronizationContext):</span></span><br><span class="line"><span class="comment">// AsyncTask: before await, thread1</span></span><br><span class="line"><span class="comment">// AsyncTask: in task, thread3</span></span><br><span class="line"><span class="comment">// AsyncTask: after await, got result: 666, thread3</span></span><br></pre></td></tr></table></figure><p>这说明了如果当前线程没有或者设置的默认的SynchronizationContex，那么await之后的回调委托实际上是在await的Task所在的线程上执行的(这一点和ContinueWith的默认行为不大一样，后者总是会通过QueueWorkItem跑在一个新的线程中)。</p><p>如果设置了非默认的SynchronizationContex，那么回调委托将通过<code>SynchronizationContex.Post</code>方法封送(由于SynchronizationContex本质也只是接口，我们这里并不能草率地说，会回到Caller线程)。如对于WPF这类UI框架而言，它实现的<code>DispatcherSynchronizationContext</code>最终通过<code>Dispatcher.BeginInvoke</code>将委托封送到UI线程。而如果你是在UI线程发起await，其后又在UI线程上使用<code>task.Result</code>同步等待执行结果，就可能解锁前面F3Async中提到的<a href="https://zhuanlan.zhihu.com/p/371362645">UI线程卡死场景</a>，这也是新手最常犯的问题。你可以通过<code>task.ConfigureAwait(bool continueOnCapturedContext)</code>指定false来关闭指定Task捕获SynchronizationContex的能力，如此委托回调的执行线程就和没有SynchronizationContex类似了。</p><p>总结下，async/await本身不创建线程，<code>aaa; await bbb; ccc;</code> 这三行代码，可能涉及到一个线程(比如没有await，或任务立即完成，甚至await线程自己的异步操作)，两个线程(比如没有自定义SynchronizationContex，或有自己实现消息泵的的SynchronizationContex)，三个线程(有其他线程实现消息泵的自定义SynchronizationContex)。但具体涉及几个线程，GetAwaiter(通常返回的是TaskAwaiter，但是你也可以自定义)，SynchronizationContex等外部代码和环境决定的。</p><h4 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h4><h5 id="await与yield的区别"><a href="#await与yield的区别" class="headerlink" title="await与yield的区别"></a>await与yield的区别</h5><p>yield和await都是语法糖，最后都会被生成一个状态机，每行yield/await都对应其中一个状态。</p><ul><li>本质用途: yield用于快速构造枚举器，而await用于简化异步编程模型，两者都会生成状态机，但前对外表现为可枚举类，用于手动迭代，后者主要用于AsyncTaskMethodBuilder自动迭代(从调用async函数起，Builder就通过异步回调不断调用MoveNext，直至走完每个await状态)</li><li>线程切换: yield不涉及线程上下文的切换，而await通常涉及(前面说了，不是因为它会创建线程，而是依赖具体的异步操作，以及同步上下文)</li></ul><h5 id="C-async-await-vs-JS-Generator异步"><a href="#C-async-await-vs-JS-Generator异步" class="headerlink" title="C# async/await vs JS Generator异步"></a>C# async/await vs JS Generator异步</h5><p>既然async/await也是异步编程模型，同样的，我们也将C# async/await用Generator异步编程四要素来分析下:</p><ul><li>Generator: C# yield是由编译器生成状态机类并实现IEnumerable，类似的，C# async/await也是编译器生成的可迭代状态机IAsyncStateMachine，不过它只有MoveNext()方法，看起来甚至不能单向传值。不过事实上，它的双向传值机制都封装在状态机类内部了</li><li>Thunk: await也有Awaitable标准，它需要实现INotifyCompletion的<code>OnCompleted(Action continuation)</code>方法，这也就提供了统一的挂载回调标准。C# Task和JS Promise一样，都实现了异步执行和回调挂接分离</li><li>AsyncOp: C#的Task原生适配了Awaitable，并且Awaitable也非常易于开发者扩展(后面讲UniTask还会详述)</li><li>Iterator: 整个状态机的驱动，由前面提到的AsyncTaskMethodBuilder来完成，它负责将await之后的执行路径通过OnCompleted挂载到异步操作上</li></ul><p>强行将C# async/await映射到四要素可能不是很合适，因为C# async/await的Generator和Iterator是一体生成的，严格上不涉及所谓的执行权转移。C# async/await 是在async function外部直接生成一个状态机Wrapper类，对函数执行入口、返回值等进行了”魔改”。而JS Generator异步，是通过自定义的run函数或第三方co库驱动迭代。因此C#的async/await可以进行任意函数层级嵌套，而无需像JS一样每一个Generator都要单独驱动，另外C# async/await 可能涉及到线程切换，而JS则通常都是在单线程。</p><h5 id="async-await是Task-状态机的语法糖"><a href="#async-await是Task-状态机的语法糖" class="headerlink" title="async/await是Task+状态机的语法糖"></a>async/await是Task+状态机的语法糖</h5><p>这个要从两方面看，一方面，async函数在经过编译器处理后，最终返回给调用方的，是builder中的Task对象(这也是为何async方法的返回值只能是<code>void</code>, <code>Task</code>, <code>Task&lt;TResult&gt;</code>)。而另一方面，await本身不关注Task，它支持所有提供异步相关接口的对象(GetAwaiter)，这样的好处在于除了Task，它还可以集成更多来自框架(比如<code>.NET</code>已经提供的各种Async API)，甚至自定义的异步对象，已有的异步操作也可以通过适配GetAwaiter移植到新的async/await异步编程模型。</p><h5 id="出现await的地方，当前线程就会返回，或发生线程上下文切换"><a href="#出现await的地方，当前线程就会返回，或发生线程上下文切换" class="headerlink" title="出现await的地方，当前线程就会返回，或发生线程上下文切换"></a>出现await的地方，当前线程就会返回，或发生线程上下文切换</h5><p>这个前面也解释过了，出现await的地方未必会涉及线程上下文切换，比如前面的<code>await F2Async()</code>，对它的整个调用都是同步的。异步编程和线程无关，线程切换取决于异步操作的实现细节，而await本身只关注与异步操作交互的接口。</p><h3 id="Unity-async-await"><a href="#Unity-async-await" class="headerlink" title="Unity async/await"></a>Unity async/await</h3><p>Unity也引入了C# async/await机制，并对其进行了适配:</p><ol><li>Unity本身也是UI框架，因此它实现了自己的同步上下文<a href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Scripting/UnitySynchronizationContext.cs">UnitySynchronizationContext</a>以及主线程的消息泵，如此await的异步委托会默认会回到Unity主线程执行(可通过task.ConfigureAwait配置)</li><li>Unity社区提供了针对大部分常见YieldInstruction(如WaitForSeconds)，以及其他常用库(如UnityWebRequest、ResourceRequest)的GetAwaiter适配(如<a href="https://github.com/svermeulen/Unity3dAsyncAwaitUtil">Unity3dAsyncAwaitUtil</a>)</li></ol><p><a href="https://github.com/svermeulen/Unity3dAsyncAwaitUtil">Unity3dAsyncAwaitUtil</a>这个库及其相关Blog: <a href="http://www.stevevermeulen.com/index.php/2017/09/using-async-await-in-unity3d-2017/">Async-Await instead of coroutines in Unity 2017</a>，非常值得了解一下，以适配大家最熟悉的YieldInstruction WaitForSeconds(3)为例，来大概了解下如何通过将它适配为可以直接<code>await WaitForSeconds(3);</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetAwaiter</span></span><br><span class="line"><span class="comment">// 适配WaitForSeconds类的GetAwaiter方法，通过GetAwaiterReturnVoid返回其Awaiter对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SimpleCoroutineAwaiter <span class="title">GetAwaiter</span>(<span class="params"><span class="keyword">this</span> WaitForSeconds instruction</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GetAwaiterReturnVoid(instruction);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// GetAwaiterReturnVoid</span></span><br><span class="line"><span class="comment">// 创建和返回Awaiter: SimpleCoroutineAwaiter</span></span><br><span class="line"><span class="comment">// 并在Unity主线程执行InstructionWrappers.ReturnVoid(awaiter, instruction)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SimpleCoroutineAwaiter <span class="title">GetAwaiterReturnVoid</span>(<span class="params"><span class="built_in">object</span> instruction</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> awaiter = <span class="keyword">new</span> SimpleCoroutineAwaiter();</span><br><span class="line">    RunOnUnityScheduler(() =&gt; AsyncCoroutineRunner.Instance.StartCoroutine(</span><br><span class="line">        InstructionWrappers.ReturnVoid(awaiter, instruction)));</span><br><span class="line">    <span class="keyword">return</span> awaiter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// InstructionWrappers.ReturnVoid</span></span><br><span class="line"><span class="comment">// 这里其实已经在Unity主线程，所以这里本质是将await最终换回了yield，由Unity来驱动WaitForSeconds的完成</span></span><br><span class="line"><span class="comment">// 只不过yield完成之后，通过awaiter.Complete回到Awaiter.OnCompleted流程去</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerator <span class="title">ReturnVoid</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            SimpleCoroutineAwaiter awaiter, <span class="built_in">object</span> instruction</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// For simple instructions we assume that they don&#x27;t throw exceptions</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> instruction;</span><br><span class="line">    awaiter.Complete(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保Action在Unity主线程上运行</span></span><br><span class="line"><span class="comment">// SyncContextUtil.UnitySynchronizationContext在插件Install的时候就初始化好了</span></span><br><span class="line"><span class="comment">// 如果发现当前已经在Unity主线程，就直接执行Action，无需自己Post自己</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RunOnUnityScheduler</span>(<span class="params">Action action</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (SynchronizationContext.Current == SyncContextUtil.UnitySynchronizationContext)</span><br><span class="line">    &#123;</span><br><span class="line">        action();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        SyncContextUtil.UnitySynchronizationContext.Post(_ =&gt; action(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正的Awaiter，它是无返回值的，对应还有一个SimpleCoroutineAwaiter&lt;T&gt;版本</span></span><br><span class="line"><span class="comment">// 它的实现比较简单，就是适配接口，记录委托回调(_continuation)，并在Compele()任务完成时，通过RunOnUnityScheduler封送委托回调</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleCoroutineAwaiter</span> : <span class="title">INotifyCompletion</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> _isDone;</span><br><span class="line">    Exception _exception;</span><br><span class="line">    Action _continuation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsCompleted</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _isDone; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetResult</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Assert(_isDone);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_exception != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ExceptionDispatchInfo.Capture(_exception).Throw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Complete</span>(<span class="params">Exception e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Assert(!_isDone);</span><br><span class="line"></span><br><span class="line">        _isDone = <span class="literal">true</span>;</span><br><span class="line">        _exception = e;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Always trigger the continuation on the unity thread when awaiting on unity yield</span></span><br><span class="line">        <span class="comment">// instructions</span></span><br><span class="line">        <span class="keyword">if</span> (_continuation != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RunOnUnityScheduler(_continuation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> INotifyCompletion.OnCompleted(Action continuation)</span><br><span class="line">    &#123;</span><br><span class="line">        Assert(_continuation == <span class="literal">null</span>);</span><br><span class="line">        Assert(!_isDone);</span><br><span class="line"></span><br><span class="line">        _continuation = continuation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此我们就可以直接使用<code>await WaitForSeconds(3);</code>了，深入细节可以发现，不管是WaitForSeconds本身，还是之后的回调委托，其实都是在Unity主线程中执行的，并且结合RunOnUnityScheduler的优化，整个过程既不会创建线程，也不会产生额外的消息投递，只是在yield上加了一层壳子而已。这也再次说明了，async/await本身只是异步编程模型，具体的线程切换情况，Awaiter，SynchronizationContext，ConfigureAwait等综合控制。</p><p>这个工具库还有一些有意思的小特性，比如Task到IEnumerator的转换(原理就是轮询Task完成状态)，通过<code>await new WaitForBackgroundThread();</code>切换到后台线程(原理其实就是对<code>task.ConfigureAwait(false)</code>的封装)，这些在理解整个async/await，Unity协程，SynchronizationContext等内容后，都应该不难理解了。</p><p>另外，这里有篇关于<a href="https://www.linkedin.com/pulse/unity-async-vs-coroutine-jo%C3%A3o-borks">Unity中async/await与coroutine的性能对比</a>，可以看看。</p><h3 id="Unity-UniTask"><a href="#Unity-UniTask" class="headerlink" title="Unity UniTask"></a>Unity UniTask</h3><p>通过前面的了解，可以发现，在Unity中，Coroutine可以用来实现单线程内的异步操作，Task可用来实现多线程的并发、异步和协同操作。而async/await是一种比Coroutine和Task更抽象易用的异步编程模型，C#完成了Task和async/await的适配，Unity3dAsyncAwaitUtil完成了Coroutine和async/await的适配，但对Unity开发者而言，还是不够方便，开发者面临过多方案选择: yield Coroutine or await Coroutine or await Task，因此，Unity社区又有大神出手，出了一套新方案: <a href="https://github.com/Cysharp/UniTask">UniTask</a>，它的目的是整合Coroutine的轻量、Task的并发、async/await的易用于一体，为开发者提供高性能、可并发、易使用的接口。</p><p>它的主要特性包括:</p><ul><li>基于值类型的 UniTask<T> 和自定义的 AsyncMethodBuilder 来实现0GC</li><li>使所有 Unity 的 AsyncOperations 和 Coroutines 可等待 (类似Unity3dAsyncAwaitUtil的适配)</li><li>基于 PlayerLoop 的任务(UniTask.Yield, UniTask.Delay, UniTask.DelayFrame…)可以替代所有协程操作</li><li>对 MonoBehaviour 消息事件和 uGUI 事件进行 可等待/异步枚举 拓展</li><li>与C#原生 Task/ValueTask/IValueTaskSource 行为高度兼容</li><li>…</li></ul><p>更详细UniTask功能介绍，推荐<a href="https://www.lfzxb.top/unitask_reademe_cn/">这篇博客</a>，UniTask一方面保留和适配 Unity Coroutine的轻量单线程异步模型，另一方面，将Coroutine的惯用场景(如WaitForSeconds)全部移植到性能更优的UniTask上实现了一遍(受益于async/await异步模型的抽象性)，并且保持UniTask与Task语义兼容，保留大部分的Task并发和交互模型能力。</p><p>从实现上来说，以<code>UniTask.Delay</code>为例，它的功能类似于WaitForSeconds，它会返回一个<code>UniTask</code>对象，UniTask对象本身只是一层可await的壳子，真正起作用的对象是其持有的<code>DelayPromise</code>对象(<code>IUniTaskSource source</code>字段)，DelayPromise的有两个核心方法:</p><ul><li><code>OnCompleted</code>: AsyncUniTaskMethodBuilder挂接异步回调会通过UniTask Awaiter调到这里，它只是简单转调用<code>core.OnCompleted</code>，<code>UniTaskCompletionSourceCore core</code>是UniTask Promise都有的字段，做一些核心代码复用</li><li><code>MoveNext() bool</code>: 它会检查时间是否到期，未到期返回true，到期则通过<code>core.TrySetResult(null)</code>设置完成状态，并返回true。注意，<code>core.TrySetResult</code>中，会调用并执行continuation</li></ul><p>异步挂接和回调机制有了，谁来驱动<code>IUniTaskSource.MoveNext</code>，注意，这个MoveNext和C#中的<code>IAsyncStateMachine.MoveNext</code>是不同的:</p><ul><li><code>IAsyncStateMachine.MoveNext</code>: 表示开始驱动整个状态机，Awaitable在异步任务完成时，会通过continuation(由AsyncTaskMethodBuilder生成并通过OnCompleted注入)调用到<code>stateMachine.MoveNext</code>跳转到下一个await语句。</li><li><code>IUniTaskSource.MoveNext</code>: 仅用于确定状态机的该异步任务是否已经完成，将continuation的调用放到了外部驱动器。比如对<code>UniTask.Delay</code>而言，它是不切换线程的，如Unity Coroutine一样，通常由额外的Ticker/Event/Poll这类机制，来检查状态变更(如Delay到期)，设置Awaiter Result，并回调continuation(通过<code>core.TrySetResult(null)</code>)。</li></ul><p>驱动<code>IUniTaskSource.MoveNext</code>的工作是由<a href="https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/Internal/PlayerLoopRunner.cs">PlayerLoopRunner</a>来完成的，DelayPromise创建之后，就会被立即添加到PlayerLoop Action中，PlayerLoopRunner穿插在Unity的各个执行Timing，驱动/检查所有IPLayerLoopItem任务的MoveNext。</p><p>对于<code>UniTask.Yield(PlayerLoopTiming.FixedUpdate);</code>这类场景，UniTask的实现更为简单，直接在<code>YieldAwaitable.OnCompleted(continuation)</code>挂接异步回调时，将continuation挂在PlayerLoop上即可，PlayerLoop会在对应timing(如FixedUpdate)触发时，调用continuation。</p><p>另外，<code>UniTask.Run/RunOnThreadPool</code>不使用默认的UnitySynchronizationContext和ExecutionContext，而是自己做同步上下文切换，这一点可能会容易和原生Task行为混淆，虽然它也提供<code>UniTask.SwitchToMainThread</code>、<code>UniTask.SwitchToThreadPool</code>、<code>UniTask.ReturnToCurrentSynchronizationContext</code>等API进行精确的同步上下文控制。</p><p>UniTask将Unity单线程异步编程诸多实践与async/await异步编程模型有机整合，并对Unity Coroutine与C# Task的诸多痛点进行优化和升级，看起来确实有一统Unity异步编程模型的潜力，应该离整合进Unity官方包也不远了。</p><h3 id="一点体会"><a href="#一点体会" class="headerlink" title="一点体会"></a>一点体会</h3><p>首先我是个C#和Unity的门外汉，只是谈谈自己的体会，异步编程尤其是并发编程从来都不是一件简单的事，无论它看起来多么”简洁优雅”。学习各语言/框架的异步演进史，是一件非常有意思的事情:</p><ul><li>C#: Thread(关注实现) -&gt; Task(关注任务) -&gt; async/await(关注可读性和扩展性)</li><li>Unity: Coroutine(Engine做大量支持，算半个异步编程模型) -&gt; Unity3DAsyncAwaitUtil(将Coroutine适配到async/await) -&gt; 到UniTask(整合Coroutine和Task，兼并性能更高、可读性更高、更适合Unity)</li><li>JS: Callback(最原始) -&gt; Generator+Thunk+AsyncOp+Iterator异步(初步四件套) -&gt; Promise(统一规范异步操作) -&gt; Generator+Promise+co(标准三件套) -&gt; async/await+Promise(终极两件套)</li></ul><p>异步编程模型一直在演进，看起来写越来越”简单”，可读性越来越”高”，代价是编译器和运行时做了更多的工作，并且这些工作和原理是作为开发者必须要了解的，以C# async/await为例，如果不能充分了解底层原理，就容易引发: </p><ul><li>异步回调闭包引用可变上下文的问题</li><li>async “无栈编程”本身带来的理解负担和调试难度</li><li>代码的线程上下文难以分析，容易引发并发安全访问的问题</li><li>同一段代码在不同的线程执行可能具有完全不同的行为(SynchronizationContext和ExecuteContext不同)</li></ul><p>等问题。语言和框架本身只提供选择，作为使用者的我们，在并发越来越”容易”的同时，保持对原理的理解，才能充分发挥工具的作用(享受上限高的好处，避免下限低的问题)。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这段时间学习Unity，顺便系统性地了解了下C#和Unity异步编程的各种机制和实现细节。本文是这些学习资料和个人理解的汇总。会先介绍下C# yield，Task，async/await，同步上下文等机制。然后聊聊其在Unity上的一些变体和应用。&lt;/p&gt;</summary>
    
    
    
    <category term="c#" scheme="http://wudaijun.com/categories/c/"/>
    
    
    <category term="coroutine" scheme="http://wudaijun.com/tags/coroutine/"/>
    
    <category term="async programing" scheme="http://wudaijun.com/tags/async-programing/"/>
    
    <category term="unity" scheme="http://wudaijun.com/tags/unity/"/>
    
    <category term="c#" scheme="http://wudaijun.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>软件工程能力</title>
    <link href="http://wudaijun.com/2021/07/software-engineering-ability/"/>
    <id>http://wudaijun.com/2021/07/software-engineering-ability/</id>
    <published>2021-07-20T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.615Z</updated>
    
    <content type="html"><![CDATA[<p>启发于<a href="https://mp.weixin.qq.com/s/hJS5LJRZkMZmHm6g2R_jpw">漫谈软件工程能力</a></p><p><img src="assets/image/202107/软件工程能力.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;启发于&lt;a href=&quot;https://mp.weixin.qq.com/s/hJS5LJRZkMZmHm6g2R_jpw&quot;&gt;漫谈软件工程能力&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;assets/image/202107/软件工程能力.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="mindmap" scheme="http://wudaijun.com/categories/mindmap/"/>
    
    
    <category term="engineer" scheme="http://wudaijun.com/tags/engineer/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计的一些小结</title>
    <link href="http://wudaijun.com/2021/07/domain-driven-design-mindmap/"/>
    <id>http://wudaijun.com/2021/07/domain-driven-design-mindmap/</id>
    <published>2021-07-03T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.615Z</updated>
    
    <content type="html"><![CDATA[<p><img src="assets/image/202107/ddd.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;assets/image/202107/ddd.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="design" scheme="http://wudaijun.com/categories/design/"/>
    
    
    <category term="domain driver design" scheme="http://wudaijun.com/tags/domain-driver-design/"/>
    
    <category term="DDD" scheme="http://wudaijun.com/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>软件设计的一些理解</title>
    <link href="http://wudaijun.com/2021/06/software-design-mindmap/"/>
    <id>http://wudaijun.com/2021/06/software-design-mindmap/</id>
    <published>2021-06-27T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.615Z</updated>
    
    <content type="html"><![CDATA[<p><img src="assets/image/202106/软件设计.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;assets/image/202106/软件设计.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="design" scheme="http://wudaijun.com/categories/design/"/>
    
    
    <category term="software design" scheme="http://wudaijun.com/tags/software-design/"/>
    
  </entry>
  
  <entry>
    <title>聊聊GS引入MQ的一些实践</title>
    <link href="http://wudaijun.com/2021/02/gs-mq-practice/"/>
    <id>http://wudaijun.com/2021/02/gs-mq-practice/</id>
    <published>2021-02-17T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.615Z</updated>
    
    <content type="html"><![CDATA[<p>在目前这套项目架构诞生初期，基于当时的游戏类型和项目需求，架构做得相对简单，设计上尽可能通过goroutine而不是节点来并发，节点间用ETCD做服务发现，用gRPC做节点通信，在单向依赖，弱藕合的情况下，基本能够满足需求。对于个别强耦合的节点交互，使用gRPC Stream来建立双工连接。</p><p>随着游戏类型和业务需求的变更，跨服功能增多，节点划分越来越细，藕合越来越重，网络拓扑也越来越复杂。gRPC Stream不再能很好地胜任。</p><p>因此我们考虑用一套新的节点交互方案，大概有两个思路:</p><ol><li>写一套完备的TCP网络库(包含服务发现，自动重连，编解码，心跳，流控等)，用于统一节点间甚至Gateway与Client间的网络交互</li><li>使用MQ解耦集群内节点交互，将网状网络化为星形网络，简化网络拓扑</li></ol><span id="more"></span><p>在对方案一进行几天的尝试后，我们最终放弃了TCP方案，主要有以下几个问题:</p><ol><li>网络拓扑完全交给了应用层去维护，开发者需要谨慎规划和约束，避免形成全联通</li><li>由于不是全联通网络，A-&gt;B的消息可能需要经由一个甚至多个中间节点路由才能到达，并且这类路由信息只能逻辑层维护</li><li>某些业务场景下，节点路由和依赖可能是动态的，如跨服匹配战场，此时需要动态建立/销毁连接以维护动态路由</li></ol><p>就前面几个问题来说，MQ是更好的解决方案，相比TCP，它有以下优势:</p><ol><li>将 0-N 跳的路由网络的模型，统一为一跳，即通过中间件即可直达任意节点，在路由和全联通之间找到一个平衡点</li><li>发布订阅模型，为应用层提供了非常大的灵活度: 单向依赖/双向依赖，扇入/扇出，负载均衡，批量发布(主题匹配)等</li></ol><p>消息中间件能够比较好地向应用层屏蔽节点路由的问题，但它并不能完全替代ETCD+gRPC，两套方案可以在不同的应用场景搭配使用。</p><p>在对几种主流消息中间件进行评估之后，我们目前选定<a href="https://github.com/nats-io/nats-server">nats</a>，它的优点是基于golang编写，轻量级，高性能，低延迟，缺点是不支持消息持久化，即最多一次投递语义，<a href="https://github.com/nats-io/nats-streaming-server">nats-streaming</a>基于nats增加了消息持久化，即最少一次投递语义，相应的也有更完备的流控机制。由于游戏服务器对消息时延敏感，并且大部分消息有状态和时效性，因此目前打算直接用nats，关键逻辑自己做消息QoS或容错机制(官方也推荐nats，由应用层而不是中间件去做QoS)。</p><p>从设计上而言，在nats之上封装应用层MQ API，不依赖nats特有功能(如Request-Reply)，只使用消息中间件的通用语义(Publish/Subscribe)，解耦组件以实现必要时透明替换，应用层对MQ API的使用主要分两种:</p><ol><li>节点通信: 应用在藕合较强的逻辑节点间，在这里Topic类似于节点公开通信地址，MQ起到的作用类似TCP。这情况情形下，对MQ封装通用消息语义: Send / Request / Async-Request，前两种语义容易理解，即异步投递和同步请求，第三种是异步请求，通过回调的方式处理响应，并统一保存请求上下文，适用于异步RPC情景。更进一步，这一层消息语义封装不应该依赖于MQ封装，即可以透明将这层语义的底层实现由MQ换成TCP或其它传输层，同时应该向应用层屏蔽掉Topic，提供类似EndPoint或Peer的抽象概念。</li><li>发布订阅: 消息中间件的常规应用，但是也需要封装，一方面是为了解耦屏蔽nats，另一方面是构建应用层对订阅分发的优化，就我们目前的实践而言，建立了一个固定大小的mq worker pool，以Topic Hash为请求分配worker，每个worker内部做二级分发(优化同一个节点对同一个Topic的多次订阅)，序列化/反序列化等，worker底层复用同一个nats client，对逻辑层提供足够易用的异步发布订阅接口。</li></ol><p>关于MQ的进一步实践我们还在摸索，目前的体会是，消息中间件和网关一样，都是游戏服务器架构的基础设施，前者对内简化服务器节点网络拓扑，后者对外屏蔽服务器内部网络拓扑，共同提升服务器的可扩展性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在目前这套项目架构诞生初期，基于当时的游戏类型和项目需求，架构做得相对简单，设计上尽可能通过goroutine而不是节点来并发，节点间用ETCD做服务发现，用gRPC做节点通信，在单向依赖，弱藕合的情况下，基本能够满足需求。对于个别强耦合的节点交互，使用gRPC Stream来建立双工连接。&lt;/p&gt;
&lt;p&gt;随着游戏类型和业务需求的变更，跨服功能增多，节点划分越来越细，藕合越来越重，网络拓扑也越来越复杂。gRPC Stream不再能很好地胜任。&lt;/p&gt;
&lt;p&gt;因此我们考虑用一套新的节点交互方案，大概有两个思路:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写一套完备的TCP网络库(包含服务发现，自动重连，编解码，心跳，流控等)，用于统一节点间甚至Gateway与Client间的网络交互&lt;/li&gt;
&lt;li&gt;使用MQ解耦集群内节点交互，将网状网络化为星形网络，简化网络拓扑&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="gameserver" scheme="http://wudaijun.com/categories/gameserver/"/>
    
    
    <category term="gameserver" scheme="http://wudaijun.com/tags/gameserver/"/>
    
    <category term="mq" scheme="http://wudaijun.com/tags/mq/"/>
    
  </entry>
  
  <entry>
    <title>Go 泛型特性速览</title>
    <link href="http://wudaijun.com/2020/12/go-generics/"/>
    <id>http://wudaijun.com/2020/12/go-generics/</id>
    <published>2020-12-19T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.615Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>2022.1.22 更新: 最近一年，Go泛型已经从草案，过渡到提案，并开始实现。<a href="https://tip.golang.org/doc/go1.18">Go1.18</a>实现了初版泛型，最终方案相较之前的泛型草案，将<strong>类型列表约束(type list in constraint)</strong>进一步丰富完善为<strong>类型集约束(type sets of constraints)</strong>的概念，本文内容已随最新文档更新。</p></blockquote></blockquote><p>之前我在<a href="https://wudaijun.com/2019/05/programing-paradigm/">编程范式游记</a>中介绍了OOP中的子类化(subtype，也叫子类型多态subtype polymorphism)和泛型(generics，也叫参数多态parametric polymorphism或类型参数type parameters)，关于两者的区别和比较可以参考那篇文章，在其中我吐槽了Go目前对泛型支持的匮乏，Go泛型最初在<a href="https://github.com/golang/go/wiki/Go">Go 2</a>中讨论，目前已经在Go1.18中正式实现，随着Go泛型设计和实现的细节也越来越清晰，我们从最新的<a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">Go泛型文档</a>来了解下Go泛型设计上有哪些考量和取舍。</p><p>PS. 虽然Go官方文档仍然沿用社区惯用的”泛型(generics)”术语，由于主流语言都有自己不同的泛型支持，如Java基于<strong>编译期类型擦除</strong>的泛型(伪泛型)，C++的<strong>图灵完备</strong>的模板机制(支持模板元编程的真泛型)等，为了避免概念混淆，将Go泛型理解为<strong>类型参数(type parameters)</strong>更精确，它不支持C++那样灵活的模板元编程，但比Java这种运行时擦除类型信息的补丁实现更优，另外，关于运算符泛型，Go也提出了一套新的解决方案。</p><h4 id="1-最简原型"><a href="#1-最简原型" class="headerlink" title="1. 最简原型"></a>1. 最简原型</h4><p>先从最简单的泛型定义开始:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span>[<span class="title">T</span>] <span class="params">(s []T)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Call</span></span><br><span class="line">Print[<span class="keyword">int</span>]([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><p>语法上和其它语言泛型大同小异，泛型的本质是将<strong>类型参数化</strong>，Go中用函数名后的<code>[]</code>定义类型参数。以上声明对C++开发者来说非常亲切的(只是换了一种语法形式)，实际上这在Go中是错误的泛型函数声明，因为它没有指明类型参数约束(constraints)。</p><span id="more"></span><h4 id="2-类型约束"><a href="#2-类型约束" class="headerlink" title="2. 类型约束"></a>2. 类型约束</h4><p>与C++不同，Go在一开始就确定要引入泛型的类型参数约束(bounded generic types，subtype与generics的有机结合)，并且借机吐槽了C++的无约束泛型类型参数，因为这会带来非常难调试的编译时报错。在上例中，即使Print内部没有调用T的任何方法，也需要通过新引入的<code>any</code>关键字来表示任意类型约束(考虑下不能未显示指定约束则缺省即为<code>any</code>的原因)。因此正确的Print声明方式为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span>[<span class="title">T</span> <span class="title">any</span>] <span class="params">(s []T)</span></span> &#123; ...</span><br></pre></td></tr></table></figure><p>PS: 任意类型不代表不能执行任意操作，如声明变量，赋值，取地址(<code>&amp;</code>)，取类型(<code>.(type)</code>)等。</p><p>那么除去<code>any</code>，如何表示一个有效的类型约束，参考其它支持bounded generic types语言的做法，如C#/Java，自然go interface是不二之选，因为go interface本质就是做subtype，而subtype本身主要就是服务于静态语言的type checker的。因此subtype也可以辅助编译器完善对类型参数的检查。使用interface做类型参数约束的函数看起来是这个样子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stringify</span>[<span class="title">T</span> <span class="title">fmt</span>.<span class="title">Stringer</span>]<span class="params">(s []T)</span> <span class="params">(ret []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, v.String()) D</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个有意思的问题，为什么Go编译器不直接用Stringify函数中对T的各种函数调用，自动推敲生成一个匿名interface呢，如此对Stringify来说，外部满足<code>fmt.Stringer</code>的类型，仍然能够使用Stringify，并且这本身也是Go隐式接口的一大便利(不依赖于subclass来实现subtype，Go没有subclass)，其它像C++/C#/Java依赖于显示接口/基类继承声明得语言，是无法做到的。关于这一点，Go官方的解释是，如果接口隐式推敲，少了显式接口这层”契约”，那么Stringify的一个很小的改动都可能导致上层调用不可用，这不利于构建大型项目。调用方只需要关心它是否满足接口约束，而不应该也不需要去阅读Stringify的代码来知道它可能调用T的哪些函数。</p><p>既然选定了用interface来做类型参数约束，那么再来看<code>any</code>，它实际上就和<code>interface&#123;&#125;</code>没有区别的，任意类型都满足<code>interface&#123;&#125;</code>接口，因此实际上Print也可以声明为 <code>func Print[T interface&#123;&#125;] (s []T)</code>，但是官方觉得在写任意类型的泛型的时候，每次写<code>interface&#123;&#125;</code>太麻烦了(符合golang的极简思维)，因此还是觉得应该保留<code>any</code>关键字，作为<code>interface&#123;&#125;</code>的别名，但是在除了泛型类型约束之外，常规空接口仍然用<code>interface&#123;&#125;</code>而不能用<code>any</code>，解释是不希望新增的泛型给以前的代码带来影响…</p><h4 id="3-泛型类型"><a href="#3-泛型类型" class="headerlink" title="3. 泛型类型"></a>3. 泛型类型</h4><p>除了泛型函数外，基于泛型也可以构建新的类型，如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个可保存任意类型的切片</span></span><br><span class="line"><span class="keyword">type</span> Vector[T any] []T</span><br><span class="line"><span class="comment">// 实现泛型类Vector方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vector[T])</span> <span class="title">Push</span><span class="params">(x T)</span></span> &#123; *v = <span class="built_in">append</span>(*v, x) &#125;</span><br><span class="line"><span class="comment">// 实例化泛型类型 Vecter[int] t</span></span><br><span class="line"><span class="keyword">var</span> v Vector[<span class="keyword">int</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与前面的Vector[int]等价，事实上编译器也会生成类似的类</span></span><br><span class="line"><span class="keyword">type</span> VecterInt []<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VectorInt)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123; *v = <span class="built_in">append</span>(*v, x) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个可保存两个任意类型值的Pair</span></span><br><span class="line"><span class="keyword">type</span> Pair[T1, T2 any] <span class="keyword">struct</span> &#123;</span><br><span class="line">val1  T1</span><br><span class="line">    val2  T2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Pair List</span></span><br><span class="line"><span class="comment">// 注意next字段引用了自身，目前这种相互直接或间接引用，要求参数类型(以及顺序)一致，后面可能会放宽此要求</span></span><br><span class="line"><span class="keyword">type</span> List[T1, T2 any] <span class="keyword">struct</span> &#123;</span><br><span class="line">next *List[T1, T2] <span class="comment">// 如果改成 List[T2, T1] 则不行</span></span><br><span class="line">val  Pair[T1, T2] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-类型集约束"><a href="#4-类型集约束" class="headerlink" title="4. 类型集约束"></a>4. 类型集约束</h4><p>前面提到Go通过interface完成对参数类型的约束，理论上来说已经是完备的了(毕竟interface用作subtype已经证明了这点)，但是还不够方便，比如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function is INVALID.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Smallest</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s []T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">r := s[<span class="number">0</span>] <span class="comment">// panic if slice is empty</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s[<span class="number">1</span>:] &#123;</span><br><span class="line"><span class="keyword">if</span> v &lt; r &#123; <span class="comment">// INVALID</span></span><br><span class="line">r = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Smallest</code>函数中，我们希望求出一个切片中的最小元素，但是这个函数声明本身是无效的，因为不是所有的类型都支持<code>&lt;</code>运算符，事实上，在Go中，仅有限的内置类型支持<code>&lt;</code>，其它自定义类型均不支持通过方法定义自己的<code>&lt;</code>运算(此处开始怀念C++的运算符，但是其带来的”一切皆有可能”的代码理解负担也确实头疼…)，诚然这里可以通过定义类似的Comparable interface来进行类型约束和比较，将<code>v &lt; r</code>替换为<code>v.Less(r)</code>，但你也需要为原生支持比较的类型(int/float/string)定义一个新的类型并实现Comparable接口，反而让Smallest使用起来更复杂。因此，这里Go有必要为基础运算符定义一套泛型类型约束，使得调用方可以直接通过<code>Smallest[int]([]int&#123;3,1,4&#125;)</code>即可使用。</p><p>这里有两种实现方式，一种方案是预定义基础运算的约束，并且让满足条件的基础类型自动适配而无需手动实现，如<code>&lt;</code>，<code>&gt;</code>，<code>==</code>，<code>&lt;&lt;</code>，<code>&amp;&amp;</code>，<code>range</code>，<code>size</code>等。另一种方式是基于Go几乎所有的逻辑运算符(唯二的例外在后面会讨论)都仅支持内置基础类型，并且内置基础类型是有限的这两点事实，从另一个角度出发: 让类型约束可以直接指定其需要包含的基础类型。Go优先选择了第二种方案，提供所谓<strong>类型集约束(type sets of contraints)</strong>机制。</p><h5 id="类型集"><a href="#类型集" class="headerlink" title="类型集"></a>类型集</h5><p>Go新增了类型集(type sets)的概念，每个类型都有自己的类型集，对于非接口类型T而言，其类型集为<code>&#123;T&#125;</code>，即为它自身。对于接口类型而言，如下面的接口T:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">interface</span> &#123;</span><br><span class="line">io.Reader</span><br><span class="line">Foo()</span><br><span class="line">Bar() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语义上等价于</span></span><br><span class="line"><span class="keyword">type</span> E1 <span class="keyword">interface</span> &#123; Foo() &#125;</span><br><span class="line"><span class="keyword">type</span> E2 <span class="keyword">interface</span> &#123; Bar() <span class="keyword">int</span> &#125;</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">interface</span> &#123;</span><br><span class="line">io.Reader</span><br><span class="line">E1</span><br><span class="line">E2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口本质是若干方法签名 + 内嵌接口的组合，而方法签名很容易转换为对应方法的interface(上例的E1和E2)，而接口T的类型集，本质是<code>io.Reader</code>的类型集和E1，E2的类型集的交集，这个定义，既能阐述接口本身概念(满足接口所定义的所有方法)，也能阐述接口作为类型约束的概念(满足T所定义的所有约束)。这个交集的概念是贯穿Go接口和Go泛型约束的。</p><h5 id="类型集约束"><a href="#类型集约束" class="headerlink" title="类型集约束"></a>类型集约束</h5><p>但是，Go接口只支持方法签名和内嵌接口，对于作为泛型类型约束来说，功能弱了一些(比如不能完成前面提到的类型枚举)，因此Go对interface进行了功能扩展，添加了三个特性，使用了这三个特性的interface，将只能作为类型约束，而不能再作为接口:</p><ol><li>类型枚举: 允许类型约束的interface中，直接枚举任意类型，如<code>type Integer inteface&#123; int &#125;</code></li><li>类型近似: 类型枚举不能解决类型重定义的问题，如<code>type MyInt int</code>，也应该满足<code>Integer</code>约束，因此类型约束interface可以通过<code>~T</code>来表达T的近似类型(approximation constraint)，对于约束<code>type Integer2 interface &#123;~int&#125;</code>而言，任何底层类型为int的类型，均满足该约束，包括MyInt</li><li>类型联合: 可以通过<code>A|B</code>来表达”A或B类型”的概念，对于约束<code>type PredeclaredSignedInteger interface &#123; int | int8 | int16 | int32 | int64 &#125;</code>而言，任意以上5个整数类型之一，均满足其约束条件</li></ol><p>现在再来看前面的Smallest函数，它的完整正确约束应该为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ordered is a type constraint that matches any ordered type.</span></span><br><span class="line"><span class="comment">// An ordered type is one that supports the &lt;, &lt;=, &gt;, and &gt;= operators.</span></span><br><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> &#123;</span><br><span class="line">~<span class="keyword">int</span> | ~<span class="keyword">int8</span> | ~<span class="keyword">int16</span> | ~<span class="keyword">int32</span> | ~<span class="keyword">int64</span> |</span><br><span class="line">~<span class="keyword">uint</span> | ~<span class="keyword">uint8</span> | ~<span class="keyword">uint16</span> | ~<span class="keyword">uint32</span> | ~<span class="keyword">uint64</span> | ~<span class="keyword">uintptr</span> |</span><br><span class="line">~<span class="keyword">float32</span> | ~<span class="keyword">float64</span> |</span><br><span class="line">~<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到<code>Ordered</code>这类约束可能会在很多地方用到，因此可能需要将其归到官方库中提供，该package为<code>contraints</code>，如此<code>Smallest</code>即可定义为<code>func Smallest[T constraints.Ordered](s []T) T</code>。</p><p>这里再提一下Go泛型的显示声明原则，有了类型列表约束之后，函数可以直接使用类型列表中所有类型都支持的运算，但<strong>不能直接使用类型列表都支持的方法，即使这些类型都提供了该方法</strong>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i MyInt)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strconv.Itoa(<span class="keyword">int</span>(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strconv.FormatFloat(<span class="keyword">float64</span>(f), <span class="string">&#x27;g&#x27;</span>, <span class="number">-1</span>, <span class="number">64</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyIntOrFloat <span class="keyword">interface</span> &#123;</span><br><span class="line">MyInt | MyFloat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToString</span>[<span class="title">T</span> <span class="title">MyIntOrFloat</span>]<span class="params">(v T)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v.String() <span class="comment">// Error: 泛型函数只能使用类型约束显式声明的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样是为了避免当类型和接口嵌套较深时，调用方很难搞清楚函数到底依赖了约束的哪些方法(因为没了类型约束这层契约)，因此在<code>MyIntOrFloat</code>中显式添加<code>String() string</code>接口是一个更明智的选择。</p><p>综上，Go泛型约束基于接口，但其功能是接口的父集，在扩展了interface功能后，完整的作为类型约束的interface语法如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceTypeName 即为内嵌接口，MethodSpec 为方法签名，均为Go接口本身的概念</span></span><br><span class="line">InterfaceType  = <span class="string">&quot;interface&quot;</span> <span class="string">&quot;&#123;&quot;</span> &#123;(MethodSpec | InterfaceTypeName | ConstraintElem) <span class="string">&quot;;&quot;</span> &#125; <span class="string">&quot;&#125;&quot;</span> .</span><br><span class="line">ConstraintElem = ConstraintTerm &#123; <span class="string">&quot;|&quot;</span> ConstraintTerm &#125; .</span><br><span class="line">ConstraintTerm = [<span class="string">&quot;~&quot;</span>] Type .</span><br></pre></td></tr></table></figure><h4 id="5-预定义约束"><a href="#5-预定义约束" class="headerlink" title="5. 预定义约束"></a>5. 预定义约束</h4><p><strong>几乎所有的运算符都仅支持内置类型</strong>，这其中有两个例外的运算符，等于(==)和不等于(!=)，比如我们知道，在Go中，struct，array是可以直接比较的，Go需要特殊处理这两个运算符，因此还是提出了<code>comparable</code>这个特殊的预定义类型约束:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span>[<span class="title">T</span> <span class="title">comparable</span>]<span class="params">(s []T, x T)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> v == x &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Go同时支持了预定义类型约束和类型集约束，因此开发者可能定义出一个永远无法满足的类型约束:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ImpossibleConstraint <span class="keyword">interface</span> &#123;</span><br><span class="line">comparable</span><br><span class="line">[]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>[]int</code>无法被比较，因此没有任何类型能满足<code>ImpossibleConstraint</code>约束，定义这个约束本身不会报错，但是在尝试调用使用该约束的任意泛型函数和泛型类时，会得到编译错误。</p><p>有了预定义类型约束和类型集约束之后，Go关于运算符的泛型补丁算是打完了，这里再简单梳理下作为interface接口和interface约束的区别:</p><ol><li>Go预定义了两个类型约束: <code>any</code>(等价于interface{}) 和 <code>comparable</code></li><li>约束在接口的基础上，扩展了类型集的支持，包括类型枚举(<code>type T interface &#123;int&#125;</code>)，或类型(<code>int8|int16</code>)，近似类型(<code>~int</code>)三种特性</li><li>接口的本质是一种类型，可定义值，可为nil(表示没有值，但有类型信息)，类型约束本身描述类型的元信息(类型的类型)，它用来定义值通常没有意义，并且不能为nil</li><li>约束本身可以泛型化，这个在之后会提到</li></ol><h4 id="6-复合类型的类型集约束"><a href="#6-复合类型的类型集约束" class="headerlink" title="6. 复合类型的类型集约束"></a>6. 复合类型的类型集约束</h4><p>如果类型集约束中可以存在复合类型，再结合索引<code>[]</code>，求大小<code>len</code>，遍历<code>range</code>，字段访问<code>.</code>等针对复合类型的操作符时，有意思的问题就来了。由于不同复合类型的操作符的参数和返回值类型可能是不同的，比如如果类型集约束中包含<code>[]int</code>和<code>[]int64</code>，它们的索引操作<code>[]</code>会分别返回<code>int</code>和<code>int64</code>，那么此时编译器有两种做法:</p><ol><li>支持<code>[]</code>操作，但是需要有一个类型联合(<code>type union</code>)的新类型，来保存<code>[]</code>的返回值。比如在这里，编译器会生成<code>int</code>和<code>int64</code>的联合来保存<code>[]</code>的返回值</li><li>仅当<code>[]</code>对类型列表中所有的类型的参数和返回值都一致时，才允许使用<code>[]</code>，否则不允许使用<code>[]</code>并报编译错误</li></ol><p>Go目前选择第二种，因为直观上它更容易理解，具体以例子来说:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> structField <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> &#123; a <span class="keyword">int</span>; x <span class="keyword">int</span> &#125; |</span><br><span class="line"><span class="keyword">struct</span> &#123; b <span class="keyword">int</span>; x <span class="keyword">float64</span> &#125; |</span><br><span class="line"><span class="keyword">struct</span> &#123; c <span class="keyword">int</span>; x <span class="keyword">uint64</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IncrementX</span>[<span class="title">T</span> <span class="title">structField</span>]<span class="params">(p *T)</span></span> &#123;</span><br><span class="line">v := p.x <span class="comment">// Error: 对structField type list来说，操作p.x的返回值类型不一样</span></span><br><span class="line">v++</span><br><span class="line">p.x = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sliceOrMap <span class="keyword">interface</span> &#123;</span><br><span class="line">[]<span class="keyword">int</span> | <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Entry</span>[<span class="title">T</span> <span class="title">sliceOrMap</span>]<span class="params">(c T, i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">c[i] <span class="comment">// OK. []int和map[int]int的索引操作的参数和返回值均为int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sliceOrFloatMap <span class="keyword">interface</span> &#123;</span><br><span class="line">[]<span class="keyword">int</span> | <span class="keyword">map</span>[<span class="keyword">float64</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FloatEntry</span>[<span class="title">T</span> <span class="title">sliceOrFloatMap</span>]<span class="params">(c T)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c[<span class="number">1.0</span>] <span class="comment">// Error: 对[]int和map[float64]int来说，[]操作的参数类型不一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前来说，这应该能够应付绝大部分复合类型type list的应用场景。</p><h4 id="7-类型参数的相互引用"><a href="#7-类型参数的相互引用" class="headerlink" title="7. 类型参数的相互引用"></a>7. 类型参数的相互引用</h4><p>Go支持同一个类型参数列表间的相互引用，如下面的泛型图类型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个泛型接口约束来表示图的节点，该约束限制类型必须提供一个返回任意类型切片的Edges()函数</span></span><br><span class="line"><span class="keyword">type</span> NodeConstraint[Edge any] <span class="keyword">interface</span> &#123;</span><br><span class="line">Edges() []Edge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个泛型接口约束来表示图的边，该约束限制类型必须提供一个返回两个相同的任意类型值的Nodes()函数</span></span><br><span class="line"><span class="keyword">type</span> EdgeConstraint[Node any] <span class="keyword">interface</span> &#123;</span><br><span class="line">Nodes() (from, to Node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点在这里，对泛型图类的类型约束列表中，存在相互引用</span></span><br><span class="line"><span class="comment">// 即限制了NodeConstraint的泛型类型(Edges返回的切片边类型)必须满足另一个EdgeConstraint约束</span></span><br><span class="line"><span class="comment">// EdgeConstraint 的泛型类型(Nodes返回的节点类型)必须满足NodeConstraint</span></span><br><span class="line"><span class="comment">// 即将两个接口约束相互关联了起来</span></span><br><span class="line"><span class="keyword">type</span> Graph[Node NodeConstraint[Edge], Edge EdgeConstraint[Node]] <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建图，由于约束本身也是泛型，所以看起来复杂一些</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span>[<span class="title">Node</span> <span class="title">NodeConstraint</span>[<span class="title">Edge</span>], <span class="title">Edge</span> <span class="title">EdgeConstraint</span>[<span class="title">Node</span>]] <span class="params">(nodes []Node)</span> *<span class="title">Graph</span>[<span class="title">Node</span>, <span class="title">Edge</span>]</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求图最短路径的方法，由于New的时候，编译器已经检查过了。因此方法中不再需要复填Node/EdgeConstraint，直接使用类型参数即可。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Graph[Node, Edge])</span> <span class="title">ShortestPath</span><span class="params">(from, to Node)</span> []<span class="title">Edge</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>我们可以用以下Vertex和FromTo类来实例化Graph泛型类:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Edges</span><span class="params">()</span> []*<span class="title">FromTo</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FromTo <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ft *FromTo)</span> <span class="title">Nodes</span><span class="params">()</span> <span class="params">(*Vertex, *Vertex)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = graph.New[*Vertex, *FromTo]([]*Vertex&#123; ... &#125;)</span><br></pre></td></tr></table></figure><p>除了相互引用以外，类型约束还可以引用自身，比如定义类型自己的<code>Equal</code>函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找并返回e的下标，官方给出的写法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span>[<span class="title">T</span> <span class="title">interface</span></span> &#123; Equal(T) <span class="keyword">bool</span> &#125;](s []T, e T) <span class="keyword">int</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是等价写法</span></span><br><span class="line"><span class="keyword">type</span> Equaler[T any] <span class="keyword">interface</span> &#123; </span><br><span class="line">Equal(T) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找并返回e的下标</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span>[<span class="title">T</span> <span class="title">Equaler</span>[<span class="title">T</span>]]<span class="params">(s []T, e T)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go编译器会推导类型参数相互引用的合理性，这进一步提升了泛型的灵活性。</p><h4 id="8-函数参数类型推导"><a href="#8-函数参数类型推导" class="headerlink" title="8. 函数参数类型推导"></a>8. 函数参数类型推导</h4><p>回到前面的Print，该泛型函数的调用方式形如: <code>Print[int]([]int&#123;3,1,2&#125;)</code>，但前面的类型参数相互引用中提到，编译器需要支持一定的类型推导(type inference)能力，因此实际上大部分时候，我们都不需要显式指定类型参数，直接通过<code>Print([]int&#123;3,1,2&#125;)</code>调用即可，编译器会通过实参<code>[]int&#123;3,1,2&#125;</code>匹配<code>[]T</code>，推导出T为int。</p><p>这种根据泛型函数调用时传入的实参类型，推敲得到泛型函数类型参数的类型的能力就是函数参数类型推导。</p><p>Go类型推导基于底层的类型一致(type unification)机制，本质上来说是一套类型匹配机制，对了类型A和类型B:</p><ol><li>如果A，B均不包含类型参数，那么A和B一致当且仅当A和B相同</li><li>仅一方包含类型参数: 如A为<code>[]map[int]bool</code>，B为<code>[]T</code>，那么称A和B是类型一致的，并且此时T为<code>map[int]bool</code></li><li>双方都包含类型参数: 如A为<code>[]map[T1]bool</code>，B为<code>[]map[int]T2</code>，那么A B也是类型一致的，并且T1为<code>int</code>，T2为<code>bool</code></li></ol><p>Go对泛型函数的类型参数推导是在函数调用而不是实例化的时候发生的，并且函数类型参数推导本身不包含类型约束检查和形实参赋值检查(像普通函数调用的检查一样)，这些是在类型推导完成之后才开始的。类型推导分为两个阶段:</p><ol><li>第一阶段，忽略所有的无类型(untype)实参(如字面常量<code>5</code>)，先依次推导参数列表中其它的包含类型参数的形参，如果一个类型参数在形参中出现了多次，那么它每次匹配的类型必须是相同的。注: 对于函数的类型参数推导，编译器<strong>只能对出现在函数参数列表中的类型参数进行推导</strong>，而对于那些只用于函数体或函数返回值的类型参数，编译器是无法推导的。</li><li>第二阶段，再开始处理无类型实参的匹配，因为其对应形参中的类型参数，可能在第一遍的时候被推敲出来了，如果对应形参还没被推导出来，给无类型实参赋予默认类型(如<code>5</code>对应<code>int</code>)，再开始推导对应形参。</li></ol><p>分为两个阶段是为了延迟无类型实参的类型推导，使泛型对于无类型实参更友好易用。举个例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPair</span>[<span class="title">F</span> <span class="title">any</span>]<span class="params">(f1, f2 F)</span> *<span class="title">Pair</span>[<span class="title">F</span>]</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, 第一阶段完成后(F类型仍然未知)，开始给无类型实参赋予默认类型int，两次匹配均得到F为int，前后一致，推导完成，F为int</span></span><br><span class="line">NewPair(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, 第一阶段完成后，根据int64(2)推导得到F为int64，第二阶段时，所有无类型实参的类型都已经确定，推导完成，F为int64</span></span><br><span class="line"><span class="comment">// 如果不是两阶段推导，那么这种情况就无法被支持</span></span><br><span class="line">NewPair(<span class="number">1</span>, <span class="keyword">int64</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Failed，第一阶段完成后(F未知)，开始分别给无类型参数赋予默认值int和float64，F前后匹配两次的类型不一致，推导失败，编译器报错</span></span><br><span class="line">NewPair(<span class="number">1</span>, <span class="number">2.5</span>)</span><br></pre></td></tr></table></figure><h4 id="9-约束类型推导"><a href="#9-约束类型推导" class="headerlink" title="9. 约束类型推导"></a>9. 约束类型推导</h4><p>约束类型推导，提供了基于一个类型参数，推导出另一个类型参数的能力，通常应用在多个类型参数之间有关联时。如前面定义Graph泛型类时，用到了泛型接口约束:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NodeConstraint[Edge any] <span class="keyword">interface</span> &#123;</span><br><span class="line">Edges() []Edge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型接口约束允许定义泛型类型参数之间的关系，但是由于约束本身也是泛型的，因此对接口约束中的类型参数也需要推导，这个步骤发生在函数类型参数推导之后，具体的推导规则仍然是根据已知的具象的实参推导未知的类型参数。具体推导规则描述起来比较抽象，仍然以官方例子来说:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数字切片中所有元素翻倍并返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Double</span>[<span class="title">E</span> <span class="title">constraints</span>.<span class="title">Number</span>]<span class="params">(s []E)</span> []<span class="title">E</span></span> &#123;</span><br><span class="line">r := <span class="built_in">make</span>([]E, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">r[i] = v + v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MySlice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值是[]int，而不是MySlice</span></span><br><span class="line"><span class="keyword">var</span> V1 = Double(MySlice&#123;<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>为了<code>Double</code>函数更易用，我们需要为<code>Double</code>的参数即切片本身定义一个类型参数(这样才能定义相同类型的返回值)，但是我们同时需要约束这个切片的元素类型，因此这里需要定义泛型接口约束:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SC[E any] <span class="keyword">interface</span> &#123;</span><br><span class="line">[]E</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义泛型约束 SC[E]，并且约束E的类型为数字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoubleDefined</span>[<span class="title">S</span> <span class="title">SC</span>[<span class="title">E</span>], <span class="title">E</span> <span class="title">constraints</span>.<span class="title">Number</span>]<span class="params">(s S)</span> <span class="title">S</span></span> &#123;</span><br><span class="line"><span class="comment">// Note that here we pass S to make, where above we passed []E.</span></span><br><span class="line">r := <span class="built_in">make</span>(S, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">r[i] = v + v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MySlice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// V3的类型是MySlice</span></span><br><span class="line"><span class="keyword">var</span> V3 = DoubleDefined(MySlice&#123;<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>上例再一次说明了泛型接口约束存在的必要性，按照我的理解，泛型接口约束允许<strong>对一个类型分层次的约束，以及完成约束与约束之间的关联</strong>。回到对约束的类型推导上来，在<code>DoubleDefined</code>中，函数的类型参数推导没有办法推导<code>E</code>的类型(因为它没有出现在函数参数列表中)，它只能推导得到<code>S -&gt; MySlice</code>，这个时候就需要约束类型参数推导来完成剩下的工作了，<code>MySlice</code>是已知的具象的类型，从它对应的<code>SC[E]</code>约束开始推导，<code>SC[E]</code>类型列表中只有一个类型<code>[]E</code>，因此<code>MySlice</code>只能<code>[]E</code>类型一致，推出<code>E -&gt; int</code>。</p><p>约束的类型推导的时机在函数参数类型推导之后，但是仍然在约束检查之前。</p><h4 id="10-小结"><a href="#10-小结" class="headerlink" title="10. 小结"></a>10. 小结</h4><p>以上主要是简单归纳了Go泛型文档中，偏应用层面的一些特性，简单小结一下:</p><ol><li>和其它语言的泛型类似，本质是将类型参数化，支持函数泛型和类型泛型，但目前<a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#no-parameterized-methods">暂不支持方法泛型</a></li><li>通过基于接口的类型约束来描述和限制类型参数(bounded generic types)</li><li>类型约束对接口扩展了类型枚举、类型近似、类型联合等元素，用以支持运算符的泛型操作</li><li>类型约束对外描述类型参数所需实现的方法或允许的类型集</li><li>类型约束对内定义了类型参数所允许调用的方法和支持的操作</li><li>类型约束本身也可以泛型化，用以类型参数的相互引用或自引用</li><li>类型推导使得大部分时候调用方无需显式指定类型参数</li><li>本质上是编译期泛型，泛型类型的反射包括完整的编译时类型信息</li><li>不支持元编程、偏特化、变参等高级特性</li></ol><p>在大部分的设计取舍上，Go官方会优先考虑构建大型项目所必需的实用性(可读+易用)，类型约束不只是type checker，更是一层设计上不可缺少的契约层，尽可能地将大部分信息都明确地内聚到这层契约上。有时候为了实用性，Go会选择牺牲一定的灵活性，类型集约束就是一个例子。</p><p>这里顺便再提下类型集约束，它是把双刃剑，一方面很大程度解决了Go没有运算符重载的问题(这里并不是说有运算符重载就一定香，它带来的代码理解负担也需要慎重考虑)，但另一方面，类型集约束也带来了如下问题:</p><ol><li>打破了接口类型约束的封装，甚至允许将泛型约束”降级”为具体类型(只有一个类型的类型列表约束)</li><li>接口约束和类型列表约束两者组合可能定义出永远不能被实例化的约束</li><li>类型列表约束没有根治没有运算符重载的问题，还加了个预定义约束<code>comparable</code>补丁</li></ol><p>因此个人觉得，类型列表约束需要慎用，特别是对于自定义类型。</p><p>总的来说，这次的Go泛型可以说是众望所归，整体上还是比较实用易用。我已经有点跃跃欲试了，准备在实践中重写部分代码，增强复用性、扩展性以及运行性能。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2022.1.22 更新: 最近一年，Go泛型已经从草案，过渡到提案，并开始实现。&lt;a href=&quot;https://tip.golang.org/doc/go1.18&quot;&gt;Go1.18&lt;/a&gt;实现了初版泛型，最终方案相较之前的泛型草案，将&lt;strong&gt;类型列表约束(type list in constraint)&lt;/strong&gt;进一步丰富完善为&lt;strong&gt;类型集约束(type sets of constraints)&lt;/strong&gt;的概念，本文内容已随最新文档更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前我在&lt;a href=&quot;https://wudaijun.com/2019/05/programing-paradigm/&quot;&gt;编程范式游记&lt;/a&gt;中介绍了OOP中的子类化(subtype，也叫子类型多态subtype polymorphism)和泛型(generics，也叫参数多态parametric polymorphism或类型参数type parameters)，关于两者的区别和比较可以参考那篇文章，在其中我吐槽了Go目前对泛型支持的匮乏，Go泛型最初在&lt;a href=&quot;https://github.com/golang/go/wiki/Go&quot;&gt;Go 2&lt;/a&gt;中讨论，目前已经在Go1.18中正式实现，随着Go泛型设计和实现的细节也越来越清晰，我们从最新的&lt;a href=&quot;https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md&quot;&gt;Go泛型文档&lt;/a&gt;来了解下Go泛型设计上有哪些考量和取舍。&lt;/p&gt;
&lt;p&gt;PS. 虽然Go官方文档仍然沿用社区惯用的”泛型(generics)”术语，由于主流语言都有自己不同的泛型支持，如Java基于&lt;strong&gt;编译期类型擦除&lt;/strong&gt;的泛型(伪泛型)，C++的&lt;strong&gt;图灵完备&lt;/strong&gt;的模板机制(支持模板元编程的真泛型)等，为了避免概念混淆，将Go泛型理解为&lt;strong&gt;类型参数(type parameters)&lt;/strong&gt;更精确，它不支持C++那样灵活的模板元编程，但比Java这种运行时擦除类型信息的补丁实现更优，另外，关于运算符泛型，Go也提出了一套新的解决方案。&lt;/p&gt;
&lt;h4 id=&quot;1-最简原型&quot;&gt;&lt;a href=&quot;#1-最简原型&quot; class=&quot;headerlink&quot; title=&quot;1. 最简原型&quot;&gt;&lt;/a&gt;1. 最简原型&lt;/h4&gt;&lt;p&gt;先从最简单的泛型定义开始:&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Define&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Print&lt;/span&gt;[&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;] &lt;span class=&quot;params&quot;&gt;(s []T)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; _, v := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; s &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		fmt.Println(v)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Call&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Print[&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;]([]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;语法上和其它语言泛型大同小异，泛型的本质是将&lt;strong&gt;类型参数化&lt;/strong&gt;，Go中用函数名后的&lt;code&gt;[]&lt;/code&gt;定义类型参数。以上声明对C++开发者来说非常亲切的(只是换了一种语法形式)，实际上这在Go中是错误的泛型函数声明，因为它没有指明类型参数约束(constraints)。&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://wudaijun.com/categories/golang/"/>
    
    
    <category term="golang" scheme="http://wudaijun.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>GS 测试规范实践</title>
    <link href="http://wudaijun.com/2020/08/gs-testing-practice/"/>
    <id>http://wudaijun.com/2020/08/gs-testing-practice/</id>
    <published>2020-08-14T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.615Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的博客中几次简单提及过给GS做测试，关于测试的必要性不用再多说，但在实际实践过程中，却往往会因为如下原因导致想要推进测试规范困难重重:</p><p>-. Q1: 写测试代码困难: 代码耦合重，各种相互依赖，全局依赖，导致写测试代码”牵一发而动全身”，举步维艰<br>-. Q2: 测试时效性低: 需求变更快，数值变更频繁，可能导致今天写好的测试代码，明天就”过时”了<br>-. Q3: 开发进度紧: 不想浪费过多时间来写测试代码，直接开发感觉开发效率更高</p><p>要想推进测试规范，上面的三个问题是必须解决的。这里简单聊聊我们在Golang游戏后端中的测试实践和解决方案。我们在GS中尝试的测试方案主要分为四种: 单元测试，集成测试，压力测试，以及模拟测试。</p><span id="more"></span><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测的优点是与业务逻辑和外部环境关联度最小，同时go test也很容易集成到CI/CD流程中。单元测试的缺点就是上面提到的Q1(耦合依赖问题)，对此，我们的解决方案是:</p><ol><li>持续重构，解耦降低依赖。有点废话，但是写易于测试的代码确实是一种修行</li><li>通过<a href="https://github.com/smartystreets/goconvey">goconvey</a>测试框架简化单元测试的编写</li><li>通过<a href="https://github.com/golang/mock">gomock</a> Mock掉接口依赖</li><li>实在Mock不掉的，通过<a href="https://github.com/agiledragon/gomonkey">gomonkey</a> Hack掉依赖，不过要记得禁用内联</li><li>对于一些复杂的单元测试，如涉及到发消息，创建玩家，启动定时器等，可以创建通用的Mock组件和环境，便于使用</li></ol><p>goconvey+gomonkey+gomock 三件套在实践中足够灵活强大，具体使用参考文档即可，比较简单，就不展示了。</p><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>集成测试我们又称之为用例测试，它是一种黑盒测试，以C/S交互协议为边界，站在客户端视角来测试服务器运行结果，黑盒测试本质上是消息流测试。它的优点是覆盖面广，网络层，集群管理，消息路由等细节都被会覆盖到。黑盒测试的难点在于易变性，协议变更，配置更新等都可能造成测试用例不可用，即上面提到的Q2(用例时效性问题)。对此，我们的实践是:</p><ol><li>将消息流测试离线化，即封装基本原语(Send,Wait,Expect,Select等)，化编译型为解释型，让测试用例可以通过类似配置文件的方式来描述，简化与服务器的交互细节，甚至理论做到交付给非技术人员使用。技术上除了对模拟客户端的封装外，主要是对json的处理: <a href="https://github.com/thedevsaddam/gojsonq">gojsonq</a>, <a href="https://github.com/nsf/jsondiff">jsondiff</a>, <a href="https://github.com/mkideal/pkg/tree/master/encoding/jsonx">jsonx</a></li><li>写可重入的测试用例，可重入即用例不应该依赖于当前服务器和用例机器人的初始状态，做到可重复执行</li><li>保存一份专用于用例测试策划配置快照，避免频繁的数值调整导致测试用例不可用。服务器和测试客户端都使用这份配置。即GS需要支持不同的配置源(如DB/File)</li></ol><p>以下是一个省掉很多细节的测试用例(yml格式描述):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 封装一个Function，从预定义变量varRole[n]中提取字段放到自定义变量中</span><br><span class="line">InitAttackCmds:</span><br><span class="line">  - find LoginAck.city.coord.X from varRole1 to varCity1X</span><br><span class="line">  - find LoginAck.city.coord.Z from varRole1 to varCity1Z</span><br><span class="line">  - find LoginAck.city.cityID from varRole1 to varCity1ID</span><br><span class="line"></span><br><span class="line"># 单个测试用例</span><br><span class="line">AttackPersonCityWinTest:</span><br><span class="line">  # 创建两个Robot，以Rbt1 Rbt2 标识</span><br><span class="line">  - newrobot 2</span><br><span class="line">  # 此时机器人已经登录完成，初始化自定义变量</span><br><span class="line">  - call InitAttackCmds</span><br><span class="line">  # 获取Rbt1初始化城防值</span><br><span class="line">  - Rbt1 send CityDefenseReq &#123;&#125;</span><br><span class="line">  # wait 后面的消息支持json局部字段比较(包含匹配)</span><br><span class="line">  - Rbt1 wait CityDefenseAck &#123;isCombustion:false&#125;</span><br><span class="line">  - Rbt1 find cityDefense from varLastAck to varCityDefensePreVal</span><br><span class="line">  # Rbt2 向 Rbt1 城池行军</span><br><span class="line">  - Rbt2 send NewTroopReq &#123;&quot;Action&quot;:1,&quot;Soldiers&quot;:&#123;&quot;11211001&quot;:500,&quot;11211301&quot;:500&#125;,&quot;EndCoord&quot;:&#123;&quot;X&quot;:%v,&quot;Z&quot;:%v&#125;,&quot;Mission&quot;:&#123;&quot;IsCampAfterHunt&quot;:false,&quot;IsRally&quot;:false&#125;,&quot;TargetID&quot;:%v&#125; varCity1X varCity1Z varCity1ID</span><br><span class="line">  - Rbt2 wait NewTroopAck &#123;errCode:0,action:1&#125;</span><br><span class="line">  # 防守失败后被烧城</span><br><span class="line">  - Rbt1 wait CombustionStateNtf &#123;isCombustion:true&#125;</span><br><span class="line">  - Rbt1 find cityDefense from varLastAck to varCityDefensePostVal</span><br><span class="line">  # 掉城防值</span><br><span class="line">  - should varCityDefensePostVal &lt; varCityDefensePreVal</span><br></pre></td></tr></table></figure><h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><p>压力测试也是黑盒测试的一种，它的目标是放大服务器的性能问题以及并发状态下的正确性问题。我在<a href="https://wudaijun.com/2019/09/gs-pressure-test/">如何给GS做压测</a>中简单地阐述过压测的一些注意事项。简单来说，用例测试注重特例和自动化，而压力测试注重随机和覆盖率。</p><h3 id="模拟测试"><a href="#模拟测试" class="headerlink" title="模拟测试"></a>模拟测试</h3><p>模拟测试是指通过类似console的方式来模拟客户端，它的功能主要分为两部分:</p><ol><li>动态构造消息并返回响应数据</li><li>支持一些简单的GM，如查看/修改自身数据</li></ol><p>它最大的优点在于灵活性，主要有两个作用:</p><ol><li>服务器新功能开发完成进行快速自测验证(脱离客户端)，提升开发效率</li><li>出现某些疑似服务器的BUG时，登录已有角色进行数据验证和Debug</li></ol><p>以下是我们的模拟测试的样子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注: FC[...]# 为输入行，其余为输出行    &quot;&#x2F;&#x2F;...&quot;表示省略消息具体内容</span><br><span class="line">FakeClient connect successed</span><br><span class="line">FC[NotAuth]# auth test</span><br><span class="line">send msg: AuthReq:type:&quot;anonymous&quot; passport:&quot;user_fakeclienttest&quot; password:&quot;user_fakeclienttest&quot;</span><br><span class="line">recv msg: AuthAck &#x2F;&#x2F;... </span><br><span class="line">FC[Authed:281474976712031]#</span><br><span class="line">FC[Authed:281474976712031]# char login 11</span><br><span class="line">send msg: LoginReq: &#x2F;&#x2F; ...</span><br><span class="line">recv msg: LoginAck playerID:27113 &#x2F;&#x2F; ...</span><br><span class="line">FC[Logined:27113]#</span><br><span class="line">FC[Logined:27113]#send HeartBeatReq &#123;ClientTs:111&#125;</span><br><span class="line">send msg: HeartBeatReq:clientTs:111 </span><br><span class="line">recv msg: HeartBeatAck clientTs:111 serverTs:1597664509306</span><br><span class="line">FC[Logined:27113]#</span><br><span class="line">FC[Logined:27113]# self all</span><br><span class="line">&#123;&quot;ID&quot;:27113,&quot;name&quot;:&quot;Newbie 27113&quot;, &#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>集成测试，压力测试，模拟测试，核心都需要一个模拟客户端，因此完全可以构建一套通用的fakeclient逻辑，包含基础网络通信，登录流程，数据状态同步等等。比如我们还基于fakeclient搭建了用于监控线上服务器可用性的监控机器人。</p><p>前面分别提到Q1，Q2的解决方案，至于Q3，我们的经验是，同学们之所以不愿意写测试，大部分原因都是测试框架还不够完善易用。另外，应该达成共识的是，开发效率并不只算单方面当前的开发时间，还应该包括客户端联调，QA验证反馈，后续重构负担等的时间，从这个角度来说，良好的测试规范起到的作用毋容置疑。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前的博客中几次简单提及过给GS做测试，关于测试的必要性不用再多说，但在实际实践过程中，却往往会因为如下原因导致想要推进测试规范困难重重:&lt;/p&gt;
&lt;p&gt;-. Q1: 写测试代码困难: 代码耦合重，各种相互依赖，全局依赖，导致写测试代码”牵一发而动全身”，举步维艰&lt;br&gt;-. Q2: 测试时效性低: 需求变更快，数值变更频繁，可能导致今天写好的测试代码，明天就”过时”了&lt;br&gt;-. Q3: 开发进度紧: 不想浪费过多时间来写测试代码，直接开发感觉开发效率更高&lt;/p&gt;
&lt;p&gt;要想推进测试规范，上面的三个问题是必须解决的。这里简单聊聊我们在Golang游戏后端中的测试实践和解决方案。我们在GS中尝试的测试方案主要分为四种: 单元测试，集成测试，压力测试，以及模拟测试。&lt;/p&gt;</summary>
    
    
    
    <category term="gameserver" scheme="http://wudaijun.com/categories/gameserver/"/>
    
    
    <category term="gameserver" scheme="http://wudaijun.com/tags/gameserver/"/>
    
  </entry>
  
  <entry>
    <title>编程语言杂记</title>
    <link href="http://wudaijun.com/2020/04/language-mindmap/"/>
    <id>http://wudaijun.com/2020/04/language-mindmap/</id>
    <published>2020-04-24T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.615Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/image/202004/language.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/assets/image/202004/language.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="mindmap" scheme="http://wudaijun.com/categories/mindmap/"/>
    
    
    <category term="mindmap" scheme="http://wudaijun.com/tags/mindmap/"/>
    
  </entry>
  
  <entry>
    <title>初识 Rust</title>
    <link href="http://wudaijun.com/2020/02/rust-basic/"/>
    <id>http://wudaijun.com/2020/02/rust-basic/</id>
    <published>2020-02-15T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.614Z</updated>
    
    <content type="html"><![CDATA[<p>之前被同事安利了很多次Rust，周末没事去<a href="https://kaisery.github.io/trpl-zh-cn/title-page.html">Rust官方文档</a>学习了下，记录一些对Rust语言粗浅理解。</p><h3 id="一-所有权系统"><a href="#一-所有权系统" class="headerlink" title="一. 所有权系统"></a>一. 所有权系统</h3><p>要说Rust语言的核心优势，应该就是运行效率+内存安全了，这两者都与其独树一帜的所有权系统有关。要谈所有权系统，GC是个不错的切入点，众所周知，编程语言GC主要包含两种: 手动GC和自动GC，它们各有利弊，总的来说是运行效率和内存安全之间的权衡取舍。而Rust则尝试两者兼顾，Rust的GC，我将其理解为半自动GC或编译期GC，即开发者配合编译器通过所有权约束来明确变量的生命周期，这样Rust在编译期就已经知道内存应该何时释放，不需要运行时通过复杂的<a href="https://wudaijun.com/2017/12/gc-study/">GC算法</a>去解析变量的引用关系，也无需像C/C++让开发者对各种内存泄露、越界访问等问题如履薄冰。这也是Rust敢号称可靠的系统级编程语言，运行时效率叫板C/C++的底气来源。</p><span id="more"></span><p>Rust GC的核心就是所有权系统，它基于以下事实:</p><ol><li>编译器能够解析局部变量的生命周期，正确管理栈内存的收缩扩张</li><li>堆内存最终都是通过栈变量来读取和修改</li></ol><p>那么，我们能否让堆内存管理和栈内存管理一样轻松，成为编译期就生成好的指令呢？Rust就是沿着这个思路走的，它将堆内存的生命周期和栈变量绑定在一起，当函数栈被回收，局部变量失效时，其对应的堆内存也会被回收。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                               <span class="comment">// 此作用域已结束，</span></span><br><span class="line">                                <span class="comment">// s 不再有效</span></span><br></pre></td></tr></table></figure><p>如代码所示，局部变量s和对应的字符串堆内存绑定在了一起，称s对这块堆内存具备所有权，当s无效时，对应String堆内存也会回收。编译器知道s的作用域，也就自然知道何时执行对String执行回收。</p><p>Rust所有权系统的核心规则如下:</p><ol><li>Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。</li><li>值有且只有一个所有者。</li><li>当所有者（变量）离开作用域，这个值将被丢弃。</li></ol><p>规则需要简单，要达成这套规则的完备性，还需要其它系统方方面面的协助和完善。下面展开聊聊。</p><h4 id="1-控制权转移"><a href="#1-控制权转移" class="headerlink" title="1. 控制权转移"></a>1. 控制权转移</h4><p>当发生局部变量赋值，如执行 <code>let s = String::from(&quot;big str&quot;); let s1 = s;</code> 时，Rust要么执行深拷贝，代价是运行时开销，要么浅拷贝，代价是s和s1只能有其中一个对String有所有权(否则会导致对堆内存的二次回收)。Rust选择了第二种方案，即s1拥有String的所有权，s在赋值给s1后不再有效，这之后对s的访问将会导致编译错误。在Rust中，这叫做<strong>控制权转移</strong>，此时也称<code>let s1 = s;</code>是<strong>转移语义</strong>，在Rust中，变量与值的交互方式分为以下几种:</p><ol><li>移动(Move)语义: 浅拷贝，且会发生控制权转移，这是Rust的默认行为</li><li>克隆(Clone)语义: 深拷贝，通过<strong>显式</strong>调用clone()来避免控制权转移，如 <code>let s1 = s.clone();</code>，如此s1和s均可继续使用</li><li>复制(Copy)语义: 浅拷贝，主要针对值语义这类浅拷贝安全的场景，Rust默认为整型、布尔、字符、浮点、以及元组(当且仅当其包含的类型也都实现Copy的时候)实现了复制语义，因此对于<code>let a = 5; let b = a;</code>，不需要显式Clone，也不会发生控制转移，a和b可继续使用</li><li>引用(Borrowing)语义: 也叫借用语义，Rust引用类似其它语言的指针，Rust创建引用的过程也称为借用，它允许你使用值但不获取其所有权</li></ol><p>Clone是比Copy更基础的概念，对支持Copy语义的对象，它必然也是支持Clone的(值语义的浅拷贝就是它的深拷贝)。实现上来说，Clone，Copy均是Rust提供的trait(类似OOP接口，但可包含默认实现，后面Rust OOP编程中再详说)，其中Clone trait依赖Copy trait，简单来说: 所有想要实现Copy trait的类，都需要同时实现Clone trait。这样从实现层保证了所有可Copy的对象，必然是可Clone的。</p><p>小结下Copy和Clone的区别和联系:</p><ul><li>Clone是显式的，Rust不会在任何地方自动调用clone()执行深拷贝。Copy是隐式的，编译期识别到Copy语义对象的复制时，会自动执行简单浅拷贝，并且不会发生控制转移</li><li>Clone是可重写的，各个类型可以自定义自己的clone()方法。Copy是不可重写的，因为编译器直接执行栈内存拷贝就行了，如果某个类型需要重写Copy，那么它就不应该是Copy语义的</li><li>支持Copy语义的类型必然支持Clone语义</li></ul><p>下面这个例子进一步说明几种赋值语义，引用语义的细节将单独在下一节展开讨论。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// === Case1: 移动 ===</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span> &#123;</span><br><span class="line">    part: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = MyStruct &#123;part: <span class="number">123</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> b = a;</span><br><span class="line">    <span class="comment">// 编译错误: a的数据控制权转移到了b，a将无法再被使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, i.part, j.part)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// === Case2: 克隆 ===</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span> &#123;</span><br><span class="line">    part: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Clone trait</span></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Clone</span> <span class="keyword">for</span> MyStruct &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">     <span class="comment">// 等价于 MyStruct &#123; part: self.part &#125;，因为i32是满足复制语义的(浅拷贝即深拷贝)</span></span><br><span class="line">        MyStruct &#123; part: <span class="keyword">self</span>.part.clone() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = MyStruct &#123;part: <span class="number">123</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> b = a.clone();<span class="comment">// 显式指明clone()，执行深拷贝</span></span><br><span class="line">    <span class="comment">// OK. 之后a和b都具有各自独立的数据所有权，因此均可使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, a.part, b.part)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// === Case3: 复制 ===</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// derive是Rust中的属性，类似类型注解的概念</span></span><br><span class="line"><span class="comment">// #[derive(Copy, Clone)] 表示在 MyStruct 上实现Copy，Clone两个trait，并使用这两个trait的默认实现</span></span><br><span class="line"><span class="comment">// Clone trait默认实现会逐个调用struct的字段的clone()方法来实现深拷贝，类似前面Case2手动重写的clone()方法</span></span><br><span class="line"><span class="comment">//            如果有字段未实现Clone trait(比如包含另一个自定义Struct)，则编译错误</span></span><br><span class="line"><span class="comment">// Copy trait不需要也不允许重写，如果有字段未实现Copy trait(比如包含String字段)，同样会触发编译错误</span></span><br><span class="line"><span class="comment">// 对于MyStruct而言，由于它实现了Copy trait，因此它的clone()方法完全可以直接写成:</span></span><br><span class="line"><span class="comment">// fn clone(&amp;self) -&gt; Self &#123;</span></span><br><span class="line"><span class="comment">// *self</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="meta">#[derive(Clone, Copy)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span> &#123;</span><br><span class="line">    part: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = MyStruct &#123;part: <span class="number">123</span>&#125;;</span><br><span class="line">    <span class="comment">// 等价于 let mut b = a.clone();</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> b = a;</span><br><span class="line">    b.part = <span class="number">456</span>;</span><br><span class="line">    <span class="comment">// OK. a和b具有独立的数据所有权</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, a.part, b.part)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// === Case4: 引用 ===</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"><span class="keyword">let</span> a = MyStruct&#123;part: <span class="number">123</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &amp;a;</span><br><span class="line"><span class="comment">// OK. b只是引用了a，并不会发生控制权转移</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, a.part, b.part)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust编译器会识别和检查变量类型是否实现或调用了指定trait，从而决定变量赋值是什么语义，以确定控制权归属。</p><h4 id="2-使用引用来避免控制权转移"><a href="#2-使用引用来避免控制权转移" class="headerlink" title="2. 使用引用来避免控制权转移"></a>2. 使用引用来避免控制权转移</h4><p>按照局部变量赋值的控制权转移规则，函数返回值和函数参数的隐式赋值也会导致控制权转移:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用calculate_length后，s1的控制权转移给了函数实参，在这之后s1就失效了</span></span><br><span class="line">        <span class="comment">// 为了后续能够继续访问String数据，需要通过返回值将控制权又转移回来</span></span><br><span class="line">        <span class="keyword">let</span> (s2, len) = calculate_length(s1); </span><br><span class="line">        <span class="comment">// 这里就不能继续访问s1了，只能使用s2</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: <span class="built_in">String</span>) -&gt; (<span class="built_in">String</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> length = s.len();</span><br><span class="line">        (s, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在控制权转移规则下，这种控制权转来转去的方式非常麻烦。这种情况下，更合适的做法是使用引用，在不转移控制权的前提下传递参数，但这里我们以另一个函数<code>first_word</code>为例，该函数求字符串内空格分隔的第一个单词:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first_word 通过引用借用了 s1，不发生控制权转移，函数返回后也不会回收形参s指向的值</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> word = first_word(&amp;s);</span><br><span class="line">    s.clear();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the first word is: &#123;&#125;&quot;</span>, word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选用<code>fist_word</code>是因为它展示了Rust引用的另一个有意思的特性。由于<code>first_word</code>返回的引用结果是基于引用参数的局部引用，因此当main调用<code>s.clear()</code>时，事实上也导致word引用失效了，导致得到非预期的结果。这在其它语言是指针/引用带来的难点之一，即要依靠开发者去解析内存引用关系，确保对内存的修改不会有非预期的副作用。而在Rust中，上面的代码不会通过编译！</p><p>和变量一样，Rust中的引用分为可变引用和不可变引用，可变引用需要在可变变量的基础上再显式声明: 如<code>let r = &amp;mut s;</code> Rust编译器会想尽办法保证<strong>引用的两大原则</strong>:</p><ol><li>在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用</li><li>引用必须总是有效的 (例如函数返回一个局部变量的引用将会得到编译错误)</li></ol><p>结合上面的规则，<code>s.clear</code>需要清空string，因此它会尝试获取s的一个可变引用(函数原型为:<code>clear(&amp;mut self)</code>)，而由于s已经有一个不可变引用word，这破坏了规则1，因此编译器会报错。</p><p>对于规则2，编译器的<strong>借用检查器</strong>会比较引用和被引用数据的生命周期，确保不会出现悬挂引用，如以下代码不会编译通过:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// rust不允许存在空值，确切地说是不允许使用空值，这里只是声明r，在第一次使用r前必须先初始化它，否则编译器会报错</span></span><br><span class="line">    <span class="keyword">let</span> r;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">        r = &amp;x;</span><br><span class="line">    &#125; <span class="comment">// 这之后 r 引用的 x 已经脱离作用域失效了，而 r 还在有效作用域内，继续访问 r 将会导致非预期结果</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上对引用的限制，有个非常显著的好处就是避免并发数据竞争问题:</p><ol><li>两个或更多指针同时访问同一数据</li><li>至少有一个指针被用来写入数据</li><li>没有同步数据访问的机制</li></ol><p>Rust可以在编译期就避免大部分的数据竞争！</p><h4 id="3-生命周期注解"><a href="#3-生命周期注解" class="headerlink" title="3. 生命周期注解"></a>3. 生命周期注解</h4><p>有Rust编译器的殚精竭虑，开发者就能安全使用这套所有权系统而高枕无忧了么，当然不是，编译器所知也仅限于编译期就能获得的信息，比如以下代码:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>(x: &amp;<span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = longest(string1.as_str(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码无法通过编译，因为longest函数的参数和返回值都是引用，编译器无法获悉函数返回的引用是来自于x还是来自于y(这是运行时的东西)，那么前面说的借用检查器也就无法通过分析作用域保证引用的有效性了。</p><p>这个时候就需要建立一套额外的规则来辅助借用检查器，将本来应该在运行时决议的事情放到编译器来完成，Rust把这套规则叫做<strong>生命周期注解</strong>，生命周期注解本身不影响引用的生命周期，它用来指定函数的引用参数和引用返回值之间的生命周期对应关系，这样编译器就可以按照这种关系进行引用生命周期推敲，生命周期注释的语法和泛型类似(这也是比较有意思的一点，将引用生命周期像类型一样来抽象):</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#x27;a 和泛型中的T一样，这里的注解表示:  &#x27;a 的具体生命周期等同于 x 和 y 的生命周期中较小的那一个</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是一些例子，说明Rust编译器是如何依靠注解来保证引用的有效性的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例1 </span></span><br><span class="line"><span class="comment">// 根据longest的生命周期注解，result的生命周期应该等于string1,string2中较短的那个</span></span><br><span class="line"><span class="comment">// 而这里result的生命周期明显大于string2，因此借用检查器会报错</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> string2 = <span class="built_in">String</span>::from(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        result = longest(string1.as_str(), string2.as_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2</span></span><br><span class="line"><span class="comment">// 这里的result虽然早于string2声明，但由于Rust不能使用未赋值的变量，因此result的生命周期其实是从第一次赋值开始的</span></span><br><span class="line"><span class="comment">// 从而满足longest引用返回值生命周期&lt;=任一引用参数生命周期，能够正常运行</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> result;</span><br><span class="line">        <span class="keyword">let</span> string2 = <span class="built_in">String</span>::from(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        result = longest(string1.as_str(), string2.as_str());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例3</span></span><br><span class="line"><span class="comment">// 如果我们将longest改成这样，它将不能通过编译</span></span><br><span class="line"><span class="comment">// 因为编译器看到了longest函数返回了y，然而生命周期注解中，输入引用y和返回值引用是两个独立的生命周期，互不关联。编译器觉得自己被欺骗了。</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">&#x27;a</span>,<span class="symbol">&#x27;b</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">&#x27;b</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生命周期注解也可用于结构体中，用于声明结构体与其字段的生命周期关系:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个标注意味着 ImportantExcerpt 的实例不能比其 part 字段中的引用存在的更久</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">    <span class="comment">// 如果part是String的引用，则会编译错误，因为String拥有自己数据的所有权</span></span><br><span class="line">    <span class="comment">// 生命周期注解只用来标注引用与引用间的生命周期关系(以保证引用的有效性)，而不能用于强行关联两个独立的生命周期</span></span><br><span class="line">    <span class="comment">// part: &#x27;a String,</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> i = ImportantExcerpt &#123; part: <span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 编译错误: 结构体实例i的生命周期比其引用字段part所引用的String s更长，违反了生命周期注解约束</span></span><br><span class="line">        <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> part = s.as_str();</span><br><span class="line">        <span class="comment">// 编译成功: 这里part是字面量的不可变引用，而字面量存储二进制程序的特定位置，因此满足生命周期注解约束</span></span><br><span class="line">        <span class="comment">// let part = &quot;123456&quot;;</span></span><br><span class="line">        </span><br><span class="line">        i.part = part;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i.part)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-智能指针"><a href="#4-智能指针" class="headerlink" title="4. 智能指针"></a>4. 智能指针</h4><p>前面讨论的控制权转移(确保一个值只有一个所有者，它负责这个值的回收)，引用(也就是指针，用于避免不必要的控制权转移)，生命周期注解(用于协助编译期保证引用的有效性)，主要都是围绕栈内存来的，只有String是个特例，它的实际内存会分配在堆上，以满足可变动态长度字符串的需求。在Rust中，栈内存和堆内存是被明确指定和分配的，Rust开发者通常会在出现以下情况时考虑用堆:</p><ol><li>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候: 比如在String，链表</li><li>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候</li><li>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候</li></ol><p>在Rust中，有如下几种指针:</p><ol><li><code>Box&lt;T&gt;</code>: 运行将数据分配在堆上，留在栈上的是指向堆数据的指针。<code>Box&lt;T&gt;</code>会在智能指针作用域结束时回收对应堆内存。<code>Box&lt;T&gt;</code>本身的是移动语义的，类似C++ <code>auto_ptr</code>。<code>Box&lt;T&gt;</code>与Rust引用的区别在于，前者指向的是堆内存，因此总能保证是有效的，而后者通常指向的是栈内存，因此需要借用检查器，生命周期注解等机制来确保引用是有效的。</li><li><code>Rc&lt;T&gt;</code>: <code>Rc&lt;T&gt;</code>类似C++<code>shared_ptr</code>，基于引用计数而非控制权+作用域来回收堆内存，但<code>Rc&lt;T&gt;</code>对共享数据是只能读的(仍然受限于借用器检查，用于避免数据竞争)。<code>Rc&lt;T&gt;</code>默认也是移动语义的，可以调用<code>Rc::Clone(rc)</code>方法(比<code>rc.clone()</code>方法更轻量)以获得独立的<code>Rc&lt;T&gt;</code>并增加引用计数。</li><li><code>RefCell&lt;T&gt;</code>: 能够基于不可变值修改其内部值，对<code>RefCell&lt;T&gt;</code>的借用检查将<strong>发生运行时而非编译期</strong>。如以下代码会导致运行Panic:</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RefCell&lt;T&gt;例子，以下代码会编译成功，但是运行Panic</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = RefCell::new(<span class="number">123</span>);</span><br><span class="line">    <span class="keyword">let</span> a = x.borrow();</span><br><span class="line">    <span class="keyword">let</span> b = x.borrow();</span><br><span class="line">    <span class="comment">// OK. 运行时借用检查允许多个不可变引用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, a, b);</span><br><span class="line">    <span class="comment">// Panic here! 运行时检查发现同时存在可变引用和不可变引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> c = x.borrow_mut();</span><br><span class="line">    *c = <span class="number">456</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RefCell&lt;T&gt;</code>在天生保守的Rust编译规则下，为开发者提供了更高的灵活性，但也需要承担更大的运行时风险。一个<code>RefCell&lt;T&gt;</code>的应用场景是，通过Mock将原本的外部IO行为(<code>&amp;self</code>参数的trait)，替换为内部数据变更(<code>&amp;self</code>参数不变，但MockStruct通过持有<code>RefCell&lt;T&gt;</code>实现内部数据可变性)。</p><p>另外，由于<code>Rc&lt;T&gt;</code>支持对相同数据同时存在多个所有者，但是只能读数据，而<code>RefCell&lt;T&gt;</code>允许在不可变语义下实现内部可变性，那么<code>Rc&lt;RefCell&lt;T&gt;&gt;</code>就可以实现基于引用计数，可存在多个具有读写数据权限的智能指针(完整版C++ <code>shared_ptr</code>):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x &#x3D; &amp;Rc::new(RefCell::new(123));</span><br><span class="line">    let a &#x3D; Rc::clone(x);</span><br><span class="line">    let b &#x3D; Rc::clone(x);</span><br><span class="line">    let c &#x3D; Rc::clone(x);</span><br><span class="line">    *b.borrow_mut() &#x3D; 456;</span><br><span class="line">    *c.borrow_mut() &#x3D; 789;</span><br><span class="line">    &#x2F;&#x2F; Output:</span><br><span class="line">    &#x2F;&#x2F; RefCell &#123; value: 789 &#125;, RefCell &#123; value: 789 &#125;, RefCell &#123; value: 789 &#125;</span><br><span class="line">    println!(&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;, a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h4><p>先总结下前面提到的Rust的各种机制是如何配合所有权系统来实现通过栈内存来管理堆内存，做到运行时零GC负担的:</p><ol><li>浅拷贝对象: 如i32，float，plain struct，默认直接执行栈拷贝，不涉及控制权转移，和常规语言无二</li><li>深拷贝对象: 比如String，通过控制权转移来保证单所有者，在所有者退出作用域时，通过Drop trait确保数据被正确回收</li><li>引用: 本质只是指针地址，借助编译器的借用检查器来避免数据竞态并保证引用的有效性，有时还需要开发者通过生命周期注解进行协助</li><li>智能指针: 和String类似，也是深拷贝对象，但提供了更灵活的内存控制，包括避免深拷贝和控制权转移，动态大小，引用计数共享数据，内部可变性等</li></ol><p>总之，Rust编译器是天生保守的，它会尽全力拒绝那些可能不正确的程序，Rust确实能在编译期检查到很多大部分语言只能在运行期暴露的错误，这是Rust最迷人的地方之一。但是，与此同时，Rust编译器也可能会拒绝一些正确的程序，此时就需要如生命周期注解，<code>Rc&lt;T&gt;</code>等工具来辅助编译器，甚至通过<code>RefCell&lt;T&gt;</code>，unsafe等方案来绕过编译器检查。把<strong>编译器做厚</strong>，把<strong>运行时做薄</strong>，是Rust安全且高效，能够立足于系统级编程语言的根本。</p><h3 id="二-函数式特性"><a href="#二-函数式特性" class="headerlink" title="二. 函数式特性"></a>二. 函数式特性</h3><p>我在<a href="https://wudaijun.com/2018/05/understand-functional-programing/">理解函数式编程</a>中提到，现在的语言不再受限于各种编程范式的约束，而是更偏实用主义，Rust也是这样的语言，它受函数式语言的影响颇深。</p><h4 id="1-函数是第一类对象"><a href="#1-函数是第一类对象" class="headerlink" title="1. 函数是第一类对象"></a>1. 函数是第一类对象</h4><p>函数可作为参数，返回值，动态创建，并且动态创建的函数具备捕获当前作用域上下文的能力，也就是闭包，提供标准库容器迭代器模式并支持开发者扩展等，这些都是如今大部分语言的标配，无需过多解释。</p><p>有一点需要提一下，Rust的闭包如果要捕获上下文的话，也要考虑到所有权转移的问题(转移，引用，可变引用)，并且Rust编译器会尝试自动推测你的闭包希望以那种方式来捕获环境。</p><h4 id="2-变量可变性"><a href="#2-变量可变性" class="headerlink" title="2. 变量可变性"></a>2. 变量可变性</h4><p>Rust中的变量默认是不可变的，但也支持通过<code>let mut x = 5;</code>声明可变变量。合理使用不可变变量能够利用编译器检查使代码易于推导，可重入，无副作用。</p><h4 id="3-模式匹配"><a href="#3-模式匹配" class="headerlink" title="3. 模式匹配"></a>3. 模式匹配</h4><p>模式匹配我最早在Erlang中接触，这个起初不是很适应的功能在用习惯之后，会发现它可以为程序提供更多对程序控制流的支配权，写出强大而简洁的代码。Rust也支持模式匹配:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">7</span>, y: <span class="number">2</span> &#125;; <span class="comment">// 构造一个Point值匹配给命名变量p</span></span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        Point &#123; x :<span class="number">0</span>, y&#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;case 1: &#123;&#125;&quot;</span>, y), <span class="comment">// 匹配p.x==0</span></span><br><span class="line">        Point &#123; x, y: <span class="number">0</span>..=<span class="number">2</span> &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;case 2: &#123;&#125;&quot;</span>, x), <span class="comment">// 匹配0&lt;=p.y&lt;=2</span></span><br><span class="line">        Point &#123; x: a, y: _ &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;case 3: &#123;&#125;&quot;</span>, a), <span class="comment">// 匹配其它情况，并将字段x的值赋给变量a</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> Point &#123;x: <span class="number">7</span>, y: b&#125; = p &#123; <span class="comment">// 匹配 x==7，并取出y值</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;case 4: &#123;&#125;&quot;</span>, b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-面向对象特性"><a href="#三-面向对象特性" class="headerlink" title="三. 面向对象特性"></a>三. 面向对象特性</h3><h4 id="1-Object"><a href="#1-Object" class="headerlink" title="1. Object"></a>1. Object</h4><p>Rust提供基本的结构体字段封装和字段访问控制(可见性)，并且允许在此之上扩展结构体方法及方法的可见性:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span> &#123;</span><br><span class="line">    x : <span class="built_in">i32</span>     <span class="comment">// 默认为私有字段</span></span><br><span class="line">    <span class="keyword">pub</span> name : <span class="built_in">String</span> <span class="comment">// 指定为公有字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> MyStruct &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">getx</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h4><p>传统OOP的继承(subclass)主要有两个作用，<strong>代码复用</strong> 和 <strong>子类化(subtype)</strong> ，如C++的继承就同时实现了这两点，继承是一把双刃剑，因为传统继承不只是有代码复用和子类化的功能，它还做到了字段复用，即对象父子内存模型的一致性，当引入对象内存模型之后，各种多重继承，菱形继承所带来的问题不堪其扰。<strong>虚基类</strong>，<strong>显式指定父类作用域</strong>或者干脆<strong>不允许多重继承</strong>等方案也是头痛医头，脚痛医脚。</p><p>近年兴起的新语言，如Golang就没有继承，它通过内嵌匿名结构体来实现代码复用，但丢失了dynamic dispatch，通过interface{}(声明式接口，隐式implement)来实现子类化，但也带来了运行时开销。</p><p>关于subclass, subtype, dynamic dispatch等概念，可以参考我之前的<a href="https://wudaijun.com/2019/05/programing-paradigm/">编程范式游记</a>)。</p><p>在Rust中，是通过trait来实现这两者的，trait本质上是<strong>实现式接口</strong>，用于对不同类型的相同方法进行抽象。Rust的trait有如下特性:</p><ol><li>trait是需要显式指明实现的</li><li>trait可以提供默认实现，但不能包含字段(部分subclass)</li><li>trait的默认实现可以调用trait中的其它方法，哪怕这些方法没有提供默认实现(dynamic dispatch)</li><li>trait可以用做参数或返回值用于表达满足该接口的类型实例抽象(subtype)</li><li>trait本身也可以定义依赖(supertrait)，如Copy trait依赖Clone trait</li><li>作为泛型约束时trait可通过+号实现拼接，表示同时满足多个接口</li></ol><p>以下代码简单展示了Rust trait的基本特性:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize_author</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125;...)&quot;</span>, <span class="keyword">self</span>.summarize_author())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Title</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">title</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> title: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize_author</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Title <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">title</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.title)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明等价于 pub fn notify&lt;T: Summary + Title&gt;(item: T) &#123;</span></span><br><span class="line"><span class="comment">// 即本质是bounded generic types的语法糖</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary + Title) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 new tweet: &#123;&#125;, &#123;&#125;&quot;</span>, item.title(), item.summarize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> t = Tweet &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">&quot;wudaijun&quot;</span>),</span><br><span class="line">        title: <span class="built_in">String</span>::from(<span class="string">&quot;study rust&quot;</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">&quot;rust is the best language&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        notify(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，Rust对OOP的支持是比较完善的，舍弃了继承和字段复用，通过trait来完成代码复用和子类化，避免了OOP继承的各种坑。</p><h3 id="四-泛型和元编程"><a href="#四-泛型和元编程" class="headerlink" title="四. 泛型和元编程"></a>四. 泛型和元编程</h3><p>Rust的泛型和元编程赋予语言更强大的灵活性。这里只列举个人目前学习到的一些要点。</p><p>Rust泛型的一些特性:</p><ol><li>模板泛型: 在编译期填充具体类型，实现单态化</li><li>支持枚举泛型: 如: <code>enum Option&lt;T&gt; &#123; Some(T), None, &#125;</code></li><li>Trait Bound: <code>fn notify(item: impl Summary) &#123;...</code> 等价于 <code>fn notify&lt;T: Summary&gt;(item: T) &#123;...</code> 等价于 <code>fn notify&lt;T&gt;(item: T) where T: Summary &#123;...</code></li><li>blanket implementations: 对实现了特定 trait 的类型有条件地实现方法，如标准库为任何实现了<code>Display</code> trait的类型实现了<code>ToString</code> trait: <code>impl&lt;T: Display&gt; ToString for T &#123;</code>。这意味着你实现了A trait，标准库/第三方库就可以为你实现B trait。这是trait和泛型的一种特殊结合，也是Rust trait和传统OOP不同的地方之一</li></ol><p>元编程能够生成代码的代码，如C++的模板由于其在预编译期处理，并且图灵完备，完全可以作为另一种语言来看待，它的执行结果就是另一种语言的代码。Rust的元编程通过宏来实现，宏的语法类似于这样:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.push($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码能将<code>let v: Vec&lt;u32&gt; = vec![1, 2, 3];</code>转换成:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">temp_vec.push(<span class="number">1</span>);</span><br><span class="line">temp_vec.push(<span class="number">2</span>);</span><br><span class="line">temp_vec.push(<span class="number">3</span>);</span><br><span class="line">temp_vec</span><br></pre></td></tr></table></figure><p>由于宏编程日常开发中使用较少，这里不再展开讨论。</p><h3 id="五-并发编程"><a href="#五-并发编程" class="headerlink" title="五. 并发编程"></a>五. 并发编程</h3><p>基于Rust本身系统级编程语言的定位，Rust标准库本身只提供对OS Thread的基础抽象，即运行时本身不实现<strong>轻量级线程</strong>及其调度器，以保持其运行时的精简高效。</p><p>Rust的所有权系统设计之初是为了简化运行时的内存管理，解决内存安全问题，而Rust作为系统级编程语言，并发自然也是绕不过去的传统难题，起初Rust觉得这是两个独立的问题，然而随着所有权系统的完善，Rust发现<strong>所有权系统也能解决一系列的并发安全问题</strong>。相较于并发领域佼佼者Erlang前辈的口号”任其崩溃(let it crash)”，Rust的并发口号也是不输分毫: “无畏并发(fearless concurrency)”。下面我们来看看Rust为何如此自信，Rust支持消息交互和共享内存两种并发编程范式。</p><h4 id="1-消息交互"><a href="#1-消息交互" class="headerlink" title="1. 消息交互"></a>1. 消息交互</h4><p>Rust消息交互CSP模型，但也与Go这类CSP语言有一些区别。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line">    <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个小例子有如下需要关注的细节:</p><ol><li>Rust 在创建 channel 时无需指定其大小，因为Rust Channel的大小是没有限制的，并且明确区分发送端和接收端，对channel的写入是永远不会阻塞的</li><li>Rust 在创建 channel 时也无需指定其类型，这是因为 tx 和 rx 是泛型对象，编译器会根据其实际发送的数据类型来实例化泛型(如这里的<code>std::sync::mpsc::Sender&lt;std::string::String&gt;</code>)，如果尝试对同一个 channel 发送不同类型，或者代码中没有调用<code>tx.send</code>函数都将会导致编译错误</li><li>Rust编译器本身会尝试推测闭包以何种方式捕获外部变量，但通常是保守的借用。这里 move 关键字强制闭包获取其使用的环境值的所有权，因此main函数在创建线程后对val和tx的任何访问都会导致编译错误</li><li><code>tx.send</code>也会导致val变量发生控制权转移，因此在新创建线程在<code>tx.send(val)</code>之后对val的任何访问也会导致编译错误</li><li>Rust通过Send trait标记类型所有权是否能在线程间传递(只是标记，无需实现)，几乎所有Rust类型的所有权都是Send的(除了像<code>Rc&lt;T&gt;</code>这种为了性能刻意不支持的并发的，跨线程传递会导致编译错误。应该使用线程安全的<code>Arc&lt;T&gt;</code>)</li></ol><p>上面的3,4其实就是我们在并发编程常犯的错误：对相同变量的非并发安全访问，由于闭包的存在，使得这类”犯罪”的成本异常低廉。而Rust的所有权系统则巧妙地在编译器就发现了这类错误，因为变量所有权只会同时在一个线程中，也就避免了数据竞争。</p><h4 id="2-共享内存"><a href="#2-共享内存" class="headerlink" title="2. 共享内存"></a>2. 共享内存</h4><p>受Rust所有权系统的影响，Rust中的内存共享初看起来有点繁杂:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Mutex, Arc&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Arc::clone(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，这里面也有一些细节:</p><ol><li>和channel一样，<code>Mutex&lt;T&gt;</code>也是泛型的，并且只能通过<code>lock</code>才能得到其中的<code>T</code>值，确保不会忘记加锁</li><li>Mutex会在脱离作用域时，会自动释放锁，确保不会忘记释放锁</li><li>这里有多个线程需要共享Mutex的所有权，因此需要用到并发安全的引用计数智能指针<code>Arc&lt;T&gt;</code>(<code>RC&lt;T&gt;</code>不是线程安全的)</li></ol><h3 id="六-体会"><a href="#六-体会" class="headerlink" title="六 体会"></a>六 体会</h3><p>本文主要从所有权系统和编程范式的角度理解Rust，总的来说，这门语言给我的印象是很不错的。</p><p>从系统级编程语言的角度来说，它确实兼顾了安全和高效，这中间是Rust编译器在”负重前行”，其它语言的编译器更多关注语法正确性，而Rust编译器还会想尽办法分析和保证代码安全性，这也是所有权系统及其相关机制的本意，这些规则前期可能要多适应下，但遵循这些约束能够换来巨大的健壮性和运行效率收益。</p><p>从高级编程语言的角度来说，Rust从多种编程范式(过程式、函数式、面向对象、泛型、元编程等)中取其精华去其糟粕，属于编程范式融合得比较好的，比如要面向对象不要继承，要函数式编程也要控制流，可变性和性能，这让Rust具有强大的灵活性和抽象能力，在图形、音视频、Web/应用前后端等各个应用领域全面发力，包括对游戏服务器这类看重性能的应用场景而言，Rust也很有潜力。</p><p>同时，由于Rust本身的多编程范式融合，以及独有的所有权系统，初学者上手Rust学习成本还是比较高的。由于对Rust缺乏实践，本文更多还是提炼汇总，如果有合适的应用场景，倒是很愿意用Rust实践下，增强理解。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前被同事安利了很多次Rust，周末没事去&lt;a href=&quot;https://kaisery.github.io/trpl-zh-cn/title-page.html&quot;&gt;Rust官方文档&lt;/a&gt;学习了下，记录一些对Rust语言粗浅理解。&lt;/p&gt;
&lt;h3 id=&quot;一-所有权系统&quot;&gt;&lt;a href=&quot;#一-所有权系统&quot; class=&quot;headerlink&quot; title=&quot;一. 所有权系统&quot;&gt;&lt;/a&gt;一. 所有权系统&lt;/h3&gt;&lt;p&gt;要说Rust语言的核心优势，应该就是运行效率+内存安全了，这两者都与其独树一帜的所有权系统有关。要谈所有权系统，GC是个不错的切入点，众所周知，编程语言GC主要包含两种: 手动GC和自动GC，它们各有利弊，总的来说是运行效率和内存安全之间的权衡取舍。而Rust则尝试两者兼顾，Rust的GC，我将其理解为半自动GC或编译期GC，即开发者配合编译器通过所有权约束来明确变量的生命周期，这样Rust在编译期就已经知道内存应该何时释放，不需要运行时通过复杂的&lt;a href=&quot;https://wudaijun.com/2017/12/gc-study/&quot;&gt;GC算法&lt;/a&gt;去解析变量的引用关系，也无需像C/C++让开发者对各种内存泄露、越界访问等问题如履薄冰。这也是Rust敢号称可靠的系统级编程语言，运行时效率叫板C/C++的底气来源。&lt;/p&gt;</summary>
    
    
    
    <category term="rust" scheme="http://wudaijun.com/categories/rust/"/>
    
    
    <category term="rust" scheme="http://wudaijun.com/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>Golang GC核心要点和度量方法</title>
    <link href="http://wudaijun.com/2020/01/go-gc-keypoint-and-monitor/"/>
    <id>http://wudaijun.com/2020/01/go-gc-keypoint-and-monitor/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.614Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-Go-GC-要点"><a href="#一-Go-GC-要点" class="headerlink" title="一. Go GC 要点"></a>一. Go GC 要点</h3><p>先来回顾一下GC的几个重要的阶段:</p><h4 id="Mark-Prepare-STW"><a href="#Mark-Prepare-STW" class="headerlink" title="Mark Prepare - STW"></a>Mark Prepare - STW</h4><p>做标记阶段的准备工作，需要停止所有正在运行的goroutine(即STW)，标记根对象，启用内存屏障，内存屏障有点像内存读写钩子，它用于在后续并发标记的过程中，维护三色标记的完备性(三色不变性)，这个过程通常很快，大概在10-30微秒。</p><h4 id="Marking-Concurrent"><a href="#Marking-Concurrent" class="headerlink" title="Marking - Concurrent"></a>Marking - Concurrent</h4><p>标记阶段会将大概25%(gcBackgroundUtilization)的P用于标记对象，逐个扫描所有G的堆栈，执行三色标记，在这个过程中，所有新分配的对象都是黑色，被扫描的G会被暂停，扫描完成后恢复，这部分工作叫后台标记(<a href="https://github.com/golang/go/blob/dev.boringcrypto.go1.13/src/runtime/mgc.go#L1817">gcBgMarkWorker</a>)。这会降低系统大概25%的吞吐量，比如<code>MAXPROCS=6</code>，那么GC P期望使用率为<code>6*0.25=1.5</code>，这150%P会通过专职(Dedicated)/兼职(Fractional)/懒散(Idle)三种工作模式的Worker共同来完成。</p><span id="more"></span><p>这还没完，为了保证在Marking过程中，其它G分配堆内存太快，导致Mark跟不上Allocate的速度，还需要其它G配合做一部分标记的工作，这部分工作叫辅助标记(mutator assists)。在Marking期间，每次G分配内存都会更新它的”负债指数”(gcAssistBytes)，分配得越快，gcAssistBytes越大，这个指数乘以全局的”负载汇率”(assistWorkPerByte)，就得到这个G需要帮忙Marking的内存大小(这个计算过程叫<a href="https://github.com/golang/go/blob/dev.boringcrypto.go1.13/src/runtime/mgc.go#L484">revise</a>)，也就是它在本次分配的mutator assists工作量(<a href="https://github.com/golang/go/blob/dev.boringcrypto.go1.13/src/runtime/mgcmark.go#L363">gcAssistAlloc</a>)。</p><h4 id="Mark-Termination-STW"><a href="#Mark-Termination-STW" class="headerlink" title="Mark Termination - STW"></a>Mark Termination - STW</h4><p>标记阶段的最后工作是Mark Termination，关闭内存屏障，停止后台标记以及辅助标记，做一些清理工作，整个过程也需要STW，大概需要60-90微秒。在此之后，所有的P都能继续为应用程序G服务了。</p><h4 id="Sweeping-Concurrent"><a href="#Sweeping-Concurrent" class="headerlink" title="Sweeping - Concurrent"></a>Sweeping - Concurrent</h4><p>在标记工作完成之后，剩下的就是清理过程了，清理过程的本质是将没有被使用的内存块整理回收给上一个内存管理层级(mcache -&gt; mcentral -&gt; mheap -&gt; OS)，清理回收的开销被平摊到应用程序的每次内存分配操作中，直到所有内存都Sweeping完成。当然每个层级不会全部将待清理内存都归还给上一级，避免下次分配再申请的开销，比如Go1.12对mheap归还OS内存做了<a href="https://ms2008.github.io/2019/06/30/golang-madvfree/">优化</a>，使用<a href="https://go-review.googlesource.com/c/go/+/135395/">NADV_FREE</a>延迟归还内存。</p><h4 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h4><p>在<a href="https://wudaijun.com/2018/01/go-scheduler/">Go调度模型</a>中我们已经提到，Go没有真正的实时抢占机制，而是一套协作式抢占(cooperative preemption)，即给G(groutine)打个标记，等待G在调用函数时检查这个标记，以此作为一个安全的抢占点(GC safe-point)。但如果其它P上的G都停了，某个G还在执行如下代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(numbers []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">     <span class="keyword">var</span> v <span class="keyword">int</span></span><br><span class="line">     <span class="keyword">for</span> _, n := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">         v += n</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add函数的运行时间取决于切片的长度，并且在函数内部是没有调用其它函数的，也就是没有抢占点。就会导致整个运行时都在等待这个G调用函数(以实现抢占，开始处理GC)，其它P也被挂起。这就是Go GC最大的诟病: GC STW时间会受到G调用函数的时机的影响并被延长，甚至如果某个G在执行无法抢占的死循环(即循环内部没有发生函数调用的死循环)，那么整个Go的runtime都会挂起，CPU 100%，节点无法响应任何消息，连正常停服都做不到。pprof这类调试工具也用不了，只能通过gdb，delve等外部调试工具来找到死循环的goroutine正在执行的堆栈。如此后果比没有被defer的panic更严重，因为那个时候的节点内部状态是无法预期的。</p><p>因此有Gopher开始倡议Go使用非协作式抢占(non-cooperative preemption)，通过堆栈和寄存器来保存抢占上下文，避免对抢占不友好的函数导致GC STW延长(毕竟第三方库代码的质量也是参差不齐的)。相关的Issue在<a href="https://github.com/golang/go/issues/24543">这里</a>。好消息是，<strong><a href="https://tip.golang.org/doc/go1.14">Go1.14</a>(目前还是Beta1版本，还未正式发布)已经支持异步抢占</strong>，也就是说:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单起见，没用channel协同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  time.Sleep(time.Millisecond)</span><br><span class="line">  runtime.GC()</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在Go1.14中终于能输出<code>OK</code>了。这个提了近五年的Issue: <a href="https://github.com/golang/go/issues/10958">runtime: tight loops should be preemptible #10958</a>前几天终于关闭了。不得不说，这是Go Runtime的一大进步，它不止避免了单个goroutine死循环导致整个runtime卡死的问题，更重要的是，它为STW提供了最坏预期，避免了GC STW造成了性能抖动隐患。</p><h3 id="二-Go-GC-度量"><a href="#二-Go-GC-度量" class="headerlink" title="二. Go GC 度量"></a>二. Go GC 度量</h3><h4 id="1-go-tool-prof"><a href="#1-go-tool-prof" class="headerlink" title="1. go tool prof"></a>1. go tool prof</h4><p>Go 基础性能分析工具，pprof的用法和启动方式参考<a href="https://wudaijun.com/2018/04/go-pprof/">go pprof性能分析</a>，其中的heap即为内存分配分析，go tool默认是查看正在使用的内存(<code>inuse_heap</code>)，如果要看其它数据，使用<code>go tool pprof --alloc_space|inuse_objects|alloc_objects</code>。</p><p>需要注意的是，go pprof本质是数据采样分析，其中的值并不是精确值，适用于性能热点优化，而非真实数据统计。</p><h4 id="2-go-tool-trace"><a href="#2-go-tool-trace" class="headerlink" title="2. go tool trace"></a>2. go tool trace</h4><p>go tool trace可以将GC统计信息以可视化的方式展现出来。要使用go tool trace，可以通过以下方式生成采样数据:</p><ol><li>API: <code>trace.Start</code></li><li>go test: <code>go test -trace=trace.out pkg</code></li><li>net/http/pprof: <code>curl http://127.0.0.1:6060/debug/pprof/trace?seconds=20</code></li></ol><p>得到采样数据后，之后即可以通过 <code>go tool trace trace.out</code> 启动一个HTTP Server，在浏览器中查看可视化trace数据:</p><p><img src="/assets/image/202001/trace-index.jpg" alt=""></p><p>里面提供了各种trace和prof的可视化入口，点击第一个View trace可以看到追踪总览:</p><p><img src="/assets/image/202001/trace-view.jpg" alt=""></p><p>包含的信息量比较广，横轴为时间线，各行为各种维度的度量，通过A/D左右移动，W/S放大放小。以下是各行的意义:</p><ul><li>Goroutines: 包含GCWaiting，Runnable，Running三种状态的Goroutine数量统计</li><li>Heap: 包含当前堆使用量(Allocated)和下次GC阈值(NextGC)统计</li><li>Threads: 包含正在运行和正在执行系统调用的Threads数量</li><li>GC: 哪个时间段在执行GC</li><li>ProcN: 各个P上面的goroutine调度情况</li></ul><p>除了<strong>View trace</strong>之外，trace目录的第二个<strong>Goroutine analysis</strong>也比较有用，它能够直观统计Goroutine的数量和执行状态:</p><p><img src="/assets/image/202001/trace-goroutines.jpg" alt=""></p><p><img src="/assets/image/202001/trace-goroutines2.jpg" alt=""></p><p>通过它可以对各个goroutine进行健康诊断，各种network,syscall的采样数据下载下来之后可以直接通过<code>go tool pprof</code>分析，因此，实际上pprof和trace两套工具是相辅相成的。</p><h4 id="3-GC-Trace"><a href="#3-GC-Trace" class="headerlink" title="3. GC Trace"></a>3. GC Trace</h4><p>GC Trace是Golang提供的非侵入式查看GC信息的方案，用法很简单，设置<code>GCDEBUG=gctrace=1</code>环境变量即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GODEBUG&#x3D;gctrace&#x3D;1 bin&#x2F;game</span><br><span class="line">gc 1 @0.039s 3%: 0.027+4.5+0.015 ms clock, 0.11+2.3&#x2F;4.0&#x2F;5.5+0.063 ms cpu, 4-&gt;4-&gt;2 MB, 5 MB goal, 4 P</span><br><span class="line">gc 2 @0.147s 1%: 0.007+1.2+0.008 ms clock, 0.029+0.15&#x2F;1.1&#x2F;2.0+0.035 ms cpu, 5-&gt;5-&gt;3 MB, 6 MB goal, 4 P</span><br><span class="line">gc 3 @0.295s 0%: 0.010+2.3+0.013 ms clock, 0.040+0.14&#x2F;2.1&#x2F;4.3+0.053 ms cpu, 7-&gt;7-&gt;4 MB, 8 MB goal, 4 P</span><br></pre></td></tr></table></figure><p>下面是各项指标的解释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">gc 1 @0.039s 3%: 0.027+4.5+0.015 ms clock, 0.11+2.3&#x2F;4.0&#x2F;5.5+0.063 ms cpu, 4-&gt;4-&gt;2 MB, 5 MB goal, 4 P</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通用参数</span><br><span class="line">gc 2: 程序运行后的第2次GC</span><br><span class="line">@0.147s: 到目前为止程序运行的时间</span><br><span class="line">3%: 到目前为止程序花在GC上的CPU%</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Wall-Clock 流逝的系统时钟</span><br><span class="line">0.027ms+4.5ms+0.015 ms   : 分别是 STW Mark Prepare，Concurrent Marking，STW Mark Termination 的时钟时间</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; CPU Time 消耗的CPU时间</span><br><span class="line">0.11+2.3&#x2F;4.0&#x2F;5.5+0.063 ms : 以+分隔的阶段同上，不过将Concurrent Marking细分为Mutator Assists Time, Background GC Time(包括Dedicated和Fractional Worker), Idle GC Time三种。其中0.11&#x3D;0.027*4，0.063&#x3D;0.015*4。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 内存相关统计</span><br><span class="line">4-&gt;4-&gt;2 MB: 分别是开始标记时，标记结束后的堆占用大小，以及标记结束后真正存活的(有效的)堆内存大小</span><br><span class="line">5 MB goal: 下次GC Mark Termination后的目标堆占用大小，该值受GC Percentage影响，并且会影响mutator assist工作量(每次堆大小变更时都动态评估，如果快超出goal了，就需要其它goroutine帮忙干活了, https:&#x2F;&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;blob&#x2F;dev.boringcrypto.go1.13&#x2F;src&#x2F;runtime&#x2F;mgc.go#L484)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Processors</span><br><span class="line">4 P : P的数量，也就是GOMAXPROCS大小，可通过runtime.GoMaxProcs设置</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 其它</span><br><span class="line">GC forced: 如果两分钟内没有执行GC，则会强制执行一次GC，此时会换行打印 GC forced</span><br></pre></td></tr></table></figure><h4 id="4-MemStats"><a href="#4-MemStats" class="headerlink" title="4. MemStats"></a>4. MemStats</h4><p><a href="https://github.com/golang/go/blob/dev.boringcrypto.go1.13/src/runtime/mstats.go#L147">runtime.MemStats</a>记录了内存分配的一些统计信息，通过<code>runtime.ReadMemStats(&amp;ms)</code>获取，它是<a href="https://github.com/golang/go/blob/dev.boringcrypto.go1.13/src/runtime/mstats.go#L24">runtime.mstats</a>的对外版(再次可见Go单一访问控制的弊端)，MemStats字段比较多，其中比较重要的有:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HeapSys </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下内存大小字段如无特殊说明单位均为bytes</span></span><br><span class="line"><span class="keyword">type</span> MemStats <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 从开始运行到现在累计分配的堆内存数</span></span><br><span class="line">    TotalAlloc <span class="keyword">uint64</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从OS申请的总内存数(包含堆、栈、内部数据结构等)</span></span><br><span class="line">    Sys <span class="keyword">uint64</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 累计分配的堆对象数量 (当前存活的堆对象数量=Mallocs-Frees)</span></span><br><span class="line">    Mallocs <span class="keyword">uint64</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 累计释放的堆对象数量</span></span><br><span class="line">    Frees   <span class="keyword">uint64</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正在使用的堆内存数，包含可访问对象和暂未被GC回收的不可访问对象</span></span><br><span class="line">    HeapAlloc <span class="keyword">uint64</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 虚拟内存空间为堆保留的大小，包含还没被使用的(还没有映射物理内存，但这部分通常很小)</span></span><br><span class="line">    <span class="comment">// 以及已经将物理内存归还给OS的部分(即HeapReleased)</span></span><br><span class="line">    <span class="comment">// HeapSys = HeapInuse + HeapIdle</span></span><br><span class="line">    HeapSys <span class="keyword">uint64</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 至少包含一个对象的span字节数</span></span><br><span class="line">    <span class="comment">// Go GC是不会整理内存的</span></span><br><span class="line">    <span class="comment">// HeapInuse - HeapAlloc 是为特殊大小保留的内存，但是它们还没有被使用</span></span><br><span class="line">    HeapInuse <span class="keyword">uint64</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 未被使用的span中的字节数</span></span><br><span class="line">    <span class="comment">// 未被使用的span指没有包含任何对象的span，它们可以归还OS，也可以被重用，或者被用于栈内存</span></span><br><span class="line">    <span class="comment">// HeapIdle - HeadReleased 即为可以归还OS但还被保留的内存，这主要用于避免频繁向OS申请内存</span></span><br><span class="line">    HeapIdle <span class="keyword">uint64</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// HeapIdle中已经归还给OS的内存量</span></span><br><span class="line">    HeapReleased <span class="keyword">uint64</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序可以通过定期调用<code>runtime.ReadMemStats</code>API来获取内存分配信息发往时序数据库进行监控。另外，该API是会STW的，但是很短，Google内部也在用，用他们的话说:”STW不可怕，长时间STW才可怕”，该API通常一分钟调用一次即可。</p><h4 id="5-ReadGCStats"><a href="#5-ReadGCStats" class="headerlink" title="5. ReadGCStats"></a>5. ReadGCStats</h4><p><code>debug.ReadGCStats</code>用于获取最近的GC统计信息，主要是GC造成的延迟信息:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCStats collect information about recent garbage collections.</span></span><br><span class="line"><span class="keyword">type</span> GCStats <span class="keyword">struct</span> &#123;</span><br><span class="line">LastGC         time.Time       <span class="comment">// 最近一次GC耗费时间</span></span><br><span class="line">NumGC          <span class="keyword">int64</span>           <span class="comment">// 执行GC的次数</span></span><br><span class="line">PauseTotal     time.Duration   <span class="comment">// 所有GC暂停时间总和</span></span><br><span class="line">Pause          []time.Duration <span class="comment">// 每次GC的暂停时间，最近的排在前面</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和ReadMemStats一样，ReadGCStats也可以定时收集，发送给时序数据库做监控统计。</p><h3 id="三-Go-GC-调优"><a href="#三-Go-GC-调优" class="headerlink" title="三. Go GC 调优"></a>三. Go GC 调优</h3><p>Go GC相关的参数少得可怜，一如既往地精简:</p><h4 id="1-debug-SetGCPercent"><a href="#1-debug-SetGCPercent" class="headerlink" title="1. debug.SetGCPercent"></a>1. debug.SetGCPercent</h4><p>一个百分比数值，决定即本次GC后，下次触发GC的阈值，比如本次GC Sweeping完成后的内存占用为200M，GC Percentage为100(默认值)，那么下次触发GC的内存阈值就是400M。这个值通常不建议修改，因为优化GC开销的方法通常是避免不必要的分配或者内存复用，而非通过调整GC Percent延迟GC触发时机(Go GC本身也会根据当前分配速率来决定是否需要提前开启新一轮GC)。另外，debug.SetGCPercent传入&lt;0的值将关闭GC。</p><h4 id="2-runtime-GC"><a href="#2-runtime-GC" class="headerlink" title="2. runtime.GC"></a>2. runtime.GC</h4><p>强制执行一次GC，如果当前正在执行GC，则帮助当前GC执行完成后，再执行一轮完整的GC。该函数阻塞直到GC完成。</p><h4 id="3-debug-FreeOSMemory"><a href="#3-debug-FreeOSMemory" class="headerlink" title="3. debug.FreeOSMemory"></a>3. debug.FreeOSMemory</h4><p>强制执行一次GC，并且尽可能多地将不再使用的内存归还给OS。</p><p>严格意义上说，以上几个API预期说调优，不如说是补救，它们都只是把Go GC本身就会做的事情提前或者延后了，通常是治标不治本的方法。真正的GC调优主要还是在应用层面。我在<a href="https://wudaijun.com/2019/09/go-performance-optimization/">这篇文章</a>聊了一些Go应用层面的内存优化。</p><p>以上主要从偏应用的角度介绍了Golang GC的几个重要阶段，STW，GC度量/调试，以及相关API等。这些理论和方法能在在必要的时候派上用场，帮助更深入地了解应用程序并定位问题。</p><p>推荐文献:</p><ol><li><a href="https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html">Garbage Collection In Go</a></li><li><a href="https://github.com/qcrao/Go-Questions/blob/master/GC/GC.md">GC 20 问</a></li><li><a href="https://blog.learngoprogramming.com/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed">A visual guide to Go Memory Allocator from scratch</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一-Go-GC-要点&quot;&gt;&lt;a href=&quot;#一-Go-GC-要点&quot; class=&quot;headerlink&quot; title=&quot;一. Go GC 要点&quot;&gt;&lt;/a&gt;一. Go GC 要点&lt;/h3&gt;&lt;p&gt;先来回顾一下GC的几个重要的阶段:&lt;/p&gt;
&lt;h4 id=&quot;Mark-Prepare-STW&quot;&gt;&lt;a href=&quot;#Mark-Prepare-STW&quot; class=&quot;headerlink&quot; title=&quot;Mark Prepare - STW&quot;&gt;&lt;/a&gt;Mark Prepare - STW&lt;/h4&gt;&lt;p&gt;做标记阶段的准备工作，需要停止所有正在运行的goroutine(即STW)，标记根对象，启用内存屏障，内存屏障有点像内存读写钩子，它用于在后续并发标记的过程中，维护三色标记的完备性(三色不变性)，这个过程通常很快，大概在10-30微秒。&lt;/p&gt;
&lt;h4 id=&quot;Marking-Concurrent&quot;&gt;&lt;a href=&quot;#Marking-Concurrent&quot; class=&quot;headerlink&quot; title=&quot;Marking - Concurrent&quot;&gt;&lt;/a&gt;Marking - Concurrent&lt;/h4&gt;&lt;p&gt;标记阶段会将大概25%(gcBackgroundUtilization)的P用于标记对象，逐个扫描所有G的堆栈，执行三色标记，在这个过程中，所有新分配的对象都是黑色，被扫描的G会被暂停，扫描完成后恢复，这部分工作叫后台标记(&lt;a href=&quot;https://github.com/golang/go/blob/dev.boringcrypto.go1.13/src/runtime/mgc.go#L1817&quot;&gt;gcBgMarkWorker&lt;/a&gt;)。这会降低系统大概25%的吞吐量，比如&lt;code&gt;MAXPROCS=6&lt;/code&gt;，那么GC P期望使用率为&lt;code&gt;6*0.25=1.5&lt;/code&gt;，这150%P会通过专职(Dedicated)/兼职(Fractional)/懒散(Idle)三种工作模式的Worker共同来完成。&lt;/p&gt;</summary>
    
    
    
    <category term="golang" scheme="http://wudaijun.com/categories/golang/"/>
    
    
    <category term="golang" scheme="http://wudaijun.com/tags/golang/"/>
    
    <category term="gc" scheme="http://wudaijun.com/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Go内存优化和相关底层机制</title>
    <link href="http://wudaijun.com/2019/09/go-performance-optimization/"/>
    <id>http://wudaijun.com/2019/09/go-performance-optimization/</id>
    <published>2019-09-13T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.614Z</updated>
    
    <content type="html"><![CDATA[<p>最近做的优化比较多，整理下和Go内存相关的一些东西。</p><h2 id="一-不要过早优化"><a href="#一-不要过早优化" class="headerlink" title="一. 不要过早优化"></a>一. 不要过早优化</h2><p>虽是老生常谈，但确实需要在做性能优化的时候铭记在心，个人的体会:</p><ol><li>first make it work, then measure, then optimize</li><li>二八原则</li><li>需求变更快</li><li>对性能的主观直觉不靠谱</li></ol><span id="more"></span><h2 id="二-内存优化"><a href="#二-内存优化" class="headerlink" title="二. 内存优化"></a>二. 内存优化</h2><p>Golang运行时的内存分配算法主要源自 Google 为 C 语言开发的TCMalloc算法，全称Thread-Caching Malloc。核心思路是层级管理，以降低锁竞争开销。Golang内存管理大概分为三层，每个线程(GPM中的P)都会自行维护一个独立的内存池(mcache)，进行内存分配时优先从mcache中分配(无锁)，当mcache内存不足时才会向全局内存池(mcentral)申请(有锁)，当mcentral内存不足时再向全局堆空间管理(mheap)中申请(有锁+按照固定大小切割)，最后mheap如果不足，则向OS申请(SysCall)。mcache -&gt; mcentral -&gt; mheap -&gt; OS 代价逐层递增，Golang运行时的很多地方都有这种层级管理的思路，比如GPM调度模型中对G的分配，这种层级在并发运行时下，通常有比较好的性能表现。</p><p>以下讨论下内存优化(主要是优化分配和GC开销，而非内存占用大小)常用的手段。</p><h3 id="1-内存复用"><a href="#1-内存复用" class="headerlink" title="1. 内存复用"></a>1. 内存复用</h3><p>关于内存复用最常见的手段就是内存池了，它缓存已分配但不再使用的对象，在下次分配时进行复用，以避免频繁的对象分配。</p><h4 id="1-1-sync-Pool"><a href="#1-1-sync-Pool" class="headerlink" title="1.1 sync.Pool"></a>1.1 sync.Pool</h4><p>Go的<code>sync.Pool</code>包是Go官方提供的内存池，在使用sync.Pool时，需要注意:</p><ol><li>sync.Pool是goroutine safe的，并发控制会带来少部分开销(经过多级缓存已经无锁优化，这部分开销大部分时候都不用过多关注)</li><li>sync.Pool无法设置大小，所以理论上只受限于GC临界值大小</li><li>sync.Pool中的对象不支持自定义过期时间及策略，go1.13前sync.Pool中的对象会在GC开始前全部清除，在go1.13中有优化，会留一部分Object，相当于延缓了收缩扩张的速度</li></ol><p>sync.Pool适用于跨goroutine且需要动态伸缩的场景，典型的如网络层或日志层，每个连接(goroutine)都需要Pool，并且连接数是不稳定的。</p><h4 id="1-2-leakybuf"><a href="#1-2-leakybuf" class="headerlink" title="1.2 leakybuf"></a>1.2 leakybuf</h4><p>有时为了达成更轻量，更可控的复用，我们可能会根据应用场景自己造轮子，比如实现一个固定大小，不会被GC的内存池。比如shadowsocks-go的<a href="https://github.com/shadowsocks/shadowsocks-go/blob/master/shadowsocks/leakybuf.go">LeakyBuf</a>就用channel巧妙实现了个[]byte Pool。</p><p>leakybuf这类Pool相较于sync.Pool的主要优势是不会被GC，但缺点是少了收缩性，设置大了浪费内存，设置小了复用作用不明显。因此它适用于能够提前预估池子大小的场景，在实践中，我们将其用在DB序列化层，其Worker数量固定，单个[]byte较大，也相对稳定。</p><h4 id="1-3-逻辑对象复用"><a href="#1-3-逻辑对象复用" class="headerlink" title="1.3 逻辑对象复用"></a>1.3 逻辑对象复用</h4><p>复用的粒度不仅限于简单struct或slice，也可以是逻辑实体。比如我们游戏中每次生成地图NPC时，会根据配置初始化大量的属性和BUFF，涉及到很多小对象的分配，这里我们选择将整个NPC作为复用粒度，在NPC倒计时结束或被击败消失时，将NPC整理缓存在池子中，并重置其战斗状态和刷新时间。这种逻辑实体的复用不通用但往往有用，必要的时候可以派上用场。</p><h4 id="1-4-原地复用"><a href="#1-4-原地复用" class="headerlink" title="1.4. 原地复用"></a>1.4. 原地复用</h4><p>除了内存池这种”有借有还”的复用外，另一种常用的内存复用思路是就地复用，它主要用于切片这类容易重置的数据结构，比如下面是一个过滤切片中所有奇数的操作:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">ret := s[:<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> s[i] &amp; <span class="number">1</span> == <span class="number">1</span>&#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个”黑科技”操作是[]byte to string:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bs := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 175 ns/op 底层会拷贝bs，保证string的字符常量语义</span></span><br><span class="line">ss2 = <span class="keyword">string</span>(bs)</span><br><span class="line"><span class="comment">// 2.48 ns/op 直接地址转换，慎用，破坏了string的字符常量语义，更改bs将影响到ss1 ！</span></span><br><span class="line">ss1 = *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;bs))</span><br></pre></td></tr></table></figure><p>切片的这类技巧经常用在网络层和算法层，有时候也能起到不错的效果。</p><h3 id="2-预分配"><a href="#2-预分配" class="headerlink" title="2. 预分配"></a>2. 预分配</h3><p>预分配主要针对map, slice这类数据结构，当你知道它要分配多大内存时，就提前分配，一是为了避免多次内存分配，二是为了减少space grow带来的数据迁移(map evacuate or slice copy)开销。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">10</span></span><br><span class="line">src := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无预分配: 162 ns/op</span></span><br><span class="line"><span class="keyword">var</span> dst []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">dst = <span class="built_in">append</span>(dst, src[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预分配，32.3 ns/op，提升了5倍</span></span><br><span class="line">dst2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, n)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">dst2 = <span class="built_in">append</span>(dst2, src[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预分配+append...: 30.1 ns/op</span></span><br><span class="line">dst2 = <span class="built_in">append</span>(dst2, src...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预分配+copy: 26.0 ns/op</span></span><br><span class="line"><span class="built_in">copy</span>(dst2, src)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，slice预分配对性能的提升是非常大的，这里为了简单起见，以纯粹的拷贝切片为例，而对于切片拷贝，应该使用go专门为优化slice拷贝提供的内置函数copy，如果抛开分配dst2的开销，<code>copy(dst2, src)</code>的运算速度达到0.311ns，是<code>append(dst, src...)</code>的20倍左右！</p><p>平时编码中养成预分配的习惯是有利而无害的，Go的一些代码分析工具如<a href="https://github.com/alexkohler/prealloc">prealloc</a>可以帮助你检查可做的预分配优化。</p><p>有时候预分配的大小不一定是精确的，也可能模糊的，比如要将一个数组中所有的偶数选出来，那么可以预分配1/2的容量，在不是特别好估算大小的情况下，尽可能保守分配。</p><p>预分配的另一个思路就是对于一些频繁生成的大对象，比如我们逻辑中打包地图实体，这是个很大的pb协议，pb默认生成的内嵌消息字段全是指针，给指针赋值的过程中为了保证深拷贝语义需要频繁地分配这些各级字段的内存，为了优化分配内存次数，我们使用<a href="https://github.com/gogo/protobuf">gogoproto</a>的nullable生成器选项来对这类消息生成嵌套的值字段而非指针字段，这样可以减少内存分配次数(但分配的数量是一样的)。</p><h3 id="3-避免不必要的分配"><a href="#3-避免不必要的分配" class="headerlink" title="3. 避免不必要的分配"></a>3. 避免不必要的分配</h3><p>Go的逃逸分析+GC会让Gopher对指针很青睐，receiver，struct field, arguments, return value等，却容易忽略背后的开销(当然，大部分时候开发者确实不需要操心)。</p><h4 id="3-1-减少返回值逃逸"><a href="#3-1-减少返回值逃逸" class="headerlink" title="3.1 减少返回值逃逸"></a>3.1 减少返回值逃逸</h4><p>为了避免引用必要的时候也可以化切片为数组:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并返回了一个切片，切片是引用语义，导致ret逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetNineGrid1</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">ret := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">9</span>)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个数组但返回了它的切片(相当于它的引用)，导致数组逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetNineGrid2</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ret [<span class="number">9</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">return</span> ret[:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并返回数组，数组是值语义，因此不会逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetNineGrid3</span><span class="params">()</span> [9]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="number">9</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这还不够，有时候还需要对计算流程进行优化:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Coord <span class="keyword">struct</span>&#123;</span><br><span class="line">X   <span class="keyword">int32</span></span><br><span class="line">Z   <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(c *Coord)</span> *<span class="title">Coord</span></span> &#123;</span><br><span class="line">ret := Coord&#123;</span><br><span class="line">X: c.X/<span class="number">2</span>,</span><br><span class="line">Z: c.Z/<span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span> <span class="title">int32</span></span> &#123;</span><br><span class="line">c := &amp;Coord&#123;</span><br><span class="line">X: <span class="number">2</span>,</span><br><span class="line">Z: <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line">c2 := f1(c)</span><br><span class="line"><span class="keyword">return</span> c2.X</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new_f1</span><span class="params">(c *Coord, ret *Coord)</span></span> &#123;</span><br><span class="line">ret.X = c.X/<span class="number">2</span>,</span><br><span class="line">ret.Z = c.Z/<span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new_f2</span><span class="params">()</span> <span class="title">int32</span></span> &#123;</span><br><span class="line">    c := &amp;Coord&#123;</span><br><span class="line">        X:  <span class="number">2</span>,</span><br><span class="line">        Z:  <span class="number">4</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    ret := &amp;Coord&#123;&#125;</span><br><span class="line">    new_f1(c, ret)</span><br><span class="line">    <span class="keyword">return</span> ret.X</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，Go编译器会分析到f1的变量ret地址会返回，因此它不能分配在栈在(调用完成后，栈就回收了)，必须分配在堆上，这就是逃逸分析(escape analyze)。而对于f2中的变量c来说，虽然函数中用了c的地址，但都是用于其调用的子函数(此时f1的栈还有效)，并未返回或传到函数栈有效域外，因此f2中的c会分配到栈上。</p><p>在默认编译参数下，f1的ret并不会逃逸，这是因为f1会被内联的，f1的调用并不会有新的函数栈的扩展和收缩，都会在f2的函数栈上进行，由于f2中的变量都没有逃逸到f2之外，因此对f2的调用也不会有任何内存分配，可以通过<code>-gcflags -N -l</code>编译选项来禁用内联，并通过<code>-gcflags -m</code>打印逃逸分析信息。但内联也是有条件的(函数足够简单，不涉及Interface)，我们将在后面再聊到内联。</p><h4 id="3-2-化指针为值"><a href="#3-2-化指针为值" class="headerlink" title="3.2 化指针为值"></a>3.2 化指针为值</h4><p>可以将使用频繁并且简单的结构体比如前面的地图坐标Coord，使用值而不是指针，这样可以减少不必要的变量逃逸带来的GC开销。</p><h4 id="3-3-字符串操作优化"><a href="#3-3-字符串操作优化" class="headerlink" title="3.3 字符串操作优化"></a>3.3 字符串操作优化</h4><p>以下是一个简单的测试，并注有其benchmark性能数据:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1834 ns/op     880 B/op      29 allocs/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringSprintf</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">v := <span class="string">&quot;benmark&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">s = fmt.Sprintf(<span class="string">&quot;%s[%s]&quot;</span>, s, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 616 ns/op     576 B/op      10 allocs/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringPlus</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">v := <span class="string">&quot;benmark&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">s = s + <span class="string">&quot;[&quot;</span> + v + <span class="string">&quot;]&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 395 ns/op     304 B/op       3 allocs/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringBuffer</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">v := <span class="string">&quot;benmark&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">buffer.WriteString(<span class="string">&quot;[&quot;</span>)</span><br><span class="line">buffer.WriteString(v)</span><br><span class="line">buffer.WriteString(<span class="string">&quot;]&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buffer.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 218 ns/op     248 B/op       5 allocs/op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringBuilder</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> builder strings.Builder</span><br><span class="line">v := <span class="string">&quot;benmark&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">builder.WriteString(<span class="string">&quot;[&quot;</span>)</span><br><span class="line">builder.WriteString(v)</span><br><span class="line">builder.WriteString(<span class="string">&quot;]&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> builder.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导致内存分配差异如此大的主要原因是string是常量语义，每次在构造新的string时，都会将之前string的底层[]byte拷贝一次，在执行多次string拼接时，<code>strings.Builder</code>和<code>bytes.Buffer</code>会缓存中间生成的[]byte，直到真正需要string结果时再调用它们的<code>String()</code>返回，避免了生成不必要的string中间结果，因此在多次拼接字符串的场景，<code>strings.Builder</code>和<code>bytes.Buffer</code>是更好的选择。</p><p>简单总结下:</p><ul><li><code>fmt.Sprintf</code>: 适用于将其它类型格式化为字符串，灵活性高，但由于逃逸会导致大量的内存分配(后面讲逃逸会再次提到)</li><li><code>+</code>: 适用于少量的的常量字符串拼接，易读性高</li><li><code>bytes.Buffer</code>: 有比slice默认更激进的cap分配，它的<code>String()</code>方法需要拷贝。适用于大量的字符串的二进制拼接，如网络层。</li><li><code>strings.Builder</code>: 底层使用slice默认cap分配，主要的优点是调用<code>String()</code>不需要拷贝(直接地址转换)，适用于要求输出结果是string的地方</li></ul><h2 id="三-逃逸和内联"><a href="#三-逃逸和内联" class="headerlink" title="三 逃逸和内联"></a>三 逃逸和内联</h2><h3 id="1-逃逸分析"><a href="#1-逃逸分析" class="headerlink" title="1. 逃逸分析"></a>1. 逃逸分析</h3><p>前面简单提了下逃逸分析，这里我们再深入讨论下，逃逸分析虽然好用，却并不免费，只有理解其内部机制，才能将收益最大化(开发效率vs运行效率)。逃逸分析的本质是当编译器发现函数变量将脱离函数栈有效域或被函数栈有效域外的变量所引用时时，将变量分配在堆上而不是栈在。也可以用两个不变性约束来描述:</p><ol><li>指向栈对象的指针不能存放在堆中</li><li>指向栈对象的指针的生命周期不能超过该栈对象</li></ol><p>典型导致逃逸的情形有:</p><ol><li>函数返回变量地址，或返回包含变量地址的struct，刚才已经讨论过</li><li>将变量地址写入channel或sync.Pool，编译器无法获悉其它goroutine如何使用这个变量，也就无法在编译时决议变量的生命周期</li><li>闭包也可能导致闭包上下文逃逸</li><li>将变量地址赋给可扩容容器(如map,slice)时，slice/map超过cap重新分配时，将在堆上进行，栈的大小毕竟是固定和有限的</li><li>涉及到Interface的很多逃逸优化都比较保守，如<code>reflect.ValueOf(x)</code>会显式调用<code>escapes(x)</code>导致x逃逸</li></ol><p>第4点和第5点单独说下，以slice和空接口为例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">example</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">s2 := <span class="built_in">make</span>([]*<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line">a, b, c, d := <span class="number">456</span>, <span class="number">456</span>, <span class="number">456</span>, <span class="number">456</span></span><br><span class="line">e := <span class="number">123</span></span><br><span class="line">f := <span class="keyword">struct</span>&#123;X <span class="keyword">int</span>; Z <span class="keyword">int</span>&#125;&#123;&#125;</span><br><span class="line"><span class="comment">// 值语义slice, a将分配在栈上</span></span><br><span class="line">s1[<span class="number">1</span>] = a</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用语义slice, 引用b的地址，b将分配在堆上</span></span><br><span class="line">s2[<span class="number">2</span>] = &amp;b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用语义slice, 引用c的值，c将分配在栈上，但s3[3]对应interface&#123;&#125;中的data会分配一个int的空间，然后将c值赋给该堆内存</span></span><br><span class="line">s3[<span class="number">3</span>] = c</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用语义slice，引用d的地址，d将分配在堆上，s3[4]对应interface&#123;&#125;的data值即为d的地址</span></span><br><span class="line">s3[<span class="number">4</span>] = &amp;d</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用语义slice，引用e的值，e同样将分配在栈上，但s3[5]本身也不再分配int堆内存(go1.15专门为0~255的小整数转interface作了[staticuint64s预分配优化](https://github.com/golang/go/blob/dev.boringcrypto.go1.15/src/runtime/iface.go#L532))</span></span><br><span class="line">s3[<span class="number">5</span>] = e</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用语义slice，引用f的值，f将分配在栈上，s3[6]对应interface&#123;&#125;的data会分配一个新的16B的空间，并拷贝f的值</span></span><br><span class="line">s3[<span class="number">6</span>] = f</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过println打印不会导致逃逸</span></span><br><span class="line"><span class="built_in">println</span>(&amp;a, &amp;b, &amp;c, &amp;d, &amp;e, &amp;f, s3[<span class="number">3</span>], s3[<span class="number">4</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于栈空间是在编译期确定的，slice重分配只能发生在堆上。目前golang逃逸分析还不能完全分析slice的生命周期和扩容可能性，它会保守地保证slice元素只能指向堆内存(否则重分配后，浅拷贝会导致堆内存引用了栈内存)，因此可能会发生逃逸。</p><p>当slice元素为interface时，情况和s2类似，interface{}本质为引用语义，即为typ + pointer，这个pointer指向实际的data，参考我之前写的<a href="https://wudaijun.com/2018/01/go-interface-implement/">go interface实现</a>。interface的pointer总是指针(不会类似Erlang Term一样对立即数进行优化，就地存储)，因此执行<code>s3[3] = c</code>时，本质会新分配一个对应空间，然后拷贝值，最后让pointer指向它。不让这个int值直接逃逸的原因是，执行该赋值后，本质上c和s3[3]是相互独立的，s3[3]为一个只读的int，而c的值是可以随时变化的，不应该相互影响，因此不能直接引用c的地址。虽然没有立即数优化，但是Go1.15之后，对小整数转interface{}进行了优化，也算聊胜于无。</p><p>Go官方一直在做interface逃逸相关的优化:</p><p>Go1.10开始提出的<a href="https://github.com/golang/go/issues/19361">devirtualization</a>，编译器在能够知晓Interface具体对象的情况下(如<code>var i Iface = &amp;myStruct&#123;&#125;</code>)，可以直接生成对象相关代码调用(通过插入类型断言)，而无需走Interface方法查找，同时助力逃逸分析。devirtualization还在不断完善(最初会导致receiver和参数逃逸，<a href="https://github.com/golang/go/issues/33160#issuecomment-512653356">这里</a>有讨论，该问题2020年底已经在Go1.16中<a href="https://go-review.googlesource.com/c/go/+/264837/5">Fix</a>)。</p><p>Go1.15的<a href="https://github.com/golang/go/blob/dev.boringcrypto.go1.15/src/runtime/iface.go#L532">staticuint64s预分配优化</a>避免了小整数转换为interface{}的内存分配。目前Go的逃逸分析策略还相对保守，比如前面代码的s2，既slice变量本身没有逃逸，也没有发生扩容，那么让slice以及其元素都在栈上应该是安全的。当然，好的逃逸分析需要在编译期更深入地理解程序，这本身也是在保证安全的前提下循序渐进的。</p><p>整体来说，目前的逃逸分析还在逐渐完善，还远没到真正成熟的地步，比如strings.Builder的源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; noescape hides a pointer from escape analysis.  noescape is</span><br><span class="line">&#x2F;&#x2F; the identity function but escape analysis doesn&#39;t think the</span><br><span class="line">&#x2F;&#x2F; output depends on the input. noescape is inlined and currently</span><br><span class="line">&#x2F;&#x2F; compiles down to zero instructions.</span><br><span class="line">&#x2F;&#x2F; USE CAREFULLY!</span><br><span class="line">&#x2F;&#x2F; This was copied from the runtime; see issues 23382 and 7921.</span><br><span class="line">&#x2F;&#x2F;go:nosplit</span><br><span class="line">&#x2F;&#x2F;go:nocheckptr</span><br><span class="line">func noescape(p unsafe.Pointer) unsafe.Pointer &#123;</span><br><span class="line">x :&#x3D; uintptr(p)</span><br><span class="line">return unsafe.Pointer(x ^ 0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Builder) copyCheck() &#123;</span><br><span class="line">if b.addr &#x3D;&#x3D; nil &#123;</span><br><span class="line">&#x2F;&#x2F; This hack works around a failing of Go&#39;s escape analysis</span><br><span class="line">&#x2F;&#x2F; that was causing b to escape and be heap allocated.</span><br><span class="line">&#x2F;&#x2F; See issue 23382.</span><br><span class="line">&#x2F;&#x2F; TODO: once issue 7921 is fixed, this should be reverted to</span><br><span class="line">&#x2F;&#x2F; just &quot;b.addr &#x3D; b&quot;.</span><br><span class="line">b.addr &#x3D; (*Builder)(noescape(unsafe.Pointer(b)))</span><br><span class="line">&#125; else if b.addr !&#x3D; b &#123;</span><br><span class="line">panic(&quot;strings: illegal use of non-zero Builder copied by value&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>noescape通过一个无用的位运算，切断了逃逸分析对指针的追踪(解除了参数与返回值的关联)，noescape被大量应用到Go Runtime源码中。</p><p>另一个饱受诟病的就是fmt.Printf系列(包括logrus.Debugf等所有带<code>...interface&#123;&#125;</code>参数的函数)，它也很容易导致逃逸，原理前面已经提过，<code>...interface&#123;&#125;</code>是<code>[]interface&#123;&#125;</code>的语法糖，逃逸分析不能确定<code>args []interface&#123;&#125;</code>切片是否会在函数中扩容，因此它要保证切片中的内容拷贝到堆上是安全的，那么就要保证切片元素不能引用栈内存，因此interface{}中的pointer只能指向堆内存。</p><p>虽然noescape能解决部分问题，但不建议轻易使用，除非是明确性能瓶颈的场景。</p><h3 id="2-内联"><a href="#2-内联" class="headerlink" title="2. 内联"></a>2. 内联</h3><p>前面说过，逃逸分析+GC好用但不免费，但如果没有内联这个最佳辅助的话，前两者的代价怕是昂贵得用不起，所有函数返回的地方，都会树立起一道”墙”，任何想要从墙内逃逸到墙外的变量都会被分配在堆上，如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCoord</span><span class="params">()</span> *<span class="title">Coord</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Coord&#123;</span><br><span class="line">X: <span class="number">1</span>,</span><br><span class="line">Z: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := NewCoord()</span><br><span class="line"><span class="keyword">return</span> c.x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewCoord</code>这类简单的构造函数都会导致返回值分配在堆上，抽离函数的代价也更大。因此Go的内联，逃逸分析，GC是名副其实的三剑客，它们共同将其它语言避之不及的指针变得”物美价廉”。</p><p>Go1.11开始对内联做了比较大的运行时优化，开始支持<a href="https://go.googlesource.com/proposal/+/master/design/19348-midstack-inlining.md">mid-stack inline</a>，talk链接在<a href="https://docs.google.com/presentation/d/1Wcblp3jpfeKwA0Y4FOmj63PW52M_qmNqlQkNaLj0P5o/edit#slide=id.g1d00ad65a7_2_17">这里</a>。并且支持通过<code>-l</code>编译参数指定内联等级(参数定义参考<a href="https://github.com/golang/go/blob/71a6a44428feb844b9dd3c4c8e16be8dee2fd8fa/src/cmd/compile/internal/gc/inl.go#L10-L17">cmd/compile/internal/gc/inl.go</a>)。并且只在<code>-l=4</code>中提供了mid-stack inline，据Go官方统计，这大概可以提升9%的性能，也增加了11%左右的二进制大小。Go1.12开始默认支持了mid-stack inline。Go1.17中，包含闭包的函数也可以被内联了。</p><p>我们目前还没有调整过内联参数，因为这是有利有弊的，过于激进的内联会导致生成的二进制文件更大，CPU instruction cache miss也可能会增加。默认等级的内联大部分时候都工作得很好并且稳定。</p><p>到Go1.17为止，虽然对Interface方法的调用还不能被内联(即使编译器知晓具体类型)，但是由于devirtualization优化的存在，已经和直接调用方法性能差距不大:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">F() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">x <span class="keyword">int</span></span><br><span class="line">y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">F</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">z := a.x + a.y</span><br><span class="line"><span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkX</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.ReportAllocs()</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;b.N; i++ &#123;</span><br><span class="line"><span class="comment">// F() 会被内联 0.36 ns/op</span></span><br><span class="line"><span class="comment">// var a = &amp;A&#123;&#125;</span></span><br><span class="line"><span class="comment">// a.F()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// before go1.16 接口方法的receiver &amp;A&#123;&#125;会逃逸 18.4 ns/op</span></span><br><span class="line"><span class="comment">// go1.16+ &amp;A&#123;&#125;不再逃逸 2.51 ns/op 消耗主要在方法调用和接口方法查找上</span></span><br><span class="line"><span class="keyword">var</span> iface I = &amp;A&#123;&#125;</span><br><span class="line">iface.F()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对目前Go Interface 内联做得不够好的情况，一个实践是，在性能敏感场景，让你的公用API返回具体类型而非Interface，如<code>etcdclient.New</code>，<code>grpc.NewServer</code>等都是如此实践的，它们通过私有字段加公开方法让外部用起来像Interface一样，但数据逻辑层可能实践起来会有一些难度，因为Go的访问控制太弱了…</p><p>总的来说，golang 的 GC，内联，逃逸仍然在不断优化和完善，关注和升级最新golang版本，可能是最廉价的性能提升方式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近做的优化比较多，整理下和Go内存相关的一些东西。&lt;/p&gt;
&lt;h2 id=&quot;一-不要过早优化&quot;&gt;&lt;a href=&quot;#一-不要过早优化&quot; class=&quot;headerlink&quot; title=&quot;一. 不要过早优化&quot;&gt;&lt;/a&gt;一. 不要过早优化&lt;/h2&gt;&lt;p&gt;虽是老生常谈，但确实需要在做性能优化的时候铭记在心，个人的体会:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;first make it work, then measure, then optimize&lt;/li&gt;
&lt;li&gt;二八原则&lt;/li&gt;
&lt;li&gt;需求变更快&lt;/li&gt;
&lt;li&gt;对性能的主观直觉不靠谱&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="go" scheme="http://wudaijun.com/categories/go/"/>
    
    
    <category term="go" scheme="http://wudaijun.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>如何给GS做压测</title>
    <link href="http://wudaijun.com/2019/09/gs-pressure-test/"/>
    <id>http://wudaijun.com/2019/09/gs-pressure-test/</id>
    <published>2019-09-12T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.614Z</updated>
    
    <content type="html"><![CDATA[<p>简单谈谈我们最近是如何给GS做压测的。</p><h3 id="1-压测机器人"><a href="#1-压测机器人" class="headerlink" title="1. 压测机器人"></a>1. 压测机器人</h3><p>压测机器人需要满足如下几个条件:</p><ol><li>异步请求: 异步才能模拟真实的客户端请求和压力</li><li>数据同步: 像客户端一样缓存和处理服务器响应数据，这样才能做好有效请求和可重入</li><li>可重入: 机器人应该可以在任何时候关闭/重启，而不应该假设初始状态(比如只有注册的时候能跑)</li><li>随机性: 机器人行为尽可能随机分布，并且每次重启重新初始化随机种子</li></ol><span id="more"></span><h3 id="2-压测用例"><a href="#2-压测用例" class="headerlink" title="2. 压测用例"></a>2. 压测用例</h3><p>压测用例可以从这几个方面来考虑:</p><ol><li>服务器比较耗时的API: 如寻路，战斗等</li><li>玩家越多越耗时的逻辑: 如视野同步，消息广播等</li><li>玩家日常操作频繁的行为: 如城建升级，联盟加入退出，以尽可能覆盖如任务，BUFF，排行榜等支撑系统</li></ol><h3 id="3-压测统计"><a href="#3-压测统计" class="headerlink" title="3. 压测统计"></a>3. 压测统计</h3><p>在做压测中，我们会从如下几个方面来获取性能指标:</p><ol><li>函数级分析: go prof简单易用，参考<a href="https://wudaijun.com/2018/04/go-pprof/">go pprof性能分析</a></li><li>消息级统计: 统计每个逻辑Actor(如地图，玩家)对单次请求的处理时间(最大/平均/次数)，消息是Actor之间交互的最小单位，每个消息处理过程是一条函数调用链</li><li>服务器请求统计: 统计每条客户端请求从网关层收到请求到网关层发出响应的时间差(最大/平均/次数)，相比消息级统计，服务器请求统计包含了多个Actor处理请求相关若干消息的时间，以及Actor之间的路由和通信开销</li><li>客户端请求统计: 统计从请求发出到收到响应的处理时间(最大/平均/次数)，相比服务器消息统计，多了网络层的时延和机器人本身的处理时间，这是最接近客户端实际体验的指标</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单谈谈我们最近是如何给GS做压测的。&lt;/p&gt;
&lt;h3 id=&quot;1-压测机器人&quot;&gt;&lt;a href=&quot;#1-压测机器人&quot; class=&quot;headerlink&quot; title=&quot;1. 压测机器人&quot;&gt;&lt;/a&gt;1. 压测机器人&lt;/h3&gt;&lt;p&gt;压测机器人需要满足如下几个条件:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;异步请求: 异步才能模拟真实的客户端请求和压力&lt;/li&gt;
&lt;li&gt;数据同步: 像客户端一样缓存和处理服务器响应数据，这样才能做好有效请求和可重入&lt;/li&gt;
&lt;li&gt;可重入: 机器人应该可以在任何时候关闭/重启，而不应该假设初始状态(比如只有注册的时候能跑)&lt;/li&gt;
&lt;li&gt;随机性: 机器人行为尽可能随机分布，并且每次重启重新初始化随机种子&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="gameserver" scheme="http://wudaijun.com/categories/gameserver/"/>
    
    
    <category term="gameserver" scheme="http://wudaijun.com/tags/gameserver/"/>
    
  </entry>
  
  <entry>
    <title>编程范式游记</title>
    <link href="http://wudaijun.com/2019/05/programing-paradigm/"/>
    <id>http://wudaijun.com/2019/05/programing-paradigm/</id>
    <published>2019-05-25T16:00:00.000Z</published>
    <updated>2023-03-20T09:58:40.614Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间学习OOP对语言和编程范式有一些新的理解，之前系统整理过<a href="https://wudaijun.com/2018/05/understand-functional-programing/">函数式编程</a>，因此先从OOP谈起。我们先回顾下面向对象(OOP)的核心思想:</p><ol><li>所有的值都是对象</li><li>对象与对象之间通过方法调用(或者说是发消息)进行通信</li><li>对象可以有自己的私有字段/状态，只有对象的方法可以访问和更新这些字段</li><li>每个对象都是一个类(Class)的实例，类定义了对象的行为(内部数据和方法实现)</li></ol><p>与函数式的”一切皆函数”一样，OOP也有一个宏大的目标”一切皆对象”。</p><span id="more"></span><h3 id="oop-with-dynamic-type"><a href="#oop-with-dynamic-type" class="headerlink" title="oop with dynamic type"></a>oop with dynamic type</h3><p>动态OOP语言，以Ruby为例，它是一种”纯度比较高”的OOP语言，它有一些比较有意思的特性:</p><ol><li>null,3,true等都是对象，对象的类也是对象，当然也有例外，如Blocks</li><li>由于对象的类也是对象(类型为Class)，因此你可以像更改对象一样动态更改类的定义，如添加新方法</li><li>对象与对象之间只能通过方法通信，即对象不能直接访问其它对象的字段</li></ol><h4 id="subclass"><a href="#subclass" class="headerlink" title="subclass"></a>subclass</h4><p>除了基于对象的封装之外，另一个OOP需要考虑的问题就是复用，以Ruby为例，比如我们有个Point类:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line">    <span class="keyword">attr_accessor</span> <span class="symbol">:x</span>, <span class="symbol">:y</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x,y)</span></span></span><br><span class="line">        <span class="variable">@x</span> = x</span><br><span class="line">        <span class="variable">@y</span> = y</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distFromOrigin</span></span></span><br><span class="line">        Math.sqrt(<span class="variable">@x</span> * <span class="variable">@x</span> + <span class="variable">@y</span> * <span class="variable">@y</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distFromOrigin2</span></span></span><br><span class="line">        Math.sqrt(x * x + y * y)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在我们要创建一个ColorPoint类，它除了多个Color字段外，其它属性和行为与Point一模一样，这个时候我们有以下几种做法:</p><ol><li>在ColorPoint类定义中，将Point相关的代码拷贝过来或重写，ColorPoint成为了与Point不相关的两个类</li><li>在ColorPoint类中定义一个Point类的成员，然后将distFromOrigin和distFromOrigin2等方法都转调(forwarding)到该成员上</li><li>通过将ColorPoint声明为Point的子类(subclass)，这样ColorPoint就继承Point的所有属性和方法，并且仍然可以自己扩展属性，覆盖或新增方法</li></ol><p>以上三种实现方式导致的ColorPoint和Point耦合度依次递增，在大多数场景下，该问题的最佳方案应该是方案3，因为它能够最大程度达成代码复用，并且在此例子，ColorPoint “is-a” Point。</p><p>但是，在OOP中，subclass通常是很容易被过度使用，比如我们现在要实现一个Point3D类，它多了个z属性，那么它的<code>distFromOrigin</code>和<code>distFromOrigin2</code>都需要override，它真正能够复用的只有<code>x</code>，<code>y</code>两个存取器，这个时候就会有一些争议(复用程度太低)，特别是如果Point还有个方法<code>distance(p)</code>，用于求出两点距离时，此时Point3D需要override该方法，并且参数为Point3D，此时将Point对象传给Point3D的distance将得到运行时错误。因此在用subclass时，需要谨慎评估类之间的关系，以及类扩展和重写带来的影响。</p><h4 id="duck-typing"><a href="#duck-typing" class="headerlink" title="duck typing"></a>duck typing</h4><p>由于Ruby是动态语言，前面我们讨论的ColorPoint的三种实现方式都不影响ColorPoint和Point的使用，如我们有个函数:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def mirror_update pt</span><br><span class="line">    pt.x = pt.x * -<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>三种方式实现的ColorPoint都可以作为<code>mirror_update</code>的参数，因为<code>mirror_update</code>对参数pt的要求是:</p><ol><li>pt实现了<code>x()</code>方法</li><li><code>pt.x()</code>方法的返回值实现了<code>*</code>方法，可接受<code>-1</code>为参数</li><li>pt实现了<code>x=</code>方法，可接受<code>pt.x*-1</code>的结果作为参数</li></ol><p>三种方式实现的Point和ColorPoint都满足以上要求，因此它们都可以使用<code>mirror_update</code>函数。这就是所谓的<a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B">Duck Typing</a>。在Ruby这类动态类型OOP语言中，代码复用非常灵活。当然这也不是免费的，由于少了静态类型检查，如果调用<code>mirror_update(Point.new(1,&quot;haha&quot;))</code>会”正确”得到<code>-1</code>，而调用<code>mirror_update(Point.new(&quot;haha&quot;,-1))</code>则会得到<code>negative argument (ArgumentError)</code>运行时错误(string没有实现<code>*</code>方法)，两种调用报错的时机和报错的形式取决与业务代码。尽管它们从逻辑上来说都是错误的。</p><h4 id="dynamic-dispatch"><a href="#dynamic-dispatch" class="headerlink" title="dynamic dispatch"></a>dynamic dispatch</h4><p>再举一个例子，如果我们要以subclass创建一个极坐标点类PolarPoint(包含一个半径属性和一个角度属性)，为了保证继承的语义，PolarPoint不得不重写来自于Point的<code>x</code>，<code>y</code>属性，我们不再讨论这里使用继承的合理性，而是想引出一个有意思的地方: PlarPoint的<code>distFromOrigin2</code>无需重写，已经可以正常工作！这得益于ruby的<strong>dynamic dispatch</strong>: 用subclass的对象调用superclass的方法时，将优先动态dispatch到subclass的方法上。dynamic dispatch在其它语言中也叫做虚函数(virtual function)或延迟绑定(late bingding)，核心思路是基于对象的方法调用，总是优先从对象实际所属类(动态)上动态查找，而不是方法所属类(静态)。</p><p>dynamic dispatch让代码复用更上了一个层次，比如你可能有一些GUI相关的基类，它已经实现绘图，缩放等操作，你在子类中只需要实现必要的形状信息，就可以基类的方法绘制定制图形，而无需自己再重写绘图相关操作。</p><h4 id="mutiple-inheritance"><a href="#mutiple-inheritance" class="headerlink" title="mutiple inheritance"></a>mutiple inheritance</h4><p>回到我们的ColorPoint，随着功能迭代，ColorPoint的颜色相关API越来越多，如加深/调色等，你可能希望将这部分代码单独抽象为一个Color类，以达成更好的代码复用。然后ColorPoint再从Color类和Point类继承，这就是多重继承。在OOP中，多重继承的名声不是太好，因为它有一些”哲学上的问题”无法达成统一: 当两个superclass有相同的字段和方法时，subclass应该如何继承？</p><p><img src="/assets/image/201905/mutiple-inheritance.png" alt=""></p><p>假如B和C有相同的属性和方法，那么有如下可能:</p><ol><li>D希望同时继承B和C的同名方法: 即D同时有B和C的能力，这是继承的本意，名字碰撞应该通过其它作用域来限制</li><li>D希望只继承B或C的方法: 比如B为ColorPoint，C为Point3D，D为ColorPoint3D，那么显然，D应该继承C的distFromOrigin方法</li><li>B,C相同的方法在A中也有，D想直接从A中继承…</li></ol><p>这就像在现实中，子女的长相可能随父亲，身高可能随母亲，脾气可能谁也不像。多重继承的这些问题很容易造成歧义和理解负担。Ruby选择不支持多重继承，但提供一个叫<strong>mixins</strong>的机制: 尝试通过include module的方式来消除对多重继承的需要。比如ColorPoint:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Color</span></span></span><br><span class="line">    <span class="keyword">attr_accessor</span> <span class="symbol">:color</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">darken</span></span></span><br><span class="line">        <span class="keyword">self</span>.color = <span class="string">&quot;dark &quot;</span> + <span class="keyword">self</span>.color</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> &lt; Point</span></span><br><span class="line">    <span class="keyword">include</span> Color</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>module和class的主要区别在于它不能实例化对象且不能派生子类，它可以有属性，但用得更多地场景是它只提供方法，然后引用一些它本身未定义的方法交给子类去实现(当然，这里又要用到dynamic dispatch)，比如Ruby的<strong>Enumerable</strong>模块:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRange</span></span></span><br><span class="line">    <span class="keyword">include</span> Enumerable</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(low,high)</span></span></span><br><span class="line">        <span class="variable">@low</span> = low</span><br><span class="line">        <span class="variable">@high</span> = high</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">each</span></span></span><br><span class="line">        i=@low</span><br><span class="line">        <span class="keyword">while</span> i &lt;= @high</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line">            i=i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>包含Enumerable的class只需要实现each方法，即可调用<code>MyRange.new(4,8).inject &#123;|x,y| x+y&#125;</code>，<code>MyRange.new(5,12).count &#123;|i| i.odd?&#125;</code>等方法。mixins通过更像组合(i can)而不是继承(i am)的方式来处理需要多重继承的情形。在方法查找(lookup)规则中，mixins优于subclass，后包含的module优于先包含的。</p><p>很多文章说mixins有多重继承的优点，同时也规避了多重继承的问题，我认为mixins的好处非常有限:</p><ol><li>module可以有属性，方法，除了不能实例对象，和普通superclass没有本质区别，也满足<code>is_a?</code>语义</li><li>module之间，module与superclass仍然有命名冲突的问题，只不过Ruby将lookup规则定死了</li><li>module可以include一个或多个module,这是换了种形式的多重继承</li></ol><p>总的来说，由于动态语言的duck typing特性，subclass主要是用在代码复用上，动态语言通常不关心某个对象是否是某个类(或其子类)的实例(<code>is_a?</code>)，它只关心某个对象有没有实现某个方法，对方法的查找是基于dynamic dispath的。</p><h3 id="oop-with-static-type"><a href="#oop-with-static-type" class="headerlink" title="oop with static type"></a>oop with static type</h3><p>聊完动态OOP语言，再来看看静态OOP语言，我们先抛开OOP，静态语言中所有的数据结构，函数参数/返回值都有静态类型，为了阐述方便，我们用伪代码表示某种虚拟的静态语言，它的描述格式为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; distFromOrigin的参数为两个字段x(类型为double)和y(类型为double)的record(或者叫struct)</span><br><span class="line">fun distFromOrigin (p:&#123;x:double,y:double&#125;) double -&gt;</span><br><span class="line">    Math.sqrt(p.x*p.x + p.y*p.y)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过val声明变量pythag类型并赋值</span><br><span class="line">val pythag : &#123;x:double,y:double&#125; &#x3D; &#123;x&#x3D;3.0, y&#x3D;4.0&#125;</span><br><span class="line">&#x2F;&#x2F; 调用函数并接收返回值，由于pythag与distFromOrigin的参数类型一致，因此静态类型检查通过，函数调用成功</span><br><span class="line">val five : double &#x3D; distFromOrigin(pythag)</span><br><span class="line">&#x2F;&#x2F; 调用函数失败，静态类型检查(实参类型int，形参类型&#123;x:doule, y:double&#125;)，编译不通过</span><br><span class="line">val _ &#x3D; distFromOrigin(2)</span><br></pre></td></tr></table></figure><p>注意，在我们用于举例的语言中，record不只是数据结构的概念，它也可以包含function类型的字段，它可以推广到OOP中的Class。</p><h4 id="subtype"><a href="#subtype" class="headerlink" title="subtype"></a>subtype</h4><p>现在假设我们有个描述带颜色的点的record: <code>&#123;x:double, y:double, color:string&#125;</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val cp : &#123;x:double,y:double,color:string&#125; &#x3D; &#123;x&#x3D;3.0, y&#x3D;4.0, color&#x3D;&quot;red&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; 静态类型检查失败, &#123;x:double,y:double,color:string&#125; 与 &#123;x:double,y:double&#125; 类型不匹配</span><br><span class="line">var five : double &#x3D; distFromOrigin(cp)</span><br></pre></td></tr></table></figure><p>而事实上，我们是希望cp能够调用distFromOrigin函数的，因为多color字段既不影响函数计算过程(函数需要的字段都有)，也不影响逻辑上的正确性。因此在这里，为了达成更好地代码复用，我们需要静态类型检查做一些扩展: 如果recordA去掉或交换某些字段后变为recordB，那么能用recordB的地方都应该能用recordA。在这种情况下，我们称recordA是recordB的子类型(subtype，注意和子类subclass区分)，记 B &lt;: A。有了这个规则后，由于<code>&#123;x:double,y:double,color:string&#125;</code>是<code>&#123;x:double,y:double&#125;</code>的子类型，子类型实参可以匹配父类型形参，因此cp可使用distFromOrigin函数。</p><h4 id="depth-subtype"><a href="#depth-subtype" class="headerlink" title="depth subtype"></a>depth subtype</h4><p>现在考虑如下情况，即recordA的某个字段是recordB的某个字段的子类型，那么有recordA&lt;:recordB 吗？听起来是可以的，因为如果一个函数以recordB为形参，那么传入recordA，该函数需要的所有字段都能正确访问到。然而还要考虑到字段可变性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun setToOrigin (c:&#123;center:&#123;x:double,y:double&#125;, r:double&#125;) -&gt; </span><br><span class="line">    c.center &#x3D; &#123;x&#x3D;0.0, y&#x3D;0.0&#125;</span><br><span class="line">    </span><br><span class="line">val sphere:&#123;center:&#123;x:double,y:double,z:double&#125;, r:double&#125;) &#x3D; &#123;center&#x3D;&#123;x&#x3D;3.0,y&#x3D;4.0,z&#x3D;0.0&#125;, r&#x3D;1.0&#125;</span><br><span class="line"></span><br><span class="line">val _ &#x3D; setToOrigin(sphere)</span><br><span class="line">val _ &#x3D; sphere.center.z</span><br></pre></td></tr></table></figure><p>由于setToOrigin不会知道外部传入的supertype还有哪些额外字段，它对center的重置导致center.z字段丢失了，也就破坏了函数本来的语义。因此通常来说: type checker，field setter，depth subtype只能三选二。</p><p>那么实际的编程语言对depth subtype的取舍如何？以Array为例，假如我们有ColorPoint &lt;: Point，那么是否有ColorPoint[] &lt;: Point[]呢？在C++/Go中，是不支持depth subtype的，比如在Go中你不能将[]int实参用于[]interface{}形参(在Go中，interface{}相当于没有任何字段的record，它是任意类型的supertype)，因为函数可能将[]interface{}某个元素改为string类型。而在Java/C#中，却是支持的，比如在Java中，以下代码却能静态检查通过正常编译:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123; ... &#125; <span class="comment">// has fields double x, y</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123; ... &#125; <span class="comment">// adds field String color</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">(Point[] pt_arr)</span> </span>&#123;</span><br><span class="line">    pt_arr[<span class="number">0</span>] = <span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">String <span class="title">m2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ColorPoint[] cpt_arr = <span class="keyword">new</span> ColorPoint[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">        cpt_arr[i] = <span class="keyword">new</span> ColorPoint(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;green&quot;</span>);</span><br><span class="line">    m1(cpt_arr);</span><br><span class="line">    <span class="keyword">return</span> cpt_arr[<span class="number">0</span>].color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是运行时执行m2函数，却会得到ArrayStoreException异常，因为Java/C#选择了可变性和depth subtype，放弃了type checker，放宽了类型检查的限制，它在运行时记录m1中<code>pt_arr</code>的真实类型(ColorPoint[])，并在执行类型不匹配的写入时，抛出异常。</p><h4 id="function-subtype"><a href="#function-subtype" class="headerlink" title="function subtype"></a>function subtype</h4><p>这里讨论当函数参数/返回值也是函数，那么这些作为参数的函数的subtype规则。假如我们有如下函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun callWithOrigin(f: &#123;x:double,y:double&#125;-&gt;&#123;x:double,y:double&#125;) -&gt;</span><br><span class="line">    f(&#123;x:0.0,y:0.0&#125;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>callWithOrigin的参数类型为<code>&#123;x:double,y:double&#125;-&gt;&#123;x:double,y:double&#125;</code>，现在我们来考虑哪些函数实参允许调用callWithOrigin:</p><ul><li><code>&#123;x:double,y:double&#125; -&gt; &#123;x:double,y:double&#125;</code>: ok, 类型完全匹配</li><li><code>&#123;x:double,y:double&#125; -&gt; &#123;x:double,y:double,color:string&#125;</code>: ok, callWithOrigin传入f的函数参数匹配，只不过返回的参数多了个color，callWithOrigin可以正常调用和使用f，只不过它不关心返回的color字段</li><li><code>&#123;x:double,y:double&#125; -&gt; &#123;x:double&#125;</code>: error, callWithOrigin可能用到f返回值中的y字段</li><li><code>&#123;x:double,y:double,z:double&#125; -&gt; &#123;x:double,y:double&#125;</code>: error, callWithOrigin传给f的参数不包含z字段，那么f执行过程就会出错</li><li><code>&#123;x:double&#125; -&gt; &#123;x:double,y:double&#125;</code>: ok, callWithOrigin传给f函数的参数包括x,y字段，只是f函数只用到了x，f函数可以正常执行</li><li><code>&#123;x:double&#125; -&gt; &#123;x:double,y:double,z:double&#125;</code>: ok，由前面的分析可知，实参函数(即subtype function)参数字段不能多，返回值字段不能少。</li></ul><p>因此，有如下结论，对于 t3 &lt;: t1 并且 t2 &lt;: t4, 有 t1-&gt;t2 &lt;: t3-&gt;t4。</p><h4 id="subtype-vs-subclass"><a href="#subtype-vs-subclass" class="headerlink" title="subtype vs subclass"></a>subtype vs subclass</h4><p>我们在讨论Ruby时用的subclass(子类)，而在讨论静态OOP语言时用的是subtype(子类型)，因为它们本质上不是一个东西:</p><ul><li>class定义对象的全部行为，subclass是通过继承来解决class与class之间<strong>代码复用</strong>的问题，子类可以通过重写(override)或扩展(extension)来完善自己的行为</li><li>type关注对象的部分对外接口(字段or方法)，subtype用于定义类型之间<strong>可替换关系</strong>，关注type checker和语义复用</li></ul><p>Ruby是动态语言，它有更为灵活的duck typing，因此不需要subtype。对静态语言而言，subtype不一定要通过subclass来实现，理论上你可以有两个完全不相关的类A和B，但他们提供一致的方法，然后你可以声明A是B的subtype。然后任何用B的地方都可以用A。subtype不care这些方法是通过继承得来的还是独立实现的。</p><p>但在大多数静态OOP语言，如Java/C#/C++中，type和class的边界很模糊，绝大多数时候，你可以认为它们是一个东西，这是因为这些语言主要依赖subclass来实现subtype，因此当你创建一个class时，相当于创建了一个type，它的名字和class名字一样，当你声明subclass关系时，也声明了subtype关系。</p><p>另一点是我们在虚拟语言中以record作为对象的type，这个record可以包含字段，方法等，然后这个record的字段还可以修改，而实际上大多数静态OOP语言中，方法字段是不能修改的，比如你不能拿到一个对象，然后修改它的某个方法，因为方法实现是属于类而不是对象的。</p><p>理解了以上两点，我们就能将虚拟语言与现实世界的OOP语言映射起来了，如C++:</p><ol><li>type和class大部分时候是一个东西，声明一个class也就声明了一个type</li><li>subclass可以基于superclass之上添加字段/方法但是不能移除已有字段/方法</li><li>subclass可以override superclass的方法</li></ol><p>为了阐述方便，以下探讨C++/Java这类主流编程语言时，不再严格区分subclass和subtype的概念。</p><h4 id="dynamic-dispath"><a href="#dynamic-dispath" class="headerlink" title="dynamic dispath"></a>dynamic dispath</h4><p>这里我们进一步讨论静态OOP语言中的dynamic dispatch和this指针，以C++为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;&#125;; &#x2F;&#x2F; include double x, y field</span><br><span class="line">class ColorPoint: public Point &#123;...&#125;; &#x2F;&#x2F; adds string color field</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void showX(Point* p) &#123; cout &lt;&lt; &quot;B showX: &quot; &lt;&lt; p-&gt;x &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class D: public B &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void showX(Point* p) &#123; cout &lt;&lt; &quot;D showX: &quot; &lt;&lt; p-&gt;x &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">     Point* p &#x3D; new Point(1.0,2.0);</span><br><span class="line">     ColorPoint* cp &#x3D;  new ColorPoint(3.0,4.0,&quot;red&quot;);</span><br><span class="line">     D* d &#x3D; new D();</span><br><span class="line">     d-&gt;showX(p);   &#x2F;&#x2F; D showX: 1  原生调用，不涉及subtype转换</span><br><span class="line">     d-&gt;showX(cp);  &#x2F;&#x2F; D showX: 3  ColorPoint作为Point的subtype，可以替换Point参数</span><br><span class="line">     B* b &#x3D; d;      &#x2F;&#x2F; 将subtype D对象转换为supertype B</span><br><span class="line">     b-&gt;showX(cp);  &#x2F;&#x2F; D showX: 3, dynamic dispath，以对象实际类型(D*)而不是当前类型(B*)来查找方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了四个类，ColorPoint是Point的subtype，D是B的subtype。以下是一些你需要注意的点:</p><ol><li>如果D是B的subtype,那么D*也是B*的subtype</li><li>C++中的dynamic dispatch不是默认开启的，而是通过为指定方法<code>virtual</code>关键字手动开启的</li><li>对象d上调用showX(声明为virtual)方法，总能找到其对应类D的showX实现，而不管d是否被转换为supertype B*</li></ol><p>现在来考虑一个问题，如果B的showX函数声明为<code>virtual void showX(ColorPoint* p)</code>，实现不变，那么上面的<code>b-&gt;showX(cp)</code>会输出什么？答案是<code>B showX: 3</code>。熟悉C++的同学会知道这是因为C++支持重载，编译认识的函数符号是如<code>_showX_Point_</code>这种编码了参数类型的，修改函数参数类型后，将被编译器认为是另一个函数，而非override。但有一门不支持重载的静态OOP语言L，这个修改能够正常的dynamic dispatch吗？我的理解是可以的，传递给<code>B::showX</code>的ColorPoint总能被<code>D::showX</code>正确使用(<code>D:::showX</code>&lt;:<code>B::showX</code>)，这是因为静态OOP语言中的对象不能修改方法(方法属于类)，只能修改字段，也就是在前面说的depth subtype中，舍弃了mehotd field setter，得到method field depth subtyping。</p><p>然后来看看this指针，对C++有一定理解的同学通常将this指针看做类方法的一个隐藏参数，它由编译器自动传入。这种看法确实能更好地理解OOP，将类方法与普通函数统一起来。但有了subtype这个概念，再来看showX方法，B和D的showX方法类型分别为: <code>void showX(B* this, Point* p)</code> 以及 <code>void showX(D* this, Point* p)</code>，这里就出现一个很奇怪的现象，D的showX不再是B的showX的subtype,我只传给了showX B的对象，但可能调用到D的showX(需要D对象，而D对象包含比B对象更多的字段，可能引发未定义错误)。这是因为this参数是特殊处理的，虽然传给showX的实参只是B对象的地址，但它同时也是D对象的地址，编译器会透明地完成这层转换，保证D的showX拿到的是正确的D对象。这也是为什么多态要在指针下才能生效的原因(值拷贝只会拷贝值的静态类型对应内容，后面多余的派生类数据以及虚函数表信息会丢失)。</p><p>结合C++对象内存布局来回顾一下:</p><p><img src="/assets/image/201905/cpp-object-model.png" alt=""></p><ol><li>ColorPoint对象只会基于Point对象增加字段，本身是满足subtype语义的</li><li>ColorPoint向后追加新增字段，而不会变更基类对象的内存布局，这样可以让对象地址转换更轻量(不必做任何额外操作)</li><li>vtable指针会在对象创建时即初始化好，不管该对象地址被转换为何种类型，vtable总是指向对象实际类型的虚函数实现(如果没实现，则指向父类该函数)</li></ol><p>如果我们省掉vtable这些细节，将这个对象模型扩展一下，结合function depth subtype，它应该是这样:</p><p><img src="/assets/image/201905/static-object-model.png" alt=""></p><h4 id="mutiple-inheritance-1"><a href="#mutiple-inheritance-1" class="headerlink" title="mutiple inheritance"></a>mutiple inheritance</h4><p>C++支持多重继承，为了解决多重继承的命名冲突和冗余数据的问题，它可以在subclass构造函数中指定要哪些字段用哪个superclass的。另外它提供一个叫虚继承(virtual interitance)的机制来解决菱形继承的数据冗余问题，即D继承自B,C，B,C有个共同父类A，那么C只会有一份继承自A的数据。</p><p>Java/C#不支持多重继承，它们的类只能有一个直接父类，但是可以实现多个接口(Interface)，Interface是一堆方法的集合，它没有任何实现，当然也不能实例化。相比Ruby的mixins这种”实现继承”言，这种”声明继承”更安全，因为Interface没有任何的字段，即使方法声明有冲突，子类也只需要提供一份实现，并以此为准，没有歧义。</p><p>C++还提供纯虚函数的概念，即方法本身只包含声明，没有实现，在Java中的抽象方法也提供类似的机制，包含抽象方法或纯虚函数的类就和Ruby中的mixins很像，它既可包含声明，也可包含实现，并且不能实例化对象。当类中的所有方法都为抽象方法并且不包含任何字段时，这个类也就变成了Interface。</p><h4 id="generics"><a href="#generics" class="headerlink" title="generics"></a>generics</h4><p>前面我们所说的<strong>subtyping(子类化)</strong>，也叫做 <strong>subtype polymorphism(子类型多态)</strong> ，而另一种静态语言中常见的用于放宽type checker，提高灵活性和复用性的方案叫 <strong>parametric polymorphism(参数多态)</strong> ，也叫做<strong>generics(泛型)</strong> ，generics是很多静态语言都要考虑的一个特性，不只是OOP。比如ML就有强大的类型推导，可以实现很灵活的泛型编程。</p><p>generics用在那些需要表述<strong>任何类型</strong>的地方，即不关心对象的实际类型，通常出现在容器结构和通用算法中，比如大名鼎鼎的C++ STL，它其实就是对泛型的极致运用，封装了各类常用的容器以及各种常用算法，比如如下是一个 STL 中的 reduce 实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="comment">// since C++20</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIt first, InputIt last, T init, BinaryOperation op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">        init = op(<span class="built_in">std</span>::move(init), *first); <span class="comment">// std::move since C++20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几行代码充分展示了STL的一些基础特性:</p><ol><li>通过迭代器抽象对容器元素的基本操作: 借鉴于函数式编程，上例的<code>InputIt</code>提供元素类型<code>T</code>的容器的操作(<code>++</code>,<code>!=</code>,<code>*</code>等)接口，容器本身并不出现在泛型中，它可以是任意Stack, List, Pair等提供了迭代器的标准甚至自定义容器</li><li>函数本身亦可泛型: 已经有函数是第一类对象的雏形，上例中的BinaryOperation既可是一个函数，也可是一个函数对象(重载了<code>()</code>的对象)，STL提供了很多函数对象，如加减乘除</li><li>大量的运算符重载: 双刃剑(方便vs隐晦)，主要是为了兼容C，比如迭代器<code>++</code>操作本身相当于<code>Next()</code></li><li>泛型声明本身不包含对class的任何约束说明: 依赖于编译时对泛型代码的生成来检查，并且运算符重载，隐式构造函数等特性让算法在理解和使用在有一些负担。这是个人认为还不够好的地方，对应的解决方案有: <strong>bounded generic types</strong>，下一节会提到</li></ol><p>C++/Java/C#都提供了泛型机制，但它们的实现方式有些区别，Java的实现方式是”类型擦除(Type Erasure)”，即在编译时将<code>List&lt;T&gt;</code>变为<code>List&lt;Object&gt;</code>，然后加上一些类型检查和类型提取转换，Java运行时没有关于泛型的任何信息，它只会看到Object(动态类型语言的思路)，这样最大的好处在于兼容性，即老的Java运行时也可以运行泛型代码，缺点是由于运行时不知道T的具体类型，因此无法对T进行诸如instanceof,new等操作。C#/C++的泛型则被称为”模板泛型”，即有运行时的支持，对使用者来说像是为每个类型T都生成了对应的ListT类，因此克服了Java这方面的缺点，是语义完整的。C++的template则更强大，它可以实现所谓的元编程，即在模板语法中可以使用分支(偏特化)，递归等特性达到图灵完全性，如你可以通过模板语法求斐波那契数列(写法和函数式语言类似)，并将运算结果或错误在编译器就吐出来，因此C++被戏称”两层语言”，一层是生成C++目标代码的函数式语言(使用模板语法)，另一层才是命令式语言(C++本身)。当然这并不是C++的初衷，这里不再展开。</p><p>Go目前没有对开发者提供泛型(据说Go2.0会加入泛型)，它的代码复用主要靠interface+reflect(额外运行时type check开销)或code generator(额外的复杂度和开发成本)来实现，它们只能解决很少一部分对泛型的需求，因此Go在这方面被广为诟病，比如知乎上<a href="https://www.zhihu.com/question/62991191">Go有什么泛型的实现方法？</a>的高票答案，相信大部分Gopher都深有体会:</p><p><img src="/assets/image/201905/go-generics.gif" alt=""></p><blockquote><blockquote><p>2022.1.22更新: <a href="https://wudaijun.com/2020/12/go-generics/">Go1.18中已经实现了泛型</a></p></blockquote></blockquote><h4 id="generics-vs-subtyping"><a href="#generics-vs-subtyping" class="headerlink" title="generics vs subtyping"></a>generics vs subtyping</h4><p>那么有了generics后，我们还需要subtyping么？比如前面的Pair类，如果使用subtype来完成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LamePair</span> </span>&#123;</span><br><span class="line">    Object x;</span><br><span class="line">    Object y;</span><br><span class="line">    LamePair(Object _x, Object _y)&#123; x=_x; y=_y; &#125;</span><br><span class="line">    <span class="function">LamePair <span class="title">swap</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> LamePair(y,x); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">String s = (String)(<span class="keyword">new</span> LamePair(<span class="string">&quot;hi&quot;</span>,<span class="number">4</span>).y); <span class="comment">// error caught only at run-time</span></span><br></pre></td></tr></table></figure><p>由于在构建LamePair时，进行了向上转换(将传入的参数转换为共同的supertype Object)，因此这里实际会有类型信息丢失，当外部想要再次获取LamePair中的元素时，就不得不进行一次向下转换(downcast)，如<code>(String)e</code>，这类转换属于run-time check，即将一部分本应在静态类型检查时暴露的错误放到了运行时，这是有悖静态类型语言的初衷的。所有的对象都属于Object，将所有的方法参数返回值都声明为Object，这是动态类型语言的思路。</p><p>因此subtyping在某些场景下不能替换generics，那反过来呢，如果我们用C++的template来实现distFromOrigin2:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">float</span> x;</span><br><span class="line"><span class="keyword">float</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">X</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Y</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> &#123;</span></span><br><span class="line"><span class="keyword">float</span> x;</span><br><span class="line"><span class="keyword">float</span> y;</span><br><span class="line"><span class="built_in">string</span> color;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">X</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Y</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">distFromOrigin2</span><span class="params">(T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(b.X()*b.X() + b.Y()*b.Y());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，仍然是一种很蹩脚的写法，由于泛型函数本身对类型缺乏认识，通常需要一堆辅助函数(<code>X()</code>,<code>Y()</code>)来帮忙完成算法的运作，前面的STL accumulate中的迭代器类型参数也是这个作用，即便如此虽然<code>distFromOrigin2</code>复用了，但并没解决Point/ColorPoint的其它字段和方法的复用问题。当然，就本例而言，即便这里的ColorPoint是Point的subtype，C++ template额外生成的函数以及丢失的dynamic dispatch也提示着将distFromOrigin2实现为Point方法是更好的选择。</p><p>综上，subtype和generics各自有自己的适用情形，它们作用于不同维度。subtype是基于supertype上的操作复用，强调类与类的复用关系。而generics基于任意类型T，对T之上的容器封装(如Stack,List,Pair,Swap等)和算法复用(如Sort,Find,Reduce等)，强调类通用的扩展。从另一个角度来讲，subtype可以实现运行时多态(dynamic dispatch)，而generics则是编译期多态(编译期生成新的类/函数)。</p><p>事实上，Java/C#同时支持subtyping和generics，因此它们支持一种将两种结合的polymorphism: <strong>bounded generic types</strong>，核心思想是通过subtype来限制generics可接受的类型，想要鱼和熊掌兼得。比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bound</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Point</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> T objRef; </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bound</span><span class="params">(T obj)</span></span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.objRef = obj; </span><br><span class="line">    &#125; </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">doRunTest</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.objRef.distFromOrigin(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过subtype让Bound对传入的T有一定的基本认知，可以调用Point的方法(无需外部传入)，通过generics让这些基于Point类之上的算法可复用。</p><h4 id="oop-in-golang"><a href="#oop-in-golang" class="headerlink" title="oop in golang"></a>oop in golang</h4><p>我将Go单独放到一节，因为它与我们熟知的C++/Java/C#/Ruby等OOP语言很不一样，它有一些创新的地方，用来解决那些困扰了OOP几十年的难题。</p><p>如果按照我们前面给出来的OOP定义，Go是OOP语言，或者说它可以实现OOP编程范式。但是Go没有继承(<code>is-a</code>)的概念，即没有subclass的概念，如果一门OOP语言没有subclass，那么我们会考虑两个问题: 1. Go如何实现class代码复用？2. Go如何实现subtype? 下面分别讨论这两个问题。</p><p>Go没有<code>is-a</code>的概念，它推崇<a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">composition over inheritance principle</a>原则，即组合胜于继承，用<code>has-a</code>替代<code>is-a</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Print A Name: &quot;</span>, a.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Print B Name: &quot;</span>, b.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a1 := A&#123;Name: <span class="string">&quot;Name A1&quot;</span>&#125;</span><br><span class="line">b := &amp;B&#123;A: a1&#125;</span><br><span class="line">a2 := A&#123;Name: <span class="string">&quot;Name A2&quot;</span>&#125;</span><br><span class="line">b.A = a2</span><br><span class="line">b.Print()   <span class="comment">// Print B Name:  Name A2</span></span><br><span class="line">b.A.Print() <span class="comment">// Print A Name:  Name A2</span></span><br><span class="line"><span class="comment">// a := (*A)(b) // cannot convert expression of type *B to type *A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码展示了Go如何通过组合而非继承来实现代码复用，当B需要复用A的代码时，它将A声明为类的一个匿名字段，之后就可以通过B来访问A中的方法和字段，当然这里也需要一套名字查找规则: 1. 先查找B中有没有对应的方法和字段 2. 再从后往前查找B中的匿名字段有无该方法和字段。因此可以通过B调用A的方法实际上是编译器的语法糖，并不是dynamic dispatch，因为Go只能通过子类对象调用子类方法，而不能通过父类对象调用子类方法。事实上，Go的子类对象无法转换为父类对象，从实现上来说，它们就是组合关系，你可以动态将B中的A字段赋为其它A对象。当然，这里的”父类””子类”叫法是不严谨的，因为Go没有subclass。</p><p>解决了面向对象的代码复用问题，我们再来看Go如何实现subtype，Go的subtype不是通过subclass来实现的，而是通过Interface来实现的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Printer interface &#123;</span><br><span class="line">Print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test(p Printer) &#123;</span><br><span class="line">p.Print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test2(a *A) &#123;</span><br><span class="line">    a.Print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(&amp;a1)</span><br><span class="line">test(b)</span><br><span class="line">test2(b) &#x2F;&#x2F; error: cannot use b (type *B) as type *A in argument to test2</span><br></pre></td></tr></table></figure><p>在Java/C#/Go中，都有Interface的概念，但Java/C#的接口实现是需要显式声明的(即类在定义时就知道自己实现了哪些接口)，但是Go的接口不需要显式声明implement，可以在运行时动态判断(实现细节参考<a href="https://wudaijun.com/2018/01/go-interface-implement/">这里</a>)，这个特性为程序提供了极大的灵活性。A,B并不知道自己实现了Printer接口，它在定义的时候甚至还没有出现Printer接口，或者只有个类似Ouputter之类的接口包含相同的方法，Interface将类如何定义和类如何被使用分离开，比如你只要实现了<code>Read(p []byte) (n int, err error)</code>方法，就实现了<code>io.Reader</code>接口，就可以使用<code>ioutil.Read/ReadAll</code>等lib API。</p><p>总结一下，Go通过组合加编译器的一些静态查找规则来实现代码复用，通过Interface来实现subtype，而如C++/Java/C#等语言用subclass来同时提供两种功能，因此导致类关系错综复杂，甚至一度被戏称COP(Class-oriented programing)而非OOP。虽然Interface实现的subtype不如subclass实现的subtype一样强大(Interface只是方法声明集合，而superclass还包含字段)，但Interface的灵活性远胜于需要显式指定的superclass，并且避免了OOP继承长久以来的痛点。</p><h3 id="dynamic-type-vs-static-type"><a href="#dynamic-type-vs-static-type" class="headerlink" title="dynamic type vs static type"></a>dynamic type vs static type</h3><p>简单来说，静态语言的设计宗旨是尽可能在静态检查中多做事情，通过静态检查来过滤大部分的类型错误，优点是程序运行更稳定，Debug也更容易，缺点是会一定程度限制代码设计的灵活性，因此通常需要subtype来在通过规则放宽type check的限制。</p><p>而动态语言的设计宗旨是优先支持更灵活的代码设计(如duck typing)，将type check放到了run-time，优点是程序更灵活，开发效率通常更高，但程序运行的稳定性会差一些，遇到问题的调试也要更复杂。毕竟没有静态类型检查，允许了更灵活的设计，也放行了很多类型错误。</p><h3 id="oop-vs-fp"><a href="#oop-vs-fp" class="headerlink" title="oop vs fp"></a>oop vs fp</h3><p>计算机业界有句古老的名言: “程序=数据结构+算法”。</p><p>OOP(Object-oriented programming)偏向数据结构，函数只是数据结构的行为(对象的方法)，通过class来封装对象，通过subclass来复用对象。OOP的终极奥义是: 一切皆对象，甚至对象的类也是对象。</p><p>FP(Functional programming)偏向算法(函数)，即函数为第一类值，数据只是函数的参数或者执行环境(闭包)。用闭包，柯里化，高阶函数等去完成函数的封装和复用。FP的终极奥义是: 一切皆函数，连数据也可以是函数。</p><p>举个例子，我们可以将数据结构和算法分为两个维度，做成一个表格:</p><p><img src="/assets/image/201905/data-func-grid.png" alt=""></p><p>表的行表示各种数据类型，列为对应的操作。每个编程语言必须要做的就是定义每种数据类型执行每种操作时的行为。</p><p>OOP的做法是按照各个行划分，定义各个数据结构的类，然后在类上面实现该类型所支持的各个方法。而FP的做法是按照各个列划分，定义各个函数，如toString，然后在函数中去区分各个数据类型并实现。</p><p>从这个角度来说，FP和OOP只是以不同的方式来组织你的代码，OOP按照数据来聚合，FP按照函数来聚合，如果使用OOP，那么添加数据类型很方便，你只需要在新定义的类中去实现它支持的操作，无需影响其它已有类。同理如果使用FP，则新添加一个函数很方便。</p><p>另一个比较有意思的点是，FP的二元操作要比OOP更直观，比如我们的add操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun add (v1,v2) &#x3D;</span><br><span class="line">    case (v1,v2) of</span><br><span class="line">      (Int i, Int j) &#x3D;&gt; Int (i+j)</span><br><span class="line">    | (Int i, Point(x,y)) &#x3D;&gt; Point(x+i, y+i)</span><br><span class="line">    | (Point(x,y), Int i) &#x3D;&gt; add(v2, v1) &#x2F;&#x2F; 代码复用</span><br><span class="line">    | (Point(x1,y1), Point(x2,y2)) &#x3D;&gt; Point(x1+x2, y1+y2)</span><br></pre></td></tr></table></figure><p>在FP中，二元操作很直观，<code>add(Point, Int)</code>和<code>add(Int, Point)</code>可以复用，而在OOP中:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span></span></span><br><span class="line">    def add v</span><br><span class="line">        <span class="keyword">if</span> v.is_a? Int</span><br><span class="line">            addInt(v)</span><br><span class="line">        <span class="keyword">elsif</span> v.is_a? Point</span><br><span class="line">            addPoint(v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addInt</span><span class="params">(v)</span></span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面的代码虽然也算直观，但有两个问题，一是代码复用不好，<code>Int.addPoint</code>和<code>Point.addInt</code>的实现其实是一样的，即使想要复用代码，只用一份实现，那这份实现应该放在Int类还是Point类呢？第二个问题是这里其实是将FP和OOP混着用，在OOP中，应该尽量避免通过运行时判断对象属于哪个类，纯正的OOP应该通过函数调用+dynamic dispatch来避免类型判断:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:i</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(v)</span></span> <span class="comment"># first dispatch</span></span><br><span class="line">        v.addInt(<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addInt</span><span class="params">(v)</span></span> <span class="comment"># second dispatch: v is Int</span></span><br><span class="line">        Int.new(v.i + i)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addPoint</span><span class="params">(v)</span></span> <span class="comment"># second dispatch: v is Point</span></span><br><span class="line">        Point.new(v.x+i, v.y+i)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(v)</span></span> <span class="comment"># first dispatch</span></span><br><span class="line">        v.addPoint(<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addInt</span><span class="params">(v)</span></span> ... <span class="keyword">end</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addPoint</span><span class="params">(v)</span></span> ... <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在虽然是纯正的OOP了，但实际上维护这些代码却很麻烦，假设我们增加一个String类型，它也可以参与add运算，那么除了定义String类型本身以外，我们还需要去已有所有类型中添加addString方法，在这种情况下，OOP增加一个数据类型也不那么方便了。</p><ol><li>静态OOP语言如C++/Java/C#可能会提供一种重载的机制，允许同一个方法名不同的类型参数，编译器会自动选择匹配的函数调用。这能够避免运行时的类型检查，也不用二次分发，但复用性和扩展性仍然不好。</li><li>在Java/C#中，可以通过Interface来声明所有的addInt/Point方法，让Int,Point实现这个接口，这样在添加String类型时，在Interface中添加addString方法，静态类型检查能够保证所有的子类都实现了addString</li></ol><p>PS: 这里只是从程序结构的角度对比FP和OOP，事实上FP的一些理念还来自于lamda演算和数学领域，因此大部分的FP语言还有不可变语义，纯函数等特性。</p><p>FP或OOP或其它的编程范式，本质上是以不同的方式对现实问题进行建模，不管是”一切皆函数”还是”一切皆对象”，都是理想化的解决方案。现实中可能没有编程语言完美实现了某一编程范式，更多地是借鉴和吸收，同时支持多种编程范式，毕竟语言是用来解决问题的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这段时间学习OOP对语言和编程范式有一些新的理解，之前系统整理过&lt;a href=&quot;https://wudaijun.com/2018/05/understand-functional-programing/&quot;&gt;函数式编程&lt;/a&gt;，因此先从OOP谈起。我们先回顾下面向对象(OOP)的核心思想:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有的值都是对象&lt;/li&gt;
&lt;li&gt;对象与对象之间通过方法调用(或者说是发消息)进行通信&lt;/li&gt;
&lt;li&gt;对象可以有自己的私有字段/状态，只有对象的方法可以访问和更新这些字段&lt;/li&gt;
&lt;li&gt;每个对象都是一个类(Class)的实例，类定义了对象的行为(内部数据和方法实现)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与函数式的”一切皆函数”一样，OOP也有一个宏大的目标”一切皆对象”。&lt;/p&gt;</summary>
    
    
    
    <category term="programing" scheme="http://wudaijun.com/categories/programing/"/>
    
    
    <category term="programing" scheme="http://wudaijun.com/tags/programing/"/>
    
  </entry>
  
</feed>
