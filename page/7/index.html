<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/theme/favicon-100x100.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/theme/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/theme/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wudaijun.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="wudaijun&#39;s blog">
<meta property="og:url" content="http://wudaijun.com/page/7/index.html">
<meta property="og:site_name" content="wudaijun&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wudaijun">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://wudaijun.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>wudaijun's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="wudaijun's blog" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wudaijun's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Done is better than perfect</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wudaijun.com/2016/12/erlang-memory-debug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/theme/avatar.png">
      <meta itemprop="name" content="wudaijun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wudaijun's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/erlang-memory-debug/" class="post-title-link" itemprop="url">Erlang 内存问题诊断</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-26 00:00:00" itemprop="dateCreated datePublished" datetime="2016-12-26T00:00:00+08:00">2016-12-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/erlang/" itemprop="url" rel="index"><span itemprop="name">erlang</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2016/12/erlang-memory-debug/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2016/12/erlang-memory-debug/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通过<code>erlang:memory()</code>查看节点内存占用总览，需要通过静态和动态两个维度对内存进行考核：</p>
<ul>
<li>静态: 各类内存占用比例，是否有某种类的内存占用了节点总内存的绝大部分</li>
<li>动态: 各类内存增长特性，如增长速度，或是否长期增长而不回收(atom除外)</li>
</ul>
<p>找出有疑似内存泄露的种类后，再进行下一步分析</p>
<h3 id="atom"><a href="#atom" class="headerlink" title="atom"></a>atom</h3><p>atom不会被GC，这意味着我们应该对atom内存增长更加重视而不是忽略。在编写代码时，尽量避免动态生成atom，因为一旦你的输入源不可靠或受到攻击(特别针对网络消息)，atom内存增长可能导致节点crash。可以考虑将atom生成函数替换为更安全的版本：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/12/erlang-memory-debug/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wudaijun.com/2016/12/unicode-in-erlang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/theme/avatar.png">
      <meta itemprop="name" content="wudaijun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wudaijun's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/unicode-in-erlang/" class="post-title-link" itemprop="url">Erlang Unicode编码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-17 00:00:00" itemprop="dateCreated datePublished" datetime="2016-12-17T00:00:00+08:00">2016-12-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/erlang/" itemprop="url" rel="index"><span itemprop="name">erlang</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2016/12/unicode-in-erlang/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2016/12/unicode-in-erlang/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Unicode基础"><a href="#Unicode基础" class="headerlink" title="Unicode基础"></a>Unicode基础</h2><h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><p>定义字符集中每个字符的<strong>codepoint(数字编码)</strong></p>
<ul>
<li>ASCII: 不用多说，编码空间为7位(0-127)</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ISO/IEC_8859-1">ISO 8859-1</a>: 又称Latin-1，以ASCII为基础，在空置的0xA0-0xFF的范围内，加入96个字母及符号。编码空间为8位(0-255)</li>
<li>UCS-2: 16位编码空间 又称基本多文种平面或零平面</li>
<li>UCS-4: 32位编码空间 在UCS-2基本上，加入辅助平面(目前有16个辅助平面，至少需要21位)</li>
<li>注1: UCS(Universal Character Set, <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86">通用字符集</a>)</li>
<li>注2: 以上四种编码都是向前兼容的，通常我们所说的Unicode编码指UCS-2和UCS-4，目前广泛运用的是UCS-2</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/12/unicode-in-erlang/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wudaijun.com/2016/11/docker-erlang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/theme/avatar.png">
      <meta itemprop="name" content="wudaijun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wudaijun's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/11/docker-erlang/" class="post-title-link" itemprop="url">探索Docker在Erlang集群中的应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-11-05 00:00:00" itemprop="dateCreated datePublished" datetime="2016-11-05T00:00:00+08:00">2016-11-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2016/11/docker-erlang/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2016/11/docker-erlang/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>接<a target="_blank" rel="noopener" href="http://0.0.0.0:4444/2016/11/docker-basic/">上篇</a>，结合Erlang，对Docker的实际应用进一步理解。并探索将Docker应用到Erlang集群的方案。</p>
<h2 id="简单Docker交互"><a href="#简单Docker交互" class="headerlink" title="简单Docker交互"></a>简单Docker交互</h2><p>下面是个简单的echo server：</p>
<pre><code>-module(server_echo).
-export([start/0]).

start() -&gt;
     io:format(&quot;SERVER Trying to bind to port 2345\n&quot;),
     &#123;ok, Listen&#125; = gen_tcp:listen(2345, [ binary
                                         , &#123;packet, 0&#125;
                                         , &#123;reuseaddr, true&#125;
                                         , &#123;active, true&#125;
                                         ]),
     io:format(&quot;SERVER Listening on port 2345\n&quot;),
     accept(Listen).

 accept(Listen) -&gt;
     &#123;ok, Socket&#125; = gen_tcp:accept(Listen),
     WorkerPid = spawn(fun() -&gt; echo(Socket) end),
     gen_tcp:controlling_process(Socket, WorkerPid),
     accept(Listen).

 echo(Socket) -&gt;
     receive
         &#123;tcp, Socket, Bin&#125; -&gt;
             io:format(&quot;SERVER Received: ~p\n&quot;, [Bin]),
             gen_tcp:send(Socket, Bin),
             echo(Socket);
         &#123;tcp_closed, Socket&#125; -&gt;
             io:format(&quot;SERVER: The client closed the connection\n&quot;)
     end.
</code></pre><p>简单起见，我们直接用<code>telnet</code>命令对echo server进行测试。现在，考虑如何在Docker容器中运行echo server。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/11/docker-erlang/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wudaijun.com/2016/11/docker-basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/theme/avatar.png">
      <meta itemprop="name" content="wudaijun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wudaijun's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/11/docker-basic/" class="post-title-link" itemprop="url">Docker 学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-11-01 00:00:00" itemprop="dateCreated datePublished" datetime="2016-11-01T00:00:00+08:00">2016-11-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2016/11/docker-basic/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2016/11/docker-basic/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-理解-Docker"><a href="#一-理解-Docker" class="headerlink" title="一. 理解 Docker"></a>一. 理解 Docker</h2><p>Docker是一种轻量级的虚拟化方案，虚拟化本身可以从两个角度来理解：</p>
<ul>
<li>隔离性：可传统的虚拟机类似，资源隔离(进程，网络，文件系统等)可用于更好地利用物理机。Docker本身虚拟化的开销非常小，这也是它相对于传统虚拟机最大的优势</li>
<li>一致性：同样一份虚拟机镜像，可以部署在不同的平台和物理机上，并且内部的环境，文件，配置是一致的，这在当前多样化的平台，日益复杂的配置/部署流程，以及团队和团队间的协作中，有着重要的意义。想象一下，当你用Docker提交代码时，你做的事情跟以前是完全不同的。在以前我们只是把代码提交上去，而在Docker中我们把整台计算机（虚拟机）提交上去。为什么Docker这么火，就是因为它帮助开发者很简单的就让自己的开发环境跟生产环境一致。环境的标准化，意味着目录、路径、配置文件、储存用户名密码的方式、访问权限、域名等种种细节的一致和差异处理的标准化。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/11/docker-basic/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wudaijun.com/2016/10/erlang-server-design7-cluster-bug-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/theme/avatar.png">
      <meta itemprop="name" content="wudaijun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wudaijun's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/10/erlang-server-design7-cluster-bug-note/" class="post-title-link" itemprop="url">开发笔记(7) 记线上一次回档BUG</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-10-17 00:00:00" itemprop="dateCreated datePublished" datetime="2016-10-17T00:00:00+08:00">2016-10-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/gameserver/" itemprop="url" rel="index"><span itemprop="name">gameserver</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2016/10/erlang-server-design7-cluster-bug-note/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2016/10/erlang-server-design7-cluster-bug-note/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>有十几个玩家报告被回档，几小时到一两天不等</p>
<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>在我们的<a href="http://wudaijun.com/2016/01/erlang-server-design5-server-node/">集群架构</a>中，集群有若干GS节点，每个GS节点可部署N个GS服务器，整个集群所有的玩家进程注册于cluster，我们通过为每个服开一个player_mgr来维护单服玩家状态，player_mgr维护{player_id, agent_pid, player_pid}三元组，用户处理多点登录，单服逻辑，离线玩家LRU等。cluster本身只提供服务注册/注销，如果做服务替换(如agent)，确保服务的唯一性(如player)应该由外部逻辑来确保，cluster并不知晓内部各种服务的特性。player进程启动/终止时，会向player_mgr和cluster分别注册/注销自己。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/10/erlang-server-design7-cluster-bug-note/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wudaijun.com/2016/09/goa-intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/theme/avatar.png">
      <meta itemprop="name" content="wudaijun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wudaijun's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/goa-intro/" class="post-title-link" itemprop="url">goa - go web框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-09-20 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-20T00:00:00+08:00">2016-09-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2016/09/goa-intro/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2016/09/goa-intro/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h3><p><a target="_blank" rel="noopener" href="https://github.com/goadesign/goa">goa</a>是基于微服务的go语言框架，能够有效帮助开发人员快速开发基于微服务的系统。它通过DSL和代码生成器来生成样板代码和辅助套件(如文档，客户端模块，客户端工具等)。这些生成数据均基于服务的设计描述，goa遵循<strong>单一数据源</strong>(Single Source of Truth, SSOT)原则，任何对设计的改变，都将自动反映到系统各处，</p>
<p>goa可以分为三个部分：</p>
<ul>
<li>goa的设计语言是内置DSL，用于描述微服务的设计</li>
<li>goa代码生成器，用于根据DSL描述生成代码模块，辅助工具，和文档等</li>
<li>goa利用生成代码和用户代码来实现一个服务，并提供一个完全可插拨的框架</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/09/goa-intro/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wudaijun.com/2016/09/erlang-rebar3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/theme/avatar.png">
      <meta itemprop="name" content="wudaijun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wudaijun's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/erlang-rebar3/" class="post-title-link" itemprop="url">Rebar3 Erlang/OTP构建利器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-09-10 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-10T00:00:00+08:00">2016-09-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/erlang/" itemprop="url" rel="index"><span itemprop="name">erlang</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2016/09/erlang-rebar3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2016/09/erlang-rebar3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一-依赖管理"><a href="#一-依赖管理" class="headerlink" title="一. 依赖管理"></a>一. 依赖管理</h3><h4 id="1-包依赖和源码依赖"><a href="#1-包依赖和源码依赖" class="headerlink" title="1. 包依赖和源码依赖"></a>1. 包依赖和源码依赖</h4><p>Rebar3支持两种依赖：</p>
<pre><code>&#123;deps,[
  %% 包依赖
  rebar,
  &#123;rebar,&quot;1.0.0&quot;&#125;,
  &#123;rebar, &#123;pkg, rebar_fork&#125;&#125;, % rebar app under a different pkg name
  &#123;rebar, &quot;1.0.0&quot;, &#123;pkg, rebar_fork&#125;&#125;,
  %% 源码依赖
  &#123;rebar, &#123;git, &quot;git://github.com/erlang/rebar3.git&quot;&#125;&#125;,
  &#123;rebar, &#123;git, &quot;http://github.com/erlang/rebar3.git&quot;&#125;&#125;,
  &#123;rebar, &#123;git, &quot;https://github.com/erlang/rebar3.git&quot;&#125;&#125;,
  &#123;rebar, &#123;git, &quot;git@github.com:erlang/rebar3.git&quot;&#125;&#125;,
  &#123;rebar, &#123;hg, &quot;https://othersite.com/erlang/rebar3&quot;&#125;&#125;,
  &#123;rebar, &#123;git, &quot;git://github.com/erlang/rebar3.git&quot;, &#123;ref, &quot;aef728&quot;&#125;&#125;&#125;,
  &#123;rebar, &#123;git, &quot;git://github.com/erlang/rebar3.git&quot;, &#123;branch, &quot;master&quot;&#125;&#125;&#125;,
  &#123;rebar, &#123;git, &quot;git://github.com/erlang/rebar3.git&quot;, &#123;tag, &quot;3.0.0&quot;&#125;&#125;&#125;
  ]&#125;
</code></pre>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/09/erlang-rebar3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wudaijun.com/2016/09/go-notes-2-procedural-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/theme/avatar.png">
      <meta itemprop="name" content="wudaijun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wudaijun's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/go-notes-2-procedural-programming/" class="post-title-link" itemprop="url">Go 笔记(2) 顺序编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-09T00:00:00+08:00">2016-09-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2016/09/go-notes-2-procedural-programming/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2016/09/go-notes-2-procedural-programming/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="不定参数-amp-多返回值"><a href="#不定参数-amp-多返回值" class="headerlink" title="不定参数&amp;多返回值"></a>不定参数&amp;多返回值</h2><p>不定参数只能是最后一个参数，它实际上是数组切片参数的语法糖：</p>
<pre><code>// 语法糖 相当于 func myfunc(args []interface&#123;&#125;)
func myfunc(args ...interface&#123;&#125;)&#123;
    for _, arg := range args &#123;
    fmt.Println(arg)
&#125;

// 参数会被打包为 []&#123;arg1,arg2,arg3&#125;
myfunc(arg1,arg2,arg3)
// 要完成可变参数的完美传递 需要用...将Slice打散
func myfunc2(args ...interface&#123;&#125;)
    // 此时args已经是Slice 如果不打散将作为一个参数 不能完美传递
    myfunc(args)
    // 编译器在此处有优化 最终会直接将args传入 不会打散再打包 参考: http://www.jianshu.com/p/94710d8ab691
    myfunc(args...) 
end
</code></pre><p>多返回值为函数提供了更大的便利性，无需传引用或者专门构造返回值结构体，并且在错误处理方面也更简便，在前面的示例代码中已经初尝甜头。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016/09/go-notes-2-procedural-programming/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wudaijun.com/2016/09/go-notes-3-object-oriented/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/theme/avatar.png">
      <meta itemprop="name" content="wudaijun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wudaijun's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/go-notes-3-object-oriented/" class="post-title-link" itemprop="url">Go 笔记(3) 面向对象和接口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-09T00:00:00+08:00">2016-09-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2016/09/go-notes-3-object-oriented/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2016/09/go-notes-3-object-oriented/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>探索Go类型扩展，类和继承，以及接口的用法和实现。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="1-类型扩展"><a href="#1-类型扩展" class="headerlink" title="1. 类型扩展"></a>1. 类型扩展</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">	</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// 定义了一个新类型:Integer，与int不能直接比较/赋值</span></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Integer)</span> <span class="title">Add</span><span class="params">(b Integer)</span> <span class="title">Integer</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-类和继承"><a href="#2-类和继承" class="headerlink" title="2. 类和继承"></a>2. 类和继承</h3><p>在Go中，传统意义上的类相当于是对struct的类型扩展：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">	</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span>&#123;</span><br><span class="line">    x, y <span class="keyword">float64</span></span><br><span class="line">    w, l <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rect)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r.l * r.w</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c := Rect&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(c.Area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!--more->

Go中的继承通过匿名组合实现：

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">	</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">type</span> Base <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(base *Base)</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Base Foo()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(base *Base)</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Base Bar()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以组合的方式 定义继承</span></span><br><span class="line"><span class="comment">// 当derive.xxx在Derive中未找到时，将从基类Base中查找</span></span><br><span class="line"><span class="comment">// 也可通过derive.Base.xxx直接引用基类Base的方法或成员</span></span><br><span class="line"><span class="keyword">type</span> Derive <span class="keyword">struct</span> &#123;</span><br><span class="line">    Base</span><br><span class="line">    age <span class="keyword">int</span> <span class="comment">// 这里的同名成员将覆盖Base中的成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写基类方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Derive)</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Derive Bar()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    b := Base&#123;<span class="string">&quot;name&quot;</span>&#125;</span><br><span class="line">    d := Derive&#123;b, <span class="number">99</span>&#125;</span><br><span class="line">    d.Foo() <span class="comment">// == d.Base.Foo() 语法糖，Foo()函数的接收者只能是Base*</span></span><br><span class="line">    d.Bar()</span><br><span class="line">    fmt.Println(d.Name,d.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以以指针的方式从一个类型派生：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Derive <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Base</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候Derive的初始化需要提供一个Base的指针，它存在的意义类似于C++中的虚基类，Go将C++面向对象中一些”黑盒子”放到了台面上来，如this指针(作为一个特殊的参数显现出来)，虚函数表(Go中不允许派生类指针到基类指针的隐式转换，也就无需虚函数表来实现多态)，虚基类(通过显式基类指针，简洁明了的实现了这一需求)。</p>
<p>Go中没有private public等关键字，要使符号对其它包可见，则需要将该符号定义为大写字母开头。如Base中的Name能被其它引用了Base所在包的代码访问到，而Derive中age则不能。Go中没有类级别的访问控制。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口(interface)是一系列方法声明的组合，同时它本身也是一个类型。</p>
<h3 id="1-非侵入式接口"><a href="#1-非侵入式接口" class="headerlink" title="1. 非侵入式接口"></a>1. 非侵入式接口</h3><p>侵入式接口是指实现类需要明确声明实现了某个接口，目前C++/Java等语言均为侵入式接口。这类接口的缺点是类的实现方需要知道需求方需要的接口，并提前实现这些接口。这给类设计带来很大困难，因为设计类的时候，你并不知道也不应该关心它会被怎么使用。</p>
<p>GO中的接口是非侵入式的，接口与类分离，类只需要关心它应该有那些功能(函数)，而无需操心其应该满足哪些接口(契约)，<strong>一个类只要实现了某个接口的所有函数，那么它就实现了这个接口</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IReader <span class="keyword">interface</span>&#123;</span><br><span class="line">    Read(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">type</span> IWriter <span class="keyword">interface</span>&#123;</span><br><span class="line">    Write(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">type</span> IFile <span class="keyword">interface</span>&#123;</span><br><span class="line">    Read(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">    Write(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">type</span> IStream <span class="keyword">interface</span>&#123;</span><br><span class="line">    Read(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">    Write(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">type</span> IDevice <span class="keyword">interface</span>&#123;</span><br><span class="line">    Name() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// File定义无需指定实现接口，直接实现其方法即可</span></span><br><span class="line"><span class="comment">// 根据File类的实现，可以得到：</span></span><br><span class="line"><span class="comment">// File类实现了 IDevice接口</span></span><br><span class="line"><span class="comment">// File*类实现了以上所有接口</span></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Write</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f File)</span> <span class="title">Name</span><span class="params">()</span> <span class="params">(s <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go的非侵入式接口的意义：</p>
<ol>
<li>Go语言的标准库，没有复杂的继承树，接口与类之间是平坦的，无需绘制类库的继承树图。</li>
<li>实现类的时候，只需要关心自己应该提供哪些方法(自身功能)，不用再纠结实现哪些接口，接口由使用方按需定义，而不用事前规划。</li>
<li>不用为了实现一个接口而导入一个包，因为多引用一个外部的包，就意味着更多的耦合。接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口。</li>
</ol>
<h3 id="2-接口赋值"><a href="#2-接口赋值" class="headerlink" title="2. 接口赋值"></a>2. 接口赋值</h3><p>由于接口本身是一种类型，因此它可被赋值。接口赋值分为两种：将对象赋值给接口和将接口赋值给接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 将对象赋值给接口</span></span><br><span class="line"><span class="comment">// 赋值条件：对象需实现该接口</span></span><br><span class="line">f := File&#123;&#125;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">var</span> I1 IDevice = f</span><br><span class="line"><span class="comment">// ok. Go会根据 func (f File) Name() 自动生成 func (f *file) Name()方法</span></span><br><span class="line"><span class="keyword">var</span> I2 IDevice = &amp;f</span><br><span class="line"><span class="comment">// error. File类实现的IFile接口中，有函数的接收者为File*</span></span><br><span class="line"><span class="comment">// func (f *File) Read(buf []byte) 不能转化为 func (f File) Read(buf []byte)</span></span><br><span class="line"><span class="comment">// 因为前者可能在函数中改变f，后者不能，可能造成语义上的不一致</span></span><br><span class="line"><span class="keyword">var</span> I3 IFile = f</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">var</span> I4 IFile = &amp;f</span><br><span class="line"><span class="comment">// 赋值完成之后 可通过接口直接调用对象方法</span></span><br><span class="line">I1.Name()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 将接口赋值给接口</span></span><br><span class="line"><span class="comment">// 赋值条件：左值接口需是右值接口的子集</span></span><br><span class="line"><span class="keyword">var</span> I5 IReader = I1 <span class="comment">// error</span></span><br><span class="line"><span class="keyword">var</span> I6 IFile   = I3 <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">var</span> I7 IReader = I3 <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<h3 id="3-接口查询"><a href="#3-接口查询" class="headerlink" title="3. 接口查询"></a>3. 接口查询</h3><p>既然我们可以将对象或者接口赋值给接口，那么也应该有方法能让我们从一个接口查询出其指向对象的类型信息和接口信息：</p>
<pre><code>f := File&#123;&#125;
// 接口查询
var I1 IDevice = f
// 判断接口I1指向的对象是否实现了IFile接口
I2, ok := I1.(IFile) // ok = false File类型没有实现IFile接口 File*类型实现了

// 类型查询
// 方法一 type assertions
f2, ok := I1.(File) // ok = true
// 方法二 type switch
// X.(type)方法只能用在switch语句中
switch(I1.(type))&#123;
    case int:       // 如果I1指向的对象为int
    case File:      // 如果I1指向的对象为File
    ...
&#125;
</code></pre><h3 id="4-接口组合"><a href="#4-接口组合" class="headerlink" title="4. 接口组合"></a>4. 接口组合</h3><p>前面的IFile接口定义等价于：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IFile <span class="keyword">interface</span>&#123;</span><br><span class="line">    IReader</span><br><span class="line">    IWriter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口组合可以以更简便的方式复用接口类似于类继承，只不过没有成员变量。</p>
<h3 id="5-空接口"><a href="#5-空接口" class="headerlink" title="5. 空接口"></a>5. 空接口</h3><p>在Go中的任何对象都满足空接口<code>interface&#123;&#125;</code>，所以<code>interface&#123;&#125;</code>可以指向任何对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 <span class="keyword">interface</span>&#123;&#125; = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> v2 <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">var</span> v3 <span class="keyword">interface</span>&#123;&#125; = <span class="keyword">struct</span>&#123; x <span class="keyword">int</span> &#125;&#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v4 <span class="keyword">interface</span>&#123;&#125; = v3</span><br></pre></td></tr></table></figure>
<p><code>interface&#123;&#125;</code>比C++中的<code>void*</code>更强大，比<code>template&lt;&gt;</code>更灵活，结合接口查询和反射，构建底层代码变得非常容易。</p>
<h3 id="6-反射"><a href="#6-反射" class="headerlink" title="6. 反射"></a>6. 反射</h3><p>简单概括，反射一种检查存储在接口变量(任意类型值)中的“类型-值对”的机制。任何接口变量(包括空接口变量)都包含了其对应的具体类型和值信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="built_in">new</span>(File)</span><br><span class="line"><span class="keyword">var</span> r IReader</span><br><span class="line">r = f</span><br><span class="line">fmt.Println(reflect.TypeOf(r), reflect.ValueOf(r))</span><br><span class="line"><span class="comment">// 输出: *main.File &amp;&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> w IWriter</span><br><span class="line">w = r.(IWriter)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>IReader接口变量只提供了访问Read方法的能力，但其接口变量仍然保存了有关该值的所有类型信息，因此我们可以通过接口查询得到IWriter接口变量。接口的静态类型决定了哪些方法可以通过接口变量调用，但接口变量本身可能包含更大的方法集。</p>
<p>有了这个机制，我们才能通过反射从任意接口变量，获取对象完整的属性。关于反射的API都在reflect包中提供，通过<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>获取接口变量的Type和Value，reflect为Type和Value提供了大量的方法，如<code>Type.Kind()</code>,<code>Value.Interface()</code>等。</p>
<p>现在我们尝试通过反射修改接口变量的值：</p>
<pre><code>var x float64 = 3.4
v := reflect.ValueOf(x)
v.Set(4.1) // error: cannot use 4.1 (type float64) as type reflect.Value in argument to v.Set
</code></pre><p>由于在<code>refect.ValueOf(x)</code>中操作的是x的拷贝，因此实际上v.Set即使能操作成功，也不能如我们预期一般修改x的值。因此reflect提供<code>Value.CanSet()</code>来辨别这类不能成功修改的值：</p>
<blockquote>
<blockquote>
<p>CanSet reports whether the value of v can be changed. A Value can be changed only if it is addressable and was not obtained by the use of unexported struct fields. If CanSet returns false, calling Set or any type-specific setter (e.g., SetBool, SetInt) will panic.</p>
</blockquote>
</blockquote>
<p>我们可以通过*float64类型的反射来修改x的值:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type of p:&quot;</span>, p.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;CanSet of p:&quot;</span> , p.CanSet())</span><br><span class="line">v := p.Elem()</span><br><span class="line">fmt.Println(<span class="string">&quot;CanSet of v:&quot;</span> , v.CanSet())</span><br><span class="line"><span class="comment">// v的地址是有效的(保存在p.Value()中) 因此可以修改</span></span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br><span class="line">fmt.Println(v.Interface())</span><br><span class="line">fmt.Println(x)</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// type of p: *float64</span></span><br><span class="line"><span class="comment">// CanSet of p: false</span></span><br><span class="line"><span class="comment">// CanSet of v: true</span></span><br><span class="line"><span class="comment">// 7.1</span></span><br><span class="line"><span class="comment">// 7.1</span></span><br></pre></td></tr></table></figure>
<p>推荐阅读:</p>
<ol>
<li>接口和反射的好文：<a target="_blank" rel="noopener" href="https://blog.go-zh.org/laws-of-reflection">https://blog.go-zh.org/laws-of-reflection</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wudaijun.com/2016/09/go-notes-1-datastructures/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/theme/avatar.png">
      <meta itemprop="name" content="wudaijun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wudaijun's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/go-notes-1-datastructures/" class="post-title-link" itemprop="url">Go 笔记(1) 常用数据结构及实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-09T00:00:00+08:00">2016-09-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2016/09/go-notes-1-datastructures/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2016/09/go-notes-1-datastructures/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>学习一下go中常用的几种数据结构，结合源码了解其实现原理。</p>
<h2 id="一-类型系统"><a href="#一-类型系统" class="headerlink" title="一. 类型系统"></a>一. 类型系统</h2><h3 id="1-array"><a href="#1-array" class="headerlink" title="1. array"></a>1. array</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x [2]<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	x[<span class="number">1</span>] = <span class="number">9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	b := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">	f(a) <span class="comment">// error: cannot use a (type [3]int) as type [2]int in argument to f</span></span><br><span class="line">	f(b) <span class="comment">// 数组是值语义 因此f无法改变b中元素内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>array的特性:</p>
<ul>
<li>固定大小，且大小为类型的一部分</li>
<li>数组元素在内存中连续存放</li>
<li>值语义: 数组本身(传参会完整拷贝数组)</li>
</ul>
<h3 id="2-slice"><a href="#2-slice" class="headerlink" title="2. slice"></a>2. slice</h3><h4 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h4><p>slice(切片)，提供描述array部分连续元素的能力。</p>
<blockquote>
<blockquote>
<p>A slice is a data structure describing a contiguous section of an array stored separately from the slice variable itself. A slice is not an array. A slice describes a piece of an array.</p>
</blockquote>
</blockquote>
<p>slice只持有array的引用，而不会拷贝元素，因此它在实现上只需持有指向array元素的pointer和slice长度length即可。但由于slice的length可以收缩或扩张，因此slice还需要一个字段capacity来保存其最初引用的array的size，当length &gt; capacity时，说明对array的访问越界，触发panic错误。</p>
<p>因此slice一共有三个字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sliceHeader&#123;</span><br><span class="line">	Length 	<span class="keyword">int</span>			<span class="comment">// slice长度</span></span><br><span class="line">	Capacity 	<span class="keyword">int</span> 		<span class="comment">// slice引用的array size</span></span><br><span class="line">	Elem 	 	*ElemType <span class="comment">// 指向slice第一个元素array中的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接创建slice 等价于:</span></span><br><span class="line"><span class="comment">// tmp := [5]int&#123;2,3,5,7,11&#125;</span></span><br><span class="line"><span class="comment">// a := tmp[0:5]</span></span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>&#125;</span><br><span class="line">b := a[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>此时a,b的sliceHeader示意图为:</p>
<p><img src="/assets/image/201609/go-slice-implement.png" alt=""></p>
<p>由于slice b在slice a中的起始偏移为1，因此 cap(b) = cap(a)-1 = 4。但b只能访问到a[1],a[2]两个元素:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试访问&gt;=length(2)的元素，会触发panic error</span></span><br><span class="line">fmt.Println(b[<span class="number">2</span>])</span><br><span class="line"><span class="comment">// 等价于 c := b[0:len(b)] c和b引用完全相同的数组切片</span></span><br><span class="line">c := b[:]</span><br><span class="line"><span class="comment">// 虽然b只能访问数组[1],[2]两个元素，但d可以在[0,cap(b)]再次切片扩展引用的数组范围</span></span><br><span class="line">d := b[<span class="number">0</span>:<span class="built_in">cap</span>(b)]</span><br><span class="line">fmt.Println(d[<span class="number">3</span>]) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<p>那么slice这种数组切片的概念，究竟带来了什么好处？比如我们有一个操作，要去掉数组的首尾元素，在C中，我们会创建(动态分配)一个新数组，然后将arr[1,n-1)拷贝出来。在C++中，有vector会方便一些，但移除元素会导致后续元素移动拷贝开销。而在Go中，<code>slice = slice[1:len(slice)-1]</code>即可完成操作，这中间不会涉及到内存分配，移动拷贝等，是个非常高效的操作。当然，由于slice是引用的数组元素，因此slice修改数组元素时，对其它引用到该元素的slice也是可见的。</p>
<p>下面来说说slice的值语义。前面提到的sliceHeader，实际就是slice的值语义，我们创建一个slice，在底层就创建了一个sliceHeader结构体。在参数传递时，将会拷贝sliceHeader，但由于sliceHeader中持有指针，因此在调用函数内可修改数组元素，但无法修改sliceHeader结构体的成员值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Extend</span><span class="params">(slice []<span class="keyword">int</span>, element <span class="keyword">int</span> )</span></span>&#123;</span><br><span class="line">	n := <span class="built_in">len</span>(slice)</span><br><span class="line">	slice = slice[<span class="number">0</span> : n+<span class="number">1</span>] <span class="comment">// 不会影响到传入的slice的length</span></span><br><span class="line">	slice[n] = element <span class="comment">// 修改了数组内容，对传入的slice可见</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次摘录一段<a target="_blank" rel="noopener" href="https://blog.golang.org/slices">golang blog</a>关于slice值语义的描述:</p>
<blockquote>
<blockquote>
<p>It’s important to understand that even though a slice contains a pointer, it is itself a value. Under the covers, it is a struct value holding a pointer and a length. It is not a pointer to a struct.</p>
</blockquote>
</blockquote>
<p>BTW，在Go里面的参数传递都是值传递的，只是针对各种类型，其值语义不同，比如int,array它们的值语义就是数据本身，不包含对外的引用(指针)，因此在传参时会完整拷贝整个数据，当然，这里的拷贝是浅拷贝，比如对指针数组这类结构而言，仍然是有副作用的，但这是应用层的东西，就数组容器本身而言，是值拷贝的。而对slice来说，其值语义中包含对数组的引用，因此在传参时，其引用内容可能被修改，但其值语义(sliceHeader)本身仍然是完整拷贝的。</p>
<h4 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h4><p>前面提到slice本质上是数组切片，但slice本身也可以作为动态数组:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">	s := a[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">	fmt.Println(<span class="string">&quot;cap: &quot;</span>,<span class="built_in">cap</span>(s),<span class="string">&quot;len: &quot;</span>,<span class="built_in">len</span>(s),<span class="string">&quot;slice: &quot;</span>,s,<span class="string">&quot;array: &quot;</span>,a)</span><br><span class="line">	<span class="comment">// len=3 cap=5 capacity足够 无需重新分配 因此修改会作用于a之上</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;cap: &quot;</span>,<span class="built_in">cap</span>(s),<span class="string">&quot;len: &quot;</span>,<span class="built_in">len</span>(s),<span class="string">&quot;slice: &quot;</span>,s,<span class="string">&quot;array: &quot;</span>,a)</span><br><span class="line">	<span class="comment">// len=5 cap=5 append通过make()重新分配新的slice 并通过copy()拷贝已有元素</span></span><br><span class="line">	<span class="comment">// 此后s不再指向a 而指向新分配的连续内存空间</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">8</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;cap: &quot;</span>,<span class="built_in">cap</span>(s),<span class="string">&quot;len: &quot;</span>,<span class="built_in">len</span>(s),<span class="string">&quot;slice: &quot;</span>,s,<span class="string">&quot;array: &quot;</span>,a)</span><br><span class="line">	<span class="comment">// 对s的修改将不在作用于a上</span></span><br><span class="line">	s[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;cap: &quot;</span>,<span class="built_in">cap</span>(s),<span class="string">&quot;len: &quot;</span>,<span class="built_in">len</span>(s),<span class="string">&quot;slice: &quot;</span>,s,<span class="string">&quot;array: &quot;</span>,a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="built_in">cap</span>:  <span class="number">5</span> <span class="built_in">len</span>:  <span class="number">3</span> slice:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>] array:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"><span class="built_in">cap</span>:  <span class="number">5</span> <span class="built_in">len</span>:  <span class="number">5</span> slice:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>] array:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line"><span class="built_in">cap</span>:  <span class="number">10</span> <span class="built_in">len</span>:  <span class="number">6</span> slice:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>] array:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line"><span class="built_in">cap</span>:  <span class="number">10</span> <span class="built_in">len</span>:  <span class="number">6</span> slice:  [<span class="number">0</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>] array:  [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>append会在<strong>len(s)+添加的元素个数&gt;cap(s)时</strong>，重新分配(make)一个slice，拷贝(copy)已有元素，添加新元素，最后返回这个新的slice。在使用append时，需要保存其返回值，因为append传入的是slice的值，也就是sliceHeader结构体，当slice capacity扩展时，append函数内不能修改sliceHeader中的Length和Capacity字段，因此需要返回一个新的sliceHeader。</p>
<p>为了避免混淆，不要像上例一样将slice的切片特性和动态数组特性混用，使用动态数组时，使用空的slice(<code>var s []int</code>)或make(<code>make([]int, len, cap)</code>)初始化一个slice会比较好。</p>
<h3 id="3-string"><a href="#3-string" class="headerlink" title="3. string"></a>3. string</h3><p>Go中的string更像是C中的字符串字面量，而不是字符数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hello, 世界&quot;</span></span><br><span class="line"><span class="comment">//str[0] = &#x27;X&#x27; // error 不可改变字符串(类似字面常量)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串可通过 + 进行拼接</span></span><br><span class="line">str += <span class="string">&quot; !&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以ANSI字符遍历 ch是一个byte n=15(每个中文在UTF-8中占3个字节)</span></span><br><span class="line">n := <span class="built_in">len</span>(str)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i&lt; n; i++ &#123;</span><br><span class="line">    ch := str[i]</span><br><span class="line">    fmt.Println(i, ch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以Unicode字符遍历 ch是一个rune 而不是byte 此时遍历得到11个Unicode字符</span></span><br><span class="line"><span class="keyword">for</span> i, ch := <span class="keyword">range</span> str&#123;</span><br><span class="line">    fmt.Println(i, ch)                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实现上，string是个read-only byte slice，另外，string的”sliceHeader”没有capacity字段：</p>
<p><img src="/assets/image/201609/go-string-implement.png" alt=""></p>
<pre><code>s := &quot;hello&quot;
t := s[2:3] // &quot;l&quot;
v := t[0:2] // 没有capacity字段，无法扩展，触发panic error: out of range
</code></pre><p>由于string的slice特性，len(s)操作非常高效，字符串切割也给代码处理带来很高的灵活度，如官方runtime/string.go的atoi函数是这样写的:</p>
<pre><code>func atoi(s string) int&#123;
    n := 0
       for len(s) &gt; 0 &amp;&amp; &#39;0&#39; &lt;= s[0] &amp;&amp; s[0] &lt;= &#39;9&#39; &#123;
        n = n*10 + int(s[0]) - &#39;0&#39;
        s = s[1:]
    &#125;
    return n
&#125;
</code></pre><p>PS，slice的这种切片特性，与Erlang的<a href="http://wudaijun.com/2015/12/erlang-datastructures/#refc-bianry">refc binary和sub binary</a>实现有相似之处，这种高效的处理方案有个老大难问题，那就是slice string未释放，那么它引用的string本身也不会被GC，哪怕只引用了很小一部分。</p>
<h3 id="4-map"><a href="#4-map" class="headerlink" title="4. map"></a>4. map</h3><p>map通过hash表实现，实现位于runtime/hashmap.go，以下是主要字段:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">	bucketCntBits = <span class="number">3</span></span><br><span class="line">	bucketCnt     = <span class="number">1</span> &lt;&lt; bucketCntBits</span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count <span class="keyword">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">	flags <span class="keyword">uint8</span></span><br><span class="line">	B     <span class="keyword">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">	</span><br><span class="line">	evacuate  <span class="keyword">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// A bucket for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">	<span class="comment">// Followed by bucketCnt keys and then bucketCnt values.</span></span><br><span class="line">	<span class="comment">// Followed by an overflow pointer.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>摘自源码注释：</p>
<blockquote>
<blockquote>
<p>A map is just a hash table.  The data is arranged into an array of buckets.  Each bucket contains up to 8 key/value pairs.  The low-order bits of the hash are used to select a bucket.  Each bucket contains a few high-order bits of each hash to distinguish the entries within a single bucket.</p>
<p>If more than 8 keys hash to a bucket, we chain on extra buckets.</p>
<p>When the hashtable grows, we allocate a new array of buckets twice as big.  Buckets are incrementally copied from the old bucket array to the new bucket array.</p>
</blockquote>
</blockquote>
<p>hmap的buckets数组大小为2^B，通过取余(<code>hash(key)&amp;(1&lt;&lt;B-1)</code>)可得到key对应的bucket在buckets数组中的下标，每个bucket可以容纳2^bucketCntBits=8个key/value对，落到该桶的key个数超过8个时，会在堆上分配一个新的bucket，并挂在链表末，因此go hashmap通过链表(8个元素一组)来解决hash碰撞问题。</p>
<p>go的hash map使用的是可扩展hash算法，在负载因子loadFactor(<code>hmap.count/(1&lt;&lt;B)</code>)大于某个值(这个值太大会导致overflow buckets过多，查找效率降低，过小会浪费存储空间，经源码作者测试确认为6.5)时，进行hash扩展。此时B=B&lt;&lt;1，原有buckets由oldbuckets指向，新的buckets重新分配，此时由于hash表大小变更，部分key得到的buckets下标也会改变，因此需要将oldbuckets中的数据按照新的hash表大小重新迁移(evacuate)，出于效率考虑，这个操作是增量进行的，在hash map每次写入时，都会尝试迁移两个bucket(以及后续overflow bucket)，一个是写入的目标bucket(局部迁移)，一个是hmap.evacuate指向的bucket(增量迁移)，这样兼顾局部性和全局性，同时也能保证在新的buckets loadFacotr到达6.5前，所有迁移工作一定能完成。迁移工作完成后，oldbucket置为nil。PS: hash map通过bucket的tophash[0]来标记bucket的迁移状态，保留的标记值为0-3，key的tophash在这个范围内时，会被+4修正</p>
<p>上述是基于go1.5 hashmap实现，在go1.8中，添加了sameSizeGrow，当overflow buckets的数量超过一定数量(2^B)而负载未大于阀值6.5时，此时可能存在部分空的bucket，即bucket未有效利用，这时会触发sameSizeGrow，即B不变，但走数据迁移流程，将oldbuckets的数据重新紧凑排列提高bucket的利用率。当然在sameSizeGrow过程中，不能触发loadFactorGrow。</p>
<p>下面来看个结构图:</p>
<p><img src="/assets/image/201609/go-map-implement.png" alt=""></p>
<p>再来看Key查找过程(简化版):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From go 1.8.1 src/runtime/hashmap.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 并发检查 go hashmap不支持并发访问</span></span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	alg := t.key.alg</span><br><span class="line">	hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">	m := <span class="keyword">uintptr</span>(<span class="number">1</span>)&lt;&lt;h.B - <span class="number">1</span></span><br><span class="line">	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">	<span class="comment">// step1: 找到bucket</span></span><br><span class="line">	<span class="comment">// 如果oldbuckets未迁移完成 则找打oldbuckets中对应的bucket(低B-1位)</span></span><br><span class="line">	<span class="comment">// 否则为buckets中的bucket(低B位)</span></span><br><span class="line">	<span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">			m &gt;&gt;= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		oldb := (*bmap)(add(c, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		<span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">			b = oldb</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	top := <span class="keyword">uint8</span>(hash &gt;&gt; (sys.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line">	<span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">		top += minTopHash</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// step2: 比较tophash</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// dataOffset为key数组在bucket(bmap结构)中的起始偏移</span></span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">				k = *((*unsafe.Pointer)(k))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// step3: 比较key</span></span><br><span class="line">			<span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">				<span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">					v = *((*unsafe.Pointer)(v))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> v</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		b = b.overflow(t)</span><br><span class="line">		<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>限于理解深度，其它一些细节没有提到，比如对不含pointer的key/value优化，另外，go map还针对常用key类型(如int32,int64,string)进行了特例优化，代码位于src/runtime/hashmap_fast.go。以下是上面已经提到的一些小的优化细节：</p>
<ul>
<li>key value采用k1,k2,..v1,v2,…排列，而不是k1,v1,k2,v2，这是出于内存对齐考虑，节约空间</li>
<li>tophash可用于加快key的查找，同时用于标记key的迁移状态</li>
<li>map大小是2的幂，因此hash值可快速求余: hash(key)&amp;(1&lt;&lt;B-1)</li>
<li>hash map的增量式扩展，sameSizeGrow</li>
</ul>
<p>其它:</p>
<ul>
<li>go map不支持并发</li>
<li>go map目前只有扩展 没有收缩操作(shrink)</li>
<li>go map迁移时，会创建新的bucket，而不会复用oldbucket中的overflow bucket(作者TODO里面)</li>
</ul>
<p>值语义：如hmap结构体所示，buckets为bucket指针数组，那么对key,value的操作都是引用语义的。</p>
<h3 id="5-channel"><a href="#5-channel" class="headerlink" title="5. channel"></a>5. channel</h3><p>channel是goroutine用于数据交互的通道，和Erlang的Actor以通信实体为第一类对象不同(Actor模型)，Go以通信介质作为第一类对象(CSP模型)，channel支持多写入者和读取者，并且可通过缓冲来实现同步/异步(一定数量)通信。</p>
<p>在实现上，channel其实就是个消息队列：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分字段</span></span><br><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图描述了一个缓冲区大小为5，并阻塞了若干读goroutine的情况:</p>
<p><img src="/assets/image/201609/go-chan-implement.png" alt=""></p>
<p>该图省略了hchan和sudog的部分字段，waitq在实现上是双向链表，虽然实际只会用到单链表语义(FIFO)。</p>
<p>根据上图情形，此时如果有其它goroutine写入channel:</p>
<ol>
<li>从recvq中pop第一个读写者的sudog</li>
<li>将写入channel的数据拷贝到该sudog的elem字段</li>
<li>唤醒该读写者goroutine(sudog.g)</li>
</ol>
<p>当recvq队列为空，此时写入:</p>
<ol>
<li>将写入的数据缓存到buff[sendx]</li>
<li>sendx环形自增，qcount++</li>
</ol>
<p>当buff缓冲区写满(qcount==dataqsiz)，此时写入:</p>
<ol>
<li>为写入者创建一个sudog，并插入到sendq队列末</li>
<li>挂起该写入者goroutine</li>
</ol>
<p>如果此时有goroutine再次读channel:</p>
<ol>
<li>从buf[recvx]读取第一个数据</li>
<li>从sendq中pop第一个阻塞的写入者goroutine(sudog)</li>
<li>将该sudog中的elem字段数据拷贝到buf[recvx]，相当于将elem数据push到buf末尾</li>
<li>recvx++</li>
<li>唤醒该发送者goroutine</li>
</ol>
<p>没有缓冲的channel(dataqsize==0)操作要简单一些，写入时如果recvq-&gt;first!=nil，则直接拷贝数据到读取者的elem字段，否则将写入者挂起。反之，读写过程也类似。</p>
<p>另外，由于一个goroutine读写多个channel，因此go提供语言级别的select，用于处理异步IO问题。这其实本质上仍然是尝试对channel进行读写操作(chanrecv)，只不过由block参数为false表明该读写不阻塞，当读写操作需要挂起时，立即返回false。而select操作本身其实就是个多分支的if-elseif-else表达式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">src/runtime/<span class="keyword">chan</span>.<span class="keyword">go</span></span><br><span class="line"><span class="comment">// compiler implements</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	select &#123;</span></span><br><span class="line"><span class="comment">//	case c &lt;- v:</span></span><br><span class="line"><span class="comment">//		... foo</span></span><br><span class="line"><span class="comment">//	default:</span></span><br><span class="line"><span class="comment">//		... bar</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// as</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	if selectnbsend(c, v) &#123;</span></span><br><span class="line"><span class="comment">//		... foo</span></span><br><span class="line"><span class="comment">//	&#125; else &#123;</span></span><br><span class="line"><span class="comment">//		... bar</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(t *chantype, c *hchan, elem unsafe.Pointer)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> chansend(t, c, elem, <span class="literal">false</span>, getcallerpc(unsafe.Pointer(&amp;t)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>select的if-elseif-else语句分支顺序是随机的，在每次执行select时会将所有scase(包含hchan)顺序随机排列。参考src/runtime/select.go hselect和scase结构体。</p>
<p>通过<code>cap(chan)</code>和<code>len(chan)</code>可以获取channel的缓冲区大小(dataqsize)和当前消息数量(qcount)。</p>
<h3 id="6-interface"><a href="#6-interface" class="headerlink" title="6. interface"></a>6. interface</h3><p>interface接口的用法和实现放到<a href="http://wudaijun.com/2016/09/go-notes-3-object-oriented/">go面向对象</a>和<a href="http://wudaijun.com/2018/01/go-interface-implement/">go interface实现</a>中。</p>
<h3 id="7-make-amp-new"><a href="#7-make-amp-new" class="headerlink" title="7. make &amp; new"></a>7. make &amp; new</h3><p>go中有make和new两个关键字用于分配一个对象，简要提一下两者的区别：</p>
<p>内建函数 new 用来分配内存，它的第一个参数是一个类型，不是一个值，它的返回值是一个指向新分配类型<strong>零值</strong>的指针</p>
<p>内建函数 make 用来为 slice，map 或 chan 类型分配内存和<strong>初始化</strong>一个对象(目前只能用于这三种类型)，跟 new 类似，第一个参数也是一个类型而不是一个值，跟 new 不同的是，make 返回类型的引用而不是指针，而返回值也依赖于具体传入的类型，具体使用如下：</p>
<pre><code>// 等价于 a := [capacity]int&#123;&#125;  s := a[0:2]
s := make([]int, length [,capacity])
m := make(map[int]string [,size])
c := make(chan int, [,length])
</code></pre><h3 id="8-常量"><a href="#8-常量" class="headerlink" title="8. 常量"></a>8. 常量</h3><p>Go中的常量是无类型的，字面常量(如：3.14, “ok”)是无类型的，可以赋给任何满在其值域中的类型。Go预定义了三个常量：true, false, iota，其中iota是一个可以被编译器修改的常量，它代表一个整数，在每个const出现时被重置为0，然后iota每出现一次，其所代表的值即自增一次。iota通常用来定义枚举值，这类值应用程序不关心具体数值，只需确保其在同一个const枚举声明中不会冲突即可。</p>
<pre><code>const (
    c0 = iota    // c0 == 0
    c1 = iota    // c1 == 1
    c2 = iota    // c2 == 2
)
// 根据枚举定义相同表达式的缩写，等价于
const (
    c0 = iota    // c0 == 0
    c1            // c1 == 1
    c2            // c2 == 2
)
</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wudaijun"
      src="/assets/theme/avatar.png">
  <p class="site-author-name" itemprop="name">wudaijun</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">133</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wudaijun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wudaijun" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/wudaijun" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;wudaijun" rel="noopener" target="_blank"><i class="fab fa-contao fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2014 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wudaijun</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'mcuD0S7ohGooofXt3SJ62qW2-9Nh9j0Va',
      appKey     : 'qvWjHt4jMELAWtqmpdK6Mh9Q',
      placeholder: "Leave something ...",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
